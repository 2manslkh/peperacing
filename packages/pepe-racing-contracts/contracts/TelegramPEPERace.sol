// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function burn(uint256 amount) external;
}
import "@openzeppelin/contracts/access/Ownable.sol";
contract TelegramPEPERace is Ownable {
    enum Suit {
    Spades,
    Hearts,
    Clubs,
    Diamonds
}
    struct BetInfo {
    address player;
    uint256 amount;
}
        struct Game {
        uint256 raceLength;
        uint256 minBet;
        // This is a SHA-256 hash of the random number generated by the bot.
        bytes32[] drawnCards;
        mapping(Suit => BetInfo[]) betsOnSuits;
        bool inProgress;
    }

    address public treasury;
    address public controller;

    IERC20 public immutable bettingToken;

    uint256 public immutable minimumBet;

    // The amount to take as revenue, in basis points.
    uint256 public immutable treasuryBps;

    uint256 public minRaceLength;
    uint256 public maxRaceLength;

    mapping(int64 => Game) public games;

    int64[] public activeTgGroups;

    event Bet(int64 tgChatId, address player, uint256 amount);
    event Win(int64 tgChatId, address player, uint256 amount);
    event GameEnded(int64 tgChatId, Suit winningSuit);
    event GameAborted(int64 tgChatId);
    constructor(
        address payable _bettingToken,
        uint256 _minimumBet,
        uint256 _treasuryBps,
        address _treasury,
        uint256 _minRaceLength,
        uint256 _maxRaceLength,
        address _controller
    ) {
        treasury = _treasury;
        treasuryBps = _treasuryBps;
        bettingToken = IERC20(_bettingToken);
        minimumBet = _minimumBet;
        minRaceLength = _minRaceLength;
        maxRaceLength = _maxRaceLength;
        controller = _controller;

    }
    function isGameInProgress(int64 _tgChatId) public view returns (bool) {
        return games[_tgChatId].inProgress;
    }

    function removeTgId(int64 _tgChatId) internal {
        for (uint256 i = 0; i < activeTgGroups.length; i++) {
            if (activeTgGroups[i] == _tgChatId) {
                activeTgGroups[i] = activeTgGroups[activeTgGroups.length - 1];
                activeTgGroups.pop();
            }
        }
    }

    function newGame(
        int64 _tgChatId,
        uint256 _raceLength,
        uint256 _minBet,
        bytes32[] calldata _drawnCards,
        address[] calldata _players,
        uint256[] calldata _bets,
        Suit[] memory _suits
    ) public returns (uint256[] memory) {
        require(msg.sender == controller, "not controller");
        require(_raceLength <= maxRaceLength, "Race too long");
        require(_raceLength >= minRaceLength, "Race too short");
        require(_minBet >= minimumBet, "Min bet too small");
        require(_players.length == _bets.length && _players.length == _suits.length, "inputs mismatched");
        require(_players.length > 1, "Not enough players");
        require(!isGameInProgress(_tgChatId), "already in progress");
        Game storage g = games[_tgChatId];
        g.raceLength = _raceLength;
        g.minBet = _minBet;
        g.drawnCards = _drawnCards;
        g.inProgress = true;
  
        for (uint16 i = 0; i < _players.length; i++) {
            require(_bets[i] >= _minBet, "Bet too small");
            g.betsOnSuits[_suits[i]].push(BetInfo({
                player: _players[i],
                amount: _bets[i]
            }));

        bool isSent = bettingToken.transferFrom(_players[i], address(this), _bets[i]);
        require(isSent, "Funds transfer failed");

        emit Bet(_tgChatId, _players[i], _bets[i]);
    }

    activeTgGroups.push(_tgChatId);
    return _bets;
    }
  

    function endGame(int64 _tgChatId, Suit winningSuit) public onlyOwner {
    require(isGameInProgress(_tgChatId), "No game in progress for this Telegram chat ID");
    
    Game storage g = games[_tgChatId];
    g.inProgress = false;
    
    uint256 losersTotalBet = 0;
    uint256 winnersTotalBet = 0;

    // Calculate the total losers' and winners' bet
    for (uint8 i = 0; i < 4; i++) {
        for (uint j = 0; j < g.betsOnSuits[Suit(i)].length; j++) {
            if (Suit(i) == winningSuit) {
                winnersTotalBet += g.betsOnSuits[Suit(i)][j].amount;
            } else {
                losersTotalBet += g.betsOnSuits[Suit(i)][j].amount;
            }
        }
    }

    // Deduct 10% for treasury
    uint256 treasuryAmount = (losersTotalBet * treasuryBps) / 100;
    uint256 availableForWinners = losersTotalBet - treasuryAmount;

    bool treasurySent = bettingToken.transfer(treasury, treasuryAmount);
    require(treasurySent, "Transfer to treasury failed");

    // Distribute the remaining losers' bets among the winners
    for (uint j = 0; j < g.betsOnSuits[winningSuit].length; j++) {
        BetInfo storage winningBet = g.betsOnSuits[winningSuit][j];
        
        // Calculate how much each winner gets from the available amount
        uint256 reward = (winningBet.amount * availableForWinners) / winnersTotalBet;

        uint256 totalAmount = winningBet.amount + reward;

        bool isSent = bettingToken.transfer(winningBet.player, totalAmount);
        require(isSent, "Transfer failed for winner");

        emit Win(_tgChatId, winningBet.player, totalAmount);
    }

    emit GameEnded(_tgChatId, winningSuit);
}

    /**
 * @dev Abort a game and refund the bets. Use in emergencies
 *      e.g. bot crash.
 * @param _tgChatId Telegram group of this game
 */
function abortGame(int64 _tgChatId) public onlyOwner {
    require(isGameInProgress(_tgChatId), "No game in progress for this Telegram chat ID");
    
    Game storage g = games[_tgChatId];
    
    // Iterate through each suit and refund the bets for each player
    for (uint8 i = 0; i < 4; i++) {
        Suit currentSuit = Suit(i);
        BetInfo[] storage betsForSuit = g.betsOnSuits[currentSuit];
        for (uint16 j = 0; j < betsForSuit.length; j++) {
            uint256 refundAmount = betsForSuit[j].amount;
            require(bettingToken.transfer(betsForSuit[j].player, refundAmount), "Refund failed");
        }
    }
    
    // Mark the game as not in progress
    g.inProgress = false;
    emit GameAborted(_tgChatId);
}

}
