{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/AtlantisAddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./common/AddressRegistry.sol\";\r\n\r\ncontract AtlantisAddressRegistry is Ownable, AddressRegistry {\r\n    bytes32 private constant ARGONAUTS = \"ARGONAUTS\";\r\n    bytes32 private constant ARGO = \"ARGO\";\r\n    bytes32 private constant XARGO = \"XARGO\";\r\n    bytes32 private constant GOLD = \"GOLD\";\r\n    bytes32 private constant STARDUST = \"STARDUST\";\r\n    bytes32 private constant ATLANTIS = \"ATLANTIS\";\r\n    bytes32 private constant ATLANTIS_PLANETS = \"ATLANTIS_PLANETS\";\r\n    bytes32 private constant STAKING_WITH_LOCK = \"STAKING_WITH_LOCK\";\r\n    bytes32 private constant ATLANTIS_GEMSTONES = \"GEMSTONES\";\r\n    bytes32 private constant ATLANTIS_EQUIPMENTS = \"EQUIPMENTS\";\r\n    bytes32 private constant ATLANTIS_SPACESHIPS = \"SPACESHIPS\";\r\n    bytes32 private constant ATLANTIS_RACING = \"RACING\";\r\n    bytes32 private constant ATLANTIS_MARKETPLACE = \"MARKETPLACE\";\r\n    bytes32 private constant ATLANTIS_AUCTION = \"AUCTION\";\r\n    bytes32 private constant STARDUST_PLEDGING = \"PLEDGING\";\r\n    bytes32 private constant GOLD_STAKING = \"GOLD_STAKING\";\r\n    bytes32 private constant FAUCET = \"FAUCET\";\r\n    mapping(address => bool) private _addresses;\r\n\r\n    function setArgonauts(address contractAddress) external onlyOwner {\r\n        _setAddress(ARGONAUTS, contractAddress);\r\n    }\r\n\r\n    function setArgo(address contractAddress) external onlyOwner {\r\n        _setAddress(ARGO, contractAddress);\r\n    }\r\n\r\n    function setXargo(address contractAddress) external onlyOwner {\r\n        _setAddress(XARGO, contractAddress);\r\n    }\r\n\r\n    function setGold(address contractAddress) external onlyOwner {\r\n        _setAddress(GOLD, contractAddress);\r\n    }\r\n\r\n    function setStardust(address contractAddress) external onlyOwner {\r\n        _setAddress(STARDUST, contractAddress);\r\n    }\r\n\r\n    function setAtlantis(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS, contractAddress);\r\n    }\r\n\r\n    function setAtlantisPlanets(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_PLANETS, contractAddress);\r\n    }\r\n\r\n    function setStakingWithLock(address contractAddress) external onlyOwner {\r\n        _setAddress(STAKING_WITH_LOCK, contractAddress);\r\n    }\r\n\r\n    function setGemstones(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_GEMSTONES, contractAddress);\r\n    }\r\n\r\n    function setEquipments(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_EQUIPMENTS, contractAddress);\r\n    }\r\n\r\n    function setSpaceships(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_SPACESHIPS, contractAddress);\r\n    }\r\n\r\n    function setRacing(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_RACING, contractAddress);\r\n    }\r\n\r\n    function setMarketplace(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_MARKETPLACE, contractAddress);\r\n    }\r\n\r\n    function setAuction(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_AUCTION, contractAddress);\r\n    }\r\n\r\n    function setPledging(address contractAddress) external onlyOwner {\r\n        _setAddress(STARDUST_PLEDGING, contractAddress);\r\n    }\r\n\r\n    function setGoldStaking(address contractAddress) external onlyOwner {\r\n        _setAddress(GOLD_STAKING, contractAddress);\r\n    }\r\n\r\n    function setFaucet(address contractAddress) external onlyOwner {\r\n        _setAddress(FAUCET, contractAddress);\r\n    }\r\n\r\n    function getArgonauts() external view returns (address) {\r\n        return getAddress(ARGONAUTS);\r\n    }\r\n\r\n    function getArgo() external view returns (address) {\r\n        return getAddress(ARGO);\r\n    }\r\n\r\n    function getXargo() external view returns (address) {\r\n        return getAddress(XARGO);\r\n    }\r\n\r\n    function getGold() external view returns (address) {\r\n        return getAddress(GOLD);\r\n    }\r\n\r\n    function getStardust() external view returns (address) {\r\n        return getAddress(STARDUST);\r\n    }\r\n\r\n    function getAtlantis() public view returns (address) {\r\n        return getAddress(ATLANTIS);\r\n    }\r\n\r\n    function getAtlantisPlanets() public view returns (address) {\r\n        return getAddress(ATLANTIS_PLANETS);\r\n    }\r\n\r\n    function getStakingWithLock() external view returns (address) {\r\n        return getAddress(STAKING_WITH_LOCK);\r\n    }\r\n\r\n    function getGemstones() public view returns (address) {\r\n        return getAddress(ATLANTIS_GEMSTONES);\r\n    }\r\n\r\n    function getEquipments() public view returns (address) {\r\n        return getAddress(ATLANTIS_EQUIPMENTS);\r\n    }\r\n\r\n    function getSpaceships() external view returns (address) {\r\n        return getAddress(ATLANTIS_SPACESHIPS);\r\n    }\r\n\r\n    function getRacing() external view returns (address) {\r\n        return getAddress(ATLANTIS_RACING);\r\n    }\r\n\r\n    function getMarketplace() external view returns (address) {\r\n        return getAddress(ATLANTIS_MARKETPLACE);\r\n    }\r\n\r\n    function getAuction() external view returns (address) {\r\n        return getAddress(ATLANTIS_AUCTION);\r\n    }\r\n\r\n    function getPledging() external view returns (address) {\r\n        return getAddress(STARDUST_PLEDGING);\r\n    }\r\n\r\n    function getGoldStaking() external view returns (address) {\r\n        return getAddress(GOLD_STAKING);\r\n    }\r\n\r\n    function getFaucet() external view returns (address) {\r\n        return getAddress(FAUCET);\r\n    }\r\n\r\n    function isControllerContract(address _contractAddress) external view returns (bool) {\r\n        if (\r\n            _contractAddress == getAtlantis() ||\r\n            _contractAddress == getGemstones() ||\r\n            _contractAddress == getAtlantisPlanets() ||\r\n            _contractAddress == getEquipments()\r\n        ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interface/IAtlantisPlanets.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\n\r\nerror AuctionSettled();\r\nerror AuctionNotInitialized();\r\nerror AuctionNotLive();\r\nerror ReservePriceNotMet();\r\nerror IncrementalPriceNotMet();\r\nerror BidsNotSorted();\r\nerror NonExistentBid();\r\nerror AuctionStillLive();\r\nerror WithdrawFailed();\r\nerror BidIncrementTooLow();\r\nerror NotEOA();\r\n\r\ncontract AtlantisAuction is Ownable, ReentrancyGuard {\r\n    struct Bid {\r\n        address bidder;\r\n        uint192 amount;\r\n        uint64 bidTime;\r\n    }\r\n\r\n    struct BidIndex {\r\n        uint8 index;\r\n        bool isSet;\r\n    }\r\n\r\n    event NewBid(address bidder, uint256 value);\r\n    event BidIncreased(address bidder, uint256 oldValue, uint256 increment);\r\n    event AuctionExtended();\r\n\r\n    // The max number of top bids the auction will accept\r\n    uint256 public constant MAX_NUM_BIDS = 8;\r\n\r\n    // The token contract to mint from\r\n    AtlantisAddressRegistry public addressRegistry;\r\n\r\n    // The minimum amount of time left in an auction after a new bid is created\r\n    uint256 public timeBuffer;\r\n\r\n    // The minimum price accepted in an auction\r\n    uint256 public reservePrice;\r\n\r\n    // The minimum percentage difference between the last bid amount and the current bid\r\n    uint8 public minBidIncrementPercentage;\r\n\r\n    // The minimum amount a user needs to submit for a stacked bid\r\n    uint256 public minStackedBidIncrement;\r\n\r\n    // The start time of the auction\r\n    uint256 public startTime;\r\n\r\n    // The end time of the auction\r\n    uint256 public endTime;\r\n\r\n    // Whether or not the auction has settled.\r\n    bool public auctionSettled;\r\n\r\n    // The current highest bids made in the auction\r\n    Bid[MAX_NUM_BIDS] public activeBids;\r\n\r\n    // The mapping between an address and its active bid. The isSet flag differentiates the default\r\n    // uint value 0 from an actual 0 value.\r\n    mapping(address => BidIndex) public bidIndexes;\r\n\r\n    constructor(\r\n        AtlantisAddressRegistry _addressRegistry,\r\n        uint256 _timeBuffer,\r\n        uint256 _reservePrice,\r\n        uint8 _minBidIncrementPercentage,\r\n        uint256 _minStackedBidIncrement,\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    ) {\r\n        addressRegistry = _addressRegistry;\r\n        timeBuffer = _timeBuffer;\r\n        reservePrice = _reservePrice;\r\n        minBidIncrementPercentage = _minBidIncrementPercentage;\r\n        minStackedBidIncrement = _minStackedBidIncrement;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    modifier onlyEOA() {\r\n        if (tx.origin != msg.sender) {\r\n            revert NotEOA();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Handle users' bids\r\n     * @dev Bids must be made while the auction is live. Bids must meet a minimum reserve price.\r\n     *\r\n     * The first 8 bids made will be accepted as valid. Subsequent bids must be a percentage\r\n     * higher than the lowest of the 8 active bids. When a low bid is replaced, the ETH will\r\n     * be refunded back to the original bidder.\r\n     *\r\n     * If a valid bid comes in within the last `timeBuffer` seconds, the auction will be extended\r\n     * for another `timeBuffer` seconds. This will continue until no new active bids come in.\r\n     *\r\n     * If a wallet makes a bid while it still has an active bid, the second bid will\r\n     * stack on top of the first bid. If the second bid doesn't meet the `minStackedBidIncrement`\r\n     * threshold, an error will be thrown. A wallet will only have one active bid at at time.\r\n     */\r\n    function bid() public payable nonReentrant onlyEOA {\r\n        if (auctionSettled) {\r\n            revert AuctionSettled();\r\n        }\r\n        if (startTime == 0 || endTime == 0) {\r\n            revert AuctionNotInitialized();\r\n        }\r\n        require(block.timestamp > startTime || block.timestamp < endTime, \"Auction has ended\");\r\n\r\n        BidIndex memory existingIndex = bidIndexes[msg.sender];\r\n        if (existingIndex.isSet) {\r\n            // Case when the user already has an active bid\r\n            if (msg.value < minStackedBidIncrement || msg.value == 0) {\r\n                revert BidIncrementTooLow();\r\n            }\r\n\r\n            uint192 oldValue = activeBids[existingIndex.index].amount;\r\n            unchecked {\r\n                activeBids[existingIndex.index].amount = oldValue + uint192(msg.value);\r\n            }\r\n            activeBids[existingIndex.index].bidTime = uint64(block.timestamp);\r\n\r\n            emit BidIncreased(msg.sender, oldValue, msg.value);\r\n        } else {\r\n            if (msg.value < reservePrice || msg.value == 0) {\r\n                revert ReservePriceNotMet();\r\n            }\r\n\r\n            uint8 lowestBidIndex = getBidIndexToUpdate();\r\n            uint256 lowestBidAmount = activeBids[lowestBidIndex].amount;\r\n            address lowestBidder = activeBids[lowestBidIndex].bidder;\r\n\r\n            unchecked {\r\n                if (msg.value < lowestBidAmount + (lowestBidAmount * minBidIncrementPercentage) / 100) {\r\n                    revert IncrementalPriceNotMet();\r\n                }\r\n            }\r\n\r\n            // Refund lowest bidder and remove bidIndexes entry\r\n            if (lowestBidder != address(0)) {\r\n                delete bidIndexes[lowestBidder];\r\n                _transferETH(lowestBidder, lowestBidAmount);\r\n            }\r\n\r\n            activeBids[lowestBidIndex] = Bid({\r\n                bidder: msg.sender,\r\n                amount: uint192(msg.value),\r\n                bidTime: uint64(block.timestamp)\r\n            });\r\n\r\n            bidIndexes[msg.sender] = BidIndex({ index: lowestBidIndex, isSet: true });\r\n\r\n            emit NewBid(msg.sender, msg.value);\r\n        }\r\n\r\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\r\n        if (endTime - block.timestamp < timeBuffer) {\r\n            unchecked {\r\n                endTime = block.timestamp + timeBuffer;\r\n            }\r\n            emit AuctionExtended();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the index of the entry in activeBids to update\r\n     * @dev The index to return will be decided by the following rules:\r\n     * If there are less than MAX_NUM_BIDS bids, the index of the first empty slot is returned.\r\n     * If there are MAX_NUM_BIDS or more bids, the index of the lowest value bid is returned. If\r\n     * there is a tie, the most recent bid with the low amount will be returned. If there is a tie\r\n     * among bidTimes, the highest index is chosen.\r\n     */\r\n    function getBidIndexToUpdate() public view returns (uint8) {\r\n        uint256 minAmount = activeBids[0].amount;\r\n        // If the first value is 0 then we can assume that no bids have been submitted\r\n        if (minAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint8 minIndex = 0;\r\n        uint64 minBidTime = activeBids[0].bidTime;\r\n\r\n        for (uint8 i = 1; i < MAX_NUM_BIDS; ) {\r\n            uint256 bidAmount = activeBids[i].amount;\r\n            uint64 bidTime = activeBids[i].bidTime;\r\n\r\n            // A zero bidAmount means the slot is empty because we enforce non-zero bid amounts\r\n            if (bidAmount == 0) {\r\n                return i;\r\n            } else if (bidAmount < minAmount || (bidAmount == minAmount && bidTime >= minBidTime)) {\r\n                minAmount = bidAmount;\r\n                minIndex = i;\r\n                minBidTime = bidTime;\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Get all active bids.\r\n     * @dev Useful for ethers client to get the entire array at once.\r\n     */\r\n    function getAllActiveBids() external view returns (Bid[MAX_NUM_BIDS] memory) {\r\n        return activeBids;\r\n    }\r\n\r\n    /**\r\n     * @notice Settles the auction and mints a skateboard ticket NFT to each winner.\r\n     * @dev Bids will be sorted in descending order off-chain due to constraints with\r\n     * sorting structs on-chain via a field on the struct, however we will validate the\r\n     * input on-chain before minting the NFTs. The input bids must be in descending order\r\n     * by amount and all input bids must correspond to a bid in the `activeBids` mapping.\r\n     * @dev Duplicate bids can be passed in to circumvent the validation logic. We are ok\r\n     * with this loophole since this function is ownerOnly.\r\n     * @dev Settlement is only possible once the auction is over.\r\n     */\r\n    function settleAuction(Bid[MAX_NUM_BIDS] calldata sortedBids) external onlyOwner nonReentrant {\r\n        IAtlantisPlanets planets = IAtlantisPlanets(addressRegistry.getAtlantisPlanets());\r\n\r\n        if (block.timestamp <= endTime) {\r\n            revert AuctionStillLive();\r\n        }\r\n        if (auctionSettled) {\r\n            revert AuctionSettled();\r\n        }\r\n\r\n        // Validate the input bids\r\n        for (uint256 i = 0; i < MAX_NUM_BIDS; ) {\r\n            Bid memory inputBid = sortedBids[i];\r\n            BidIndex memory bidIndex = bidIndexes[inputBid.bidder];\r\n            if (\r\n                !bidIndex.isSet ||\r\n                activeBids[bidIndex.index].bidder != inputBid.bidder ||\r\n                activeBids[bidIndex.index].amount != inputBid.amount ||\r\n                activeBids[bidIndex.index].bidTime != inputBid.bidTime\r\n            ) {\r\n                revert NonExistentBid();\r\n            }\r\n\r\n            // The zero-th index has nothing to compare against\r\n            if (i != 0) {\r\n                Bid memory prevBid = sortedBids[i - 1];\r\n                if (inputBid.amount > prevBid.amount) {\r\n                    revert BidsNotSorted();\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        // Get addresses from bids\r\n        address[MAX_NUM_BIDS] memory winners;\r\n        for (uint256 i = 0; i < MAX_NUM_BIDS; ) {\r\n            winners[i] = sortedBids[i].bidder;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Mint tickets to auction winners\r\n        // planets.epicMint(winners);\r\n\r\n        auctionSettled = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ETH to a specified address.\r\n     * @dev This function can only be called internally.\r\n     */\r\n    function _transferETH(address to, uint256 value) internal returns (bool) {\r\n        (bool success, ) = to.call{ value: value, gas: 30000 }(new bytes(0));\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the start and end time of the auction.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setAuctionTimes(uint256 _startTime, uint256 _endTime) external onlyOwner {\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction time buffer.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\r\n        timeBuffer = _timeBuffer;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction reserve price.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\r\n        reservePrice = _reservePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction minimum bid increment percentage.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external onlyOwner {\r\n        minBidIncrementPercentage = _minBidIncrementPercentage;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction replacing bid buffer amount.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setMinReplacementIncrease(uint256 _minStackedBidIncrement) external onlyOwner {\r\n        minStackedBidIncrement = _minStackedBidIncrement;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws the contract value to the owner\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        bool success = _transferETH(msg.sender, address(this).balance);\r\n        if (!success) {\r\n            revert WithdrawFailed();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/AddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ncontract AddressRegistry {\r\n    mapping(bytes32 => address) public addresses;\r\n\r\n    function getAddress(bytes32 _identifier) public view returns (address) {\r\n        return addresses[_identifier];\r\n    }\r\n\r\n    function _setAddress(bytes32 _identifier, address contractAddress) internal {\r\n        addresses[_identifier] = contractAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/common/AtlantisLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nlibrary AtlantisLib {\r\n    enum Orbit {\r\n        COMMON, // 0\r\n        UNCOMMON, // 1\r\n        RARE, // 2\r\n        EPIC // 3\r\n    }\r\n\r\n    enum OrbitName {\r\n        HALO_RING, //0\r\n        PANDORA, //1\r\n        ATLAS, //2\r\n        METIS, //3\r\n        ENTWINED, //4\r\n        RAINBOW_CLOUDS, //5\r\n        GALATICA, //6\r\n        ASTEROIDS, //7\r\n        INTERSTELLAR_PINK, //8\r\n        INTERSTELLAR_GRADIENT, //9\r\n        // Epic planets\r\n        INTERSTELLAR_GOLD //10\r\n    }\r\n\r\n    enum Background {\r\n        PURPLE_HUES, //0\r\n        BROWN_HUES, //1\r\n        WAVY, //2\r\n        SHOOTING_STARS, //3\r\n        // Epic planets\r\n        GOLD_HUES, //4\r\n        GOLD_SHOOTING_STARS, //5\r\n        WAVY_GOLD, //6\r\n        GOLD_SKIES //7\r\n    }\r\n\r\n    enum Evolution {\r\n        ALPHA, // 1-19\r\n        BETA, // 20-29\r\n        GAMMA, // 30-39\r\n        DELTA, // 40-49\r\n        EPSILON // 50\r\n    }\r\n\r\n    enum Element {\r\n        FIRE, // 0\r\n        LIGHTNING, // 1\r\n        STEEL // 2\r\n    }\r\n\r\n    struct Planet {\r\n        uint8 level; // Max Level: 50\r\n        Element element;\r\n        Orbit orbit;\r\n        OrbitName orbitName;\r\n        Background background;\r\n        bool onExpedition;\r\n    }\r\n\r\n    enum Rarity {\r\n        COMMON,\r\n        UNCOMMON,\r\n        RARE,\r\n        EPIC\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet element as string\r\n     */\r\n    function _planetElementToString(AtlantisLib.Element element) internal pure returns (string memory) {\r\n        if (element == AtlantisLib.Element.FIRE) {\r\n            return \"Fire\";\r\n        } else if (element == AtlantisLib.Element.STEEL) {\r\n            return \"Steel\";\r\n        } else if (element == AtlantisLib.Element.LIGHTNING) {\r\n            return \"Lightning\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     */\r\n    function _planetOrbitToString(AtlantisLib.Orbit orbit) internal pure returns (string memory) {\r\n        if (orbit == AtlantisLib.Orbit.COMMON) {\r\n            return \"Common\";\r\n        } else if (orbit == AtlantisLib.Orbit.UNCOMMON) {\r\n            return \"Uncommon\";\r\n        } else if (orbit == AtlantisLib.Orbit.RARE) {\r\n            return \"Rare\";\r\n        } else if (orbit == AtlantisLib.Orbit.EPIC) {\r\n            return \"Epic\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get tier of equipment based on level\r\n     * @param level Level of an equipment\r\n     */\r\n    function _getEquipmentTier(uint8 level) internal pure returns (AtlantisLib.Rarity tier) {\r\n        if (level < 1) {\r\n            tier = AtlantisLib.Rarity.COMMON;\r\n        } else if (level >= 1 && level < 5) {\r\n            tier = AtlantisLib.Rarity.UNCOMMON;\r\n        } else if (level >= 5 && level < 8) {\r\n            tier = AtlantisLib.Rarity.RARE;\r\n        } else if (level >= 8 && level <= 10) {\r\n            tier = AtlantisLib.Rarity.EPIC;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     */\r\n    function _planetOrbitTypeToString(AtlantisLib.OrbitName orbitName) internal pure returns (string memory) {\r\n        if (orbitName == AtlantisLib.OrbitName.HALO_RING) {\r\n            return \"Halo Ring\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.PANDORA) {\r\n            return \"Pandora\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.ATLAS) {\r\n            return \"Atlas\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.METIS) {\r\n            return \"Metis\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.ENTWINED) {\r\n            return \"Entwined\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.RAINBOW_CLOUDS) {\r\n            return \"Rainbow Clouds\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.GALATICA) {\r\n            return \"Galatica\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.ASTEROIDS) {\r\n            return \"Asteroids\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.INTERSTELLAR_PINK) {\r\n            return \"Interstellar Pink\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.INTERSTELLAR_GRADIENT) {\r\n            return \"Interstellar Gradient\";\r\n            // Epic planets\r\n        } else if (orbitName == AtlantisLib.OrbitName.INTERSTELLAR_GOLD) {\r\n            return \"Interstellar Gold\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     */\r\n    function _planetBackgroundToString(AtlantisLib.Background background) internal pure returns (string memory) {\r\n        if (background == AtlantisLib.Background.PURPLE_HUES) {\r\n            return \"Purple Hues\";\r\n        } else if (background == AtlantisLib.Background.BROWN_HUES) {\r\n            return \"Brown Hues\";\r\n        } else if (background == AtlantisLib.Background.WAVY) {\r\n            return \"Wavy\";\r\n        } else if (background == AtlantisLib.Background.SHOOTING_STARS) {\r\n            return \"Shooting Stars\";\r\n            // Epic planets\r\n        } else if (background == AtlantisLib.Background.WAVY_GOLD) {\r\n            return \"Wavy Gold\";\r\n        } else if (background == AtlantisLib.Background.GOLD_SHOOTING_STARS) {\r\n            return \"Gold Shooting Stars\";\r\n        } else if (background == AtlantisLib.Background.GOLD_HUES) {\r\n            return \"Gold Hues\";\r\n        } else if (background == AtlantisLib.Background.GOLD_SKIES) {\r\n            return \"Gold Skies\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/interface/IAtlantisPlanets.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n// Import AtlantisLib\r\nimport { AtlantisLib } from \"../common/AtlantisLib.sol\";\r\n\r\ninterface IAtlantisPlanets is IERC721 {\r\n    error AuctionSettled();\r\n\r\n    /**\r\n     * The signature must be by the correct signer\r\n     */\r\n    error InvalidSignature();\r\n\r\n    /**\r\n     * The minting stage must be correct\r\n     */\r\n    error InvalidStage(uint8 currentStage, uint8 requiredStage);\r\n\r\n    /**\r\n     * The collection has exceeded the max supply\r\n     */\r\n    error ExceededMaxSupply();\r\n\r\n    /**\r\n     * The user has exceeded allowed mint count\r\n     */\r\n    error ExceedMaxMintPerWallet();\r\n\r\n    /**\r\n     * The planet has exceeded the max level\r\n     */\r\n    error ExceededMaxLevel();\r\n\r\n    /**\r\n     * Error thrown when user queries an unknown OrbitId\r\n     */\r\n    error UnknownOrbit();\r\n\r\n    /**\r\n     * Error thrown when user queries an unknown ElementId\r\n     */\r\n    error UnknownElement();\r\n\r\n    /**\r\n     * Error thrown when user queries an unknown PlanetId\r\n     */\r\n    error InvalidUpgradeLevel(uint8 currentLevel, uint8 newLevel);\r\n    /**\r\n     * User is not the owner of planet\r\n     */\r\n    error NotOwnerOfPlanet();\r\n\r\n    error InsufficientCRO(uint256 amountPaid, uint256 amountRequired);\r\n\r\n    error InvalidInput();\r\n\r\n    function upgradePlanet(uint256 _tokenId, uint8 _levels) external;\r\n\r\n    function getUpgradeCosts(\r\n        uint256 _tokenId,\r\n        uint8 _levels\r\n    ) external view returns (uint256 stardustCost, uint256 xArgoCost, uint16[4] memory gemstoneRequirements);\r\n\r\n    function getPlanetDetails(uint256 _planetId) external view returns (AtlantisLib.Planet memory);\r\n\r\n    function setPlanetElements(uint256[] memory _tokenIds, AtlantisLib.Element[] memory _gemstoneType) external;\r\n\r\n    function setPlanetOrbits(uint256[] memory _tokenIds, AtlantisLib.Orbit[] memory _planetsOrbit) external;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}