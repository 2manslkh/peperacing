{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Airdropper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\n// Import IERC20, IERC721, IERC1155\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\n\r\ncontract Airdropper {\r\n    /**\r\n     * @dev Airdrop ERC20 tokens\r\n     * @param token The address of the ERC20 token\r\n     * @param _addresses The addresses of the recipients\r\n     * @param _amounts The amounts of tokens to send\r\n     */\r\n    function airdropERC20(IERC20 token, address[] calldata _addresses, uint256[] calldata _amounts) external {\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            token.transferFrom(msg.sender, _addresses[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Airdrop ERC721 tokens\r\n     * @param token The address of the ERC721 token\r\n     * @param _addresses The addresses of the recipients\r\n     * @param _tokenIds The token IDs of the tokens to send\r\n     */\r\n    function airdropERC721(IERC721 token, address[] calldata _addresses, uint256[] calldata _tokenIds) external {\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            token.transferFrom(msg.sender, _addresses[i], _tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Airdrop ERC1155 tokens\r\n     * @param token The address of the ERC1155 token\r\n     * @param _addresses The addresses of the recipients\r\n     * @param _tokenIds The token IDs of the tokens to send\r\n     * @param _amounts The amounts of tokens to send\r\n     */\r\n    function airdropERC1155(\r\n        IERC1155 token,\r\n        address[] calldata _addresses,\r\n        uint256[] calldata _tokenIds,\r\n        uint256[] calldata _amounts\r\n    ) external {\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            token.safeTransferFrom(msg.sender, _addresses[i], _tokenIds[i], _amounts[i], \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Airdrop ETH\r\n     * @param _addresses The addresses of the recipients\r\n     * @param _amounts The amounts of ETH to send\r\n     */\r\n    function airdropETH(address[] calldata _addresses, uint256[] calldata _amounts) external payable {\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            payable(_addresses[i]).transfer(_amounts[i]);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/AtlanteanTrove.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/// @title AtlanteanTrove Quest Rewards Claiming Contract\r\n/// @author Kratos\r\n/*\r\n                                                  #                             \r\n                                               .%%%%%%%%                        \r\n                                                %%%%%%%%%,                      \r\n                                               /%%%%%%%%%                       \r\n                                               %%%%%%%%%%                       \r\n                                               %%%%%%%%%(                       \r\n                                              (%%%%%%%%%                        \r\n                                              %%%%%%%%%#                        \r\n                                             %%%%%%%%%%                         \r\n                                            #%%%%%%%%%%                         \r\n                                  *%&/ *   #%%%%%%%%%% #,.#.                    \r\n                   .            ,         %%%%%%%%%%% .@@@#                     \r\n                   @&@@@#,     @         %%%%%%%%%%%                            \r\n                              @         %%%%%%%%%%%%       #,                   \r\n                   , .       @            %%%%%%%%%%%#                          \r\n                 ,   ,%.    .               %%%%%%%%%%% /@@@@@ *                \r\n                   @@@@@@@@@@              * /%%%%%%@@@@( &@@@@                 \r\n                  @@@&@        @@@/ .@*     @@%@@@%%%&@@@%  %.    @             \r\n            @      @@@@&( @@@   @@@@@@      @@@@@@   @@.(&.       @             \r\n           (@  / .(   %@@@@@@%(@@@@@@         @@@.%%%%%%%%%*      @@@           \r\n           @@@  #       @//  **@@@   @      @      %&%%%#%%%%,    @@/           \r\n           @@@   @      @             @    @        (%%%&%%%%     @@@,          \r\n         %@@@@@  @@    @.             .    @          %%%%%/     @@@@@          \r\n         @@@.@@@ @@@@   %@        @, (       ( @      .%%%   &@ @@@@@@          \r\n         &@@@#@@@@/.@@@          ,               (     /%# ,@/ @@@@@@@          \r\n        @&@@#@@*@&@@@ @@@@@&    (#.@          @@@    #  #  @  @@@@@@@@,         \r\n        (@@@@@@@@@@@@@@ @@     &@&@@@@%     (@@@@@@@        @@@@@@@(@@@         \r\n        @@@,@@@@*@@&@@@@.@@@ @@*@@.@*@@@@@&(@@@@@@@@@@@(   @@@@/@@@ @@          \r\n         @@@@@@@&@%@@@@@@@@@ @/.@#@@@@@@(@@ @@@@@@*@*@@@@@@@@@..@@@.@@@(        \r\n         @@@@@@,@@@@@%@@@ @ @.&@@@,@ @@.@@@@@/(@@@.@@@@@@@@@(@@@(@@@*@@         \r\n         @@@@ @@@@@@#@#@.@@*@((@@&@@,#        #@&@@@@%@@@@@@,@#@@@@@@@ &        \r\n         @@@@@@@@(@@@&@@@@@@@@@@@    ,  .,.#//(& @*@@@#@@ @@@,@@@.@@@@#         \r\n         @@@(@@@@@@@@@@ @,@@@@@@@,@@@@@@@@@@@@@#@@/@@@@@@@@@@@@&@@@@@@          \r\n          ,@ @@@@@@@@@@ @@@@@@@@@@@@@@@@@@@,@@#@@@@@@@@@@,@@@@@@/@@@@           \r\n            @#@@@@(@@@ @@, @@@@@@@@*@@@@@.@@(@@@@*@ @@@@@@@@@@@@(@@             \r\n              @@@@@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ .            \r\n               @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@%@@@@/@@@@@@,@@@@&              \r\n                @@ @@@%@@&@@.@@@@*@@@#@@@@@@@@.@@@@@@@@#%@@@@@@@@               \r\n                  @@@@@@@@@@@@@ @@@@ @@@,(@@@@@@@@@@@@@@@#@@@ #                 \r\n                    @@@@@@@@@@,@@@@@&@@@@@@@@@@@@@@@@@.@@@@@                    \r\n                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@@@                      \r\n                        @ @@@@@@@,@@@@@@@#@@@@@@@@@ (@@@*                       \r\n                         @@@(@@@@@ @@@*@@@@@@@@@@,@@@&&                         \r\n                            @@@@@@@@@@ @@@@@@@@@@@@@@                           \r\n                               @@(@@@@@@@@@@@(@@@@@@                            \r\n                                  @.@@@@*@@&.@@@@@*      \r\n*/\r\n\r\ncontract AtlanteanTrove is IERC1155Receiver, ReentrancyGuard {\r\n    using ECDSA for bytes32;\r\n\r\n    /// @notice Mapping of round to user address to their claim status\r\n    mapping(uint256 => mapping(address => bool)) private hasClaimed;\r\n\r\n    /// @notice Mapping of round to Round details\r\n    mapping(uint256 => Round) public roundTime;\r\n\r\n    /// @notice Mapping to track each round rewards\r\n    mapping(uint256 => Reward) internal roundRewards;\r\n\r\n    /// @notice Mapping to track each round amounts\r\n    mapping(uint256 => Amount) internal roundAmounts;\r\n\r\n    /// @notice Variable to track current round\r\n    uint256 public currentRound = 0;\r\n\r\n    /// @notice The address of the admin\r\n    address public admin;\r\n\r\n    /// @notice The address of the controller\r\n    address public controller;\r\n\r\n    /// @notice The address of the whitelist signer\r\n    address private whitelistSignerAddress;\r\n\r\n    /// Reward structs\r\n\r\n    /// @notice Defines how much a single instance of claimable ERC-20 reward is worth\r\n    struct RewardERC20 {\r\n        address tokenAddress;\r\n        uint256 amount;\r\n    }\r\n\r\n    /// @notice Defines how much a single instance of claimable ERC-721 reward is worth\r\n    struct RewardERC721 {\r\n        address tokenAddress;\r\n        uint256[] tokenIds;\r\n        uint256 index;\r\n    }\r\n\r\n    /// @notice Defines how much a single instance of claimable ERC-1155 reward is worth\r\n    struct RewardERC1155 {\r\n        address tokenAddress;\r\n        uint256[] tokenIds;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    /// @notice Defines how much a single instance of total rewards claimable is worth\r\n    struct Reward {\r\n        RewardERC20[] erc20Rewards;\r\n        RewardERC721[] erc721Rewards;\r\n        RewardERC1155[] erc1155Rewards;\r\n    }\r\n\r\n    /// Accounting structs\r\n\r\n    /// @notice Struct used to track amount of ERC-20 in the contract in a specific round\r\n    struct RewardERC20Amount {\r\n        address tokenAddress;\r\n        uint256 amount;\r\n    }\r\n\r\n    /// @notice Struct used to track amount of ERC-721 in the contract in a specific round\r\n    struct RewardERC721Amount {\r\n        address tokenAddress;\r\n        uint256 amount;\r\n    }\r\n\r\n    /// @notice Struct used to track amount of ERC-1155 in the contract in a specific round\r\n    struct RewardERC1155Amount {\r\n        address tokenAddress;\r\n        uint256 tokenId;\r\n        uint256 amount;\r\n    }\r\n\r\n    /// @notice Struct used to track amount of rewards in the contract in a specific round\r\n    struct Amount {\r\n        RewardERC20Amount[] erc20Amount;\r\n        RewardERC721Amount[] erc721Amount;\r\n        RewardERC1155Amount[][] erc1155Amount;\r\n    }\r\n\r\n    /// @notice Struct used for managing rewards by admin\r\n    struct RewardData {\r\n        uint256 round;\r\n        RewardERC20[] erc20Rewards;\r\n        uint256[] erc20Amounts;\r\n        RewardERC721[] erc721Rewards;\r\n        uint256[] erc721Amounts;\r\n        RewardERC1155[] erc1155Rewards;\r\n        uint256[][] erc1155Amounts;\r\n    }\r\n\r\n    /// @notice Struct used for managing rounds\r\n    struct Round {\r\n        uint256 startTime;\r\n        uint256 expiryTimestamp;\r\n    }\r\n\r\n    // Events\r\n    event SetRoundExpiry(uint256 round, uint256 expiryTimestamp);\r\n    event SetController(address controller);\r\n    event SetAdmin(address admin);\r\n    event SetWhitelistSignerAddress(address whitelistSignerAddress);\r\n    event StartNewRound(uint256 round, uint256 startTime, uint256 expiryTimestamp);\r\n    event ClaimRewards(uint256 round, address indexed user, Amount amount);\r\n    event AddRewards(uint256 round, RewardData rewardData);\r\n    event RemoveRewards(uint256 round, RewardData rewardData);\r\n\r\n    constructor(address _controller, address _whitelistSignerAddress) {\r\n        admin = msg.sender;\r\n        controller = _controller;\r\n        whitelistSignerAddress = _whitelistSignerAddress;\r\n    }\r\n\r\n    // Modifiers\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin can call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == controller, \"Only controller can call this function.\");\r\n        _;\r\n    }\r\n\r\n    // Admin functions\r\n\r\n    /**\r\n     * @dev Set round expiry timestamp\r\n     * @param _round Round number\r\n     * @param expiryTimestamp Expiry timestamp for the round\r\n     */\r\n    function setRoundExpiry(uint256 _round, uint256 expiryTimestamp) external onlyAdmin {\r\n        // Round expiry can only be set in the future\r\n        require(expiryTimestamp > block.timestamp, \"Expiry timestamp must be in future.\");\r\n        // Set round expiry timestamp\r\n        roundTime[_round].expiryTimestamp = expiryTimestamp;\r\n        // Emit event\r\n        emit SetRoundExpiry(_round, expiryTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Set address of controller EOA\r\n     * @param _controller Address of controller EOA\r\n     */\r\n    function setController(address _controller) external onlyAdmin {\r\n        // Set controller address\r\n        controller = _controller;\r\n        // Emit event\r\n        emit SetController(_controller);\r\n    }\r\n\r\n    /**\r\n     * @dev Set address of admin EOA\r\n     * @param _admin Address of admin EOA\r\n     */\r\n    function setAdmin(address _admin) external onlyAdmin {\r\n        // Set admin address\r\n        admin = _admin;\r\n        // Emit event\r\n        emit SetAdmin(_admin);\r\n    }\r\n\r\n    /**\r\n     * @dev Set new whitelist signer address\r\n     * @param _whitelistSignerAddress Address of new whitelist signer\r\n     */\r\n    function setWhitelistSignerAddress(address _whitelistSignerAddress) external onlyAdmin {\r\n        // Set whitelist signer address\r\n        whitelistSignerAddress = _whitelistSignerAddress;\r\n        // Emit event\r\n        emit SetWhitelistSignerAddress(_whitelistSignerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Top up rewards for a round, only for admin\r\n     * @param data Reward data\r\n     */\r\n    function topUpRewards(RewardData calldata data) external onlyAdmin {\r\n        // Handle ERC20 rewards\r\n        if (data.erc20Rewards.length > 0) {\r\n            _handleERC20Rewards(data);\r\n        }\r\n        // Handle ERC721 rewards\r\n        if (data.erc721Rewards.length > 0) {\r\n            _handleERC721Rewards(data);\r\n        }\r\n        // Handle ERC1155 rewards\r\n        if (data.erc1155Rewards.length > 0) {\r\n            _handleERC1155Rewards(data);\r\n        }\r\n\r\n        // Emit event\r\n        emit AddRewards(data.round, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove rewards for a round, only for admin\r\n     * @param data Reward data\r\n     */\r\n    function removeRewards(RewardData calldata data) external onlyAdmin {\r\n        // Cannot remove rewards if round is already started\r\n        require(data.round != currentRound, \"Cannot modify rewards for ongoing round.\");\r\n        // Remove ERC20 rewards and transfer back to admin\r\n        if (roundRewards[data.round].erc20Rewards.length > 0) {\r\n            // Transfer rewards to admin\r\n            for (uint256 i = 0; i < roundRewards[data.round].erc20Rewards.length; ) {\r\n                require(\r\n                    IERC20(roundRewards[data.round].erc20Rewards[i].tokenAddress).transfer(\r\n                        admin,\r\n                        roundAmounts[data.round].erc20Amount[i].amount\r\n                    ),\r\n                    \"Transfer failed.\"\r\n                );\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            // If round is not in the past, delete rewards\r\n            if (data.round > currentRound) {\r\n                delete roundRewards[data.round].erc20Rewards;\r\n            }\r\n        }\r\n        // Remove ERC721 rewards and transfer back to admin\r\n        if (roundRewards[data.round].erc721Rewards.length > 0) {\r\n            // Transfer rewards to admin\r\n\r\n            for (uint256 i = 0; i < roundRewards[data.round].erc721Rewards.length; ) {\r\n                uint256 _index = roundRewards[data.round].erc721Rewards[i].index;\r\n                for (\r\n                    uint256 j = 0;\r\n                    j <\r\n                    roundRewards[data.round].erc721Rewards[i].tokenIds.length -\r\n                        roundRewards[data.round].erc721Rewards[i].index;\r\n\r\n                ) {\r\n                    IERC721(roundRewards[data.round].erc721Rewards[i].tokenAddress).transferFrom(\r\n                        address(this),\r\n                        admin,\r\n                        roundRewards[data.round].erc721Rewards[i].tokenIds[_index]\r\n                    );\r\n                    unchecked {\r\n                        _index++;\r\n                        j++;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            // If round is not in the past, delete rewards\r\n            if (data.round > currentRound) {\r\n                delete roundRewards[data.round].erc721Rewards;\r\n            }\r\n        }\r\n\r\n        // Remove ERC1155 rewards and transfer back to admin\r\n        if (roundRewards[data.round].erc1155Rewards.length > 0)\r\n            // Transfer rewards to admin\r\n            for (uint256 i = 0; i < roundRewards[data.round].erc1155Rewards.length; ) {\r\n                for (uint256 j = 0; j < roundRewards[data.round].erc1155Rewards[i].tokenIds.length; ) {\r\n                    IERC1155(roundRewards[data.round].erc1155Rewards[i].tokenAddress).safeTransferFrom(\r\n                        address(this),\r\n                        admin,\r\n                        roundRewards[data.round].erc1155Rewards[i].tokenIds[j],\r\n                        data.erc1155Amounts[i][j],\r\n                        \"\"\r\n                    );\r\n                    unchecked {\r\n                        j++;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    i++;\r\n                }\r\n\r\n                if (data.round > currentRound) // If round is not in the past, delete rewards\r\n                {\r\n                    delete roundRewards[data.round].erc1155Rewards;\r\n                }\r\n            }\r\n        emit RemoveRewards(data.round, data);\r\n    }\r\n\r\n    // Controller functions\r\n\r\n    /**\r\n     * @dev Start a new round for controller only\r\n     * @param expiryTimestamp Expiry timestamp for the round\r\n     */\r\n    function startNewRound(uint256 startTime, uint256 expiryTimestamp) external onlyController {\r\n        // Timestamp must be in future\r\n        require(expiryTimestamp > block.timestamp, \"Expiry timestamp must be in future.\");\r\n        // Increment currentRound\r\n        currentRound++;\r\n        // Save round details\r\n        roundTime[currentRound] = Round(startTime, expiryTimestamp);\r\n        // Emit event\r\n        emit StartNewRound(currentRound, startTime, expiryTimestamp);\r\n    }\r\n\r\n    // View functions\r\n\r\n    /**\r\n     * @notice Get user claim status for a round\r\n     * @param _round Round number\r\n     * @param user Address of user\r\n     */\r\n    function hasUserClaimed(uint256 _round, address user) public view returns (bool) {\r\n        return hasClaimed[_round][user];\r\n    }\r\n\r\n    /**\r\n     * @notice Get round rewards\r\n     * @param _round Round number\r\n     */\r\n    function getRoundRewards(uint256 _round) external view returns (Reward memory) {\r\n        return roundRewards[_round];\r\n    }\r\n\r\n    /**\r\n     * @notice Get round amounts\r\n     * @param _round Round number\r\n     */\r\n    function getRoundAmounts(uint256 _round) external view returns (Amount memory) {\r\n        return roundAmounts[_round];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the the signature is signed by a valid signer for whitelist\r\n     * @param sender Address of minter\r\n     * @param _round Round number\r\n     * @param nonce Random bytes32 nonce\r\n     * @param signature Signature generated off-chain\r\n     */\r\n    function whitelistSigned(\r\n        address sender,\r\n        uint256 _round,\r\n        bytes memory nonce,\r\n        bytes memory signature\r\n    ) public view returns (bool) {\r\n        bytes32 hash = keccak256(abi.encodePacked(sender, nonce, _round));\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        hash = keccak256(abi.encodePacked(prefix, hash));\r\n        return whitelistSignerAddress == hash.recover(signature);\r\n    }\r\n\r\n    /**\r\n     * @dev Claims rewards for a round\r\n     * @param _round Round number\r\n     * @param nonce Random bytes32 nonce\r\n     * @param signature Signature generated off-chain\r\n     */\r\n    function claimRewards(uint256 _round, bytes memory nonce, bytes memory signature) external nonReentrant {\r\n        // Check if user is whitelisted\r\n        require(whitelistSigned(msg.sender, _round, nonce, signature), \"Invalid Signature!\");\r\n        // Check if user has already claimed\r\n        require(!hasUserClaimed(_round, msg.sender), \"User has already claimed rewards.\");\r\n        // Check if round has expired\r\n        require(block.timestamp <= roundTime[_round].expiryTimestamp, \"Round has expired.\");\r\n        // Check if round has started\r\n        require(block.timestamp >= roundTime[_round].startTime, \"Round has not started.\");\r\n        // Mark user as claimed\r\n        hasClaimed[_round][msg.sender] = true;\r\n        // Get round reward info\r\n        // Reward memory reward = roundRewards[_round];\r\n        // Get round amounts info\r\n        //  Amount memory amount = roundAmounts[_round];\r\n        // Initialise variables for events logging\r\n        Amount memory claimedAmounts;\r\n        claimedAmounts.erc20Amount = new RewardERC20Amount[](roundRewards[_round].erc20Rewards.length);\r\n        claimedAmounts.erc721Amount = new RewardERC721Amount[](roundRewards[_round].erc721Rewards.length);\r\n        claimedAmounts.erc1155Amount = new RewardERC1155Amount[][](roundRewards[_round].erc1155Rewards.length);\r\n\r\n        // If there are ERC20 token rewards, transfer\r\n        if (roundRewards[_round].erc20Rewards.length > 0) {\r\n            for (uint256 i = 0; i < roundRewards[_round].erc20Rewards.length; ) {\r\n                // Reduce amount of reward amount after transfer\r\n                roundAmounts[_round].erc20Amount[i].amount -= roundRewards[_round].erc20Rewards[i].amount;\r\n                // Record amount for event logging\r\n                claimedAmounts.erc20Amount[i].tokenAddress = roundRewards[_round].erc20Rewards[i].tokenAddress;\r\n                claimedAmounts.erc20Amount[i].amount = roundRewards[_round].erc20Rewards[i].amount;\r\n                require(\r\n                    IERC20(roundRewards[_round].erc20Rewards[i].tokenAddress).transfer(\r\n                        msg.sender,\r\n                        roundRewards[_round].erc20Rewards[i].amount\r\n                    ),\r\n                    \"Transfer failed\"\r\n                );\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If there are ERC721 token rewards, transfer\r\n        if (roundRewards[_round].erc721Rewards.length > 0) {\r\n            for (uint256 i = 0; i < roundRewards[_round].erc721Rewards.length; ) {\r\n                // Reduce amount of reward amount after transfer\r\n                roundAmounts[_round].erc721Amount[i].amount -= 1;\r\n                // Record amount for event logging\r\n                claimedAmounts.erc721Amount[i].tokenAddress = roundRewards[_round].erc721Rewards[i].tokenAddress;\r\n                claimedAmounts.erc721Amount[i].amount = 1;\r\n                IERC721(roundRewards[_round].erc721Rewards[i].tokenAddress).transferFrom(\r\n                    address(this),\r\n                    msg.sender,\r\n                    roundRewards[_round].erc721Rewards[i].tokenIds[roundRewards[_round].erc721Rewards[i].index]\r\n                );\r\n                // Increment index\r\n                unchecked {\r\n                    roundRewards[_round].erc721Rewards[i].index++;\r\n                }\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If there are ERC1155 token rewards, transfer\r\n        if (roundRewards[_round].erc1155Rewards.length > 0) {\r\n            for (uint256 i = 0; i < roundRewards[_round].erc1155Rewards.length; ) {\r\n                claimedAmounts.erc1155Amount[i] = new RewardERC1155Amount[](\r\n                    roundRewards[_round].erc1155Rewards[i].tokenIds.length\r\n                );\r\n                for (uint256 j = 0; j < roundRewards[_round].erc1155Rewards[i].tokenIds.length; ) {\r\n                    // Reduce amount of reward amount after transfer\r\n                    roundAmounts[_round].erc1155Amount[i][j].amount -= roundRewards[_round].erc1155Rewards[i].amounts[\r\n                        j\r\n                    ];\r\n                    // Record amount for event logging\r\n                    claimedAmounts.erc1155Amount[i][j].tokenAddress = roundRewards[_round]\r\n                        .erc1155Rewards[i]\r\n                        .tokenAddress;\r\n                    claimedAmounts.erc1155Amount[i][j].tokenId = roundRewards[_round].erc1155Rewards[i].tokenIds[j];\r\n                    claimedAmounts.erc1155Amount[i][j].amount = roundRewards[_round].erc1155Rewards[i].amounts[j];\r\n                    IERC1155(roundRewards[_round].erc1155Rewards[i].tokenAddress).safeTransferFrom(\r\n                        address(this),\r\n                        msg.sender,\r\n                        roundRewards[_round].erc1155Rewards[i].tokenIds[j],\r\n                        roundRewards[_round].erc1155Rewards[i].amounts[j],\r\n                        \"\"\r\n                    );\r\n                    unchecked {\r\n                        j++;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // Emit event\r\n        emit ClaimRewards(_round, msg.sender, claimedAmounts);\r\n    }\r\n\r\n    // Internal helper functions\r\n\r\n    function _handleERC20Rewards(RewardData calldata data) internal {\r\n        if (roundRewards[data.round].erc20Rewards.length == 0) {\r\n            // Add rewards to round\r\n            for (uint256 i = 0; i < data.erc20Rewards.length; ) {\r\n                roundRewards[data.round].erc20Rewards.push(data.erc20Rewards[i]);\r\n                roundAmounts[data.round].erc20Amount.push(\r\n                    RewardERC20Amount(data.erc20Rewards[i].tokenAddress, data.erc20Amounts[i])\r\n                );\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        } else {\r\n            // Already existing rewards cannot change reward amount, can only top up reward\r\n            // Ensure that the token address is the same\r\n            for (uint256 i = 0; i < data.erc20Rewards.length; ) {\r\n                require(\r\n                    roundRewards[data.round].erc20Rewards[i].tokenAddress == data.erc20Rewards[i].tokenAddress,\r\n                    \"Token address cannot be changed.\"\r\n                );\r\n                roundAmounts[data.round].erc20Amount[i].amount += data.erc20Amounts[i];\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // Transfer ERC20 tokens to contract\r\n        for (uint256 i = 0; i < data.erc20Rewards.length; ) {\r\n            require(\r\n                IERC20(data.erc20Rewards[i].tokenAddress).transferFrom(msg.sender, address(this), data.erc20Amounts[i]),\r\n                \"Transfer failed\"\r\n            );\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _handleERC721Rewards(RewardData calldata data) internal {\r\n        // No existing rewards\r\n        if (roundRewards[data.round].erc721Rewards.length == 0) {\r\n            // Add rewards to round\r\n            for (uint256 i = 0; i < data.erc721Rewards.length; ) {\r\n                roundRewards[data.round].erc721Rewards.push(data.erc721Rewards[i]);\r\n                roundAmounts[data.round].erc721Amount.push(\r\n                    RewardERC721Amount(data.erc721Rewards[i].tokenAddress, data.erc721Amounts[i])\r\n                );\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        } else {\r\n            // Already existing rewards cannot change reward amount, can only top up reward\r\n            // Ensure that the token address is the same\r\n            for (uint256 i = 0; i < data.erc721Rewards.length; ) {\r\n                require(\r\n                    roundRewards[data.round].erc721Rewards[i].tokenAddress == data.erc721Rewards[i].tokenAddress,\r\n                    \"Token address cannot be changed.\"\r\n                );\r\n                roundRewards[data.round].erc721Rewards.push(data.erc721Rewards[i]);\r\n                roundAmounts[data.round].erc721Amount[i].amount += data.erc721Amounts[i];\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // Transfer ERC721 tokens to contract\r\n        for (uint256 i = 0; i < data.erc721Rewards.length; ) {\r\n            for (uint256 j = 0; j < data.erc721Rewards[i].tokenIds.length; ) {\r\n                IERC721(data.erc721Rewards[i].tokenAddress).transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    data.erc721Rewards[i].tokenIds[j]\r\n                );\r\n                unchecked {\r\n                    j++;\r\n                }\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _handleERC1155Rewards(RewardData calldata data) internal {\r\n        if (roundRewards[data.round].erc1155Rewards.length == 0) {\r\n            // Add rewards to round\r\n            for (uint256 i = 0; i < data.erc1155Rewards.length; ) {\r\n                roundRewards[data.round].erc1155Rewards.push(data.erc1155Rewards[i]);\r\n                for (uint256 j = 0; j < data.erc1155Rewards[i].tokenIds.length; ) {\r\n                    roundAmounts[data.round].erc1155Amount[i].push(\r\n                        RewardERC1155Amount(\r\n                            data.erc1155Rewards[i].tokenAddress,\r\n                            data.erc1155Rewards[i].tokenIds[j],\r\n                            data.erc1155Amounts[i][j]\r\n                        )\r\n                    );\r\n                    unchecked {\r\n                        j++;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        } else {\r\n            // Already existing rewards cannot change reward amount, can only top up reward\r\n            // Ensure that the token address is the same\r\n            for (uint256 i = 0; i < data.erc1155Rewards.length; ) {\r\n                for (uint256 j = 0; j < data.erc1155Rewards[i].tokenIds.length; ) {\r\n                    require(\r\n                        roundRewards[data.round].erc1155Rewards[i].tokenAddress == data.erc1155Rewards[i].tokenAddress,\r\n                        \"Token address cannot be changed.\"\r\n                    );\r\n                    roundAmounts[data.round].erc1155Amount[i][j].amount += data.erc1155Amounts[i][j];\r\n                    unchecked {\r\n                        j++;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // Transfer ERC1155 tokens to contract\r\n        for (uint256 i = 0; i < data.erc1155Rewards.length; ) {\r\n            for (uint256 j = 0; j < data.erc1155Rewards[i].tokenIds.length; ) {\r\n                IERC1155(data.erc1155Rewards[i].tokenAddress).safeTransferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    data.erc1155Rewards[i].tokenIds[j],\r\n                    data.erc1155Amounts[i][j],\r\n                    \"\"\r\n                );\r\n                unchecked {\r\n                    j++;\r\n                }\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        // Add your custom logic for handling ERC1155 token transfers\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        // Add your custom logic for handling ERC1155 token transfers\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n"
    },
    "contracts/Atlantis.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./interface/IAtlantis.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\n\r\n/// @title Atlantis - Expedition contract\r\n/// @dev Send your Argonauts and Planets on an expedition to earn rewards in terms of Stardust tokens and gemstones!\r\ncontract Atlantis is Ownable, ERC721Holder, IAtlantis, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    /// @notice Atlantis address registry, which allows contracts to keep track of the latest deployed addresses at all times.\r\n    AtlantisAddressRegistry public addressRegistry;\r\n    /// @notice Base rate of stardust per expedition\r\n    uint256 public baseStardustRate = 115 ether;\r\n    /// @notice Level parameter\r\n    uint256 public levelParameter = 1;\r\n    /// @notice Rarity parameter\r\n    uint256 public rarityParameter = 20;\r\n    /// @notice Mapping of level to Gemstone rate\r\n    mapping(uint8 => uint256) public gemstoneRate;\r\n    /// @notice Mapping of NFTs staked to gemstone multiplier\r\n    uint256[4] public nftGemstoneMultiplier;\r\n    /// @notice Array of orbit to rarity multiplier\r\n    uint256[4] public rarityMultiplier;\r\n    /// @notice Mapping of address to boolean whitelisted status\r\n    mapping(address => bool) public whitelistedCollections;\r\n    /// @notice Mapping of user address to array of Expedition struct\r\n    mapping(uint256 => Expedition) public expeditions;\r\n    /// @notice Variable to track current Expedition id\r\n    uint256 public currentExpeditionId = 0;\r\n    /// @notice Variable to track expedition duration\r\n    uint256 public expeditionDuration = 7 days;\r\n    /// @notice Denominator used for calculation\r\n    uint256 public constant DENOMINATOR = 100;\r\n    /// @notice Tax fee for going on expeditions\r\n    uint256 public taxFee = 0.25 ether;\r\n    /// @notice EOA for treasury\r\n    address public treasury;\r\n\r\n    /**\r\n     * @notice Constructor for Atlantis Expedition\r\n     * @param _registry Address registry contract\r\n     * @param _treasury Address of EOA treasury\r\n     */\r\n    constructor(AtlantisAddressRegistry _registry, address _treasury) {\r\n        // Set address registry\r\n        addressRegistry = _registry;\r\n        // Set treasury\r\n        // Check that treasury is not address(0)\r\n        require(_treasury != address(0), \"Invalid treasury address\");\r\n        treasury = _treasury;\r\n        // Get argonaut address from registry\r\n        address argonautAddress = addressRegistry.getArgonauts();\r\n        // Initialise whitelisted collection with Argonauts\r\n        whitelistedCollections[argonautAddress] = true;\r\n    }\r\n\r\n    // --------------------- PUBLIC FUNCTINOS ---------------------\r\n\r\n    /**\r\n     * @notice Starts an Atlantis Expedition\r\n     * @dev NFTs sent on expedition must be whitelisted\r\n     * @param _planetId PlanetId of planets to send NFTs on expedition\r\n     * @param _collectionAddresses Collection Addresses of nfts to send on expedition\r\n     * @param _tokenIds TokenIds of nfts to send on expedition\r\n     */\r\n    function startExpedition(\r\n        uint256 _planetId,\r\n        address[] memory _collectionAddresses,\r\n        uint256[] memory _tokenIds\r\n    ) external payable {\r\n        require(msg.value == taxFee, \"Invalid tax fee\");\r\n        IAtlantisPlanets atlantisPlanets = IAtlantisPlanets(addressRegistry.getAtlantisPlanets());\r\n        // Tax fee ether to treasury\r\n        (bool success, ) = payable(treasury).call{ value: taxFee }(\"\");\r\n        require(success, \"Transfer failed\");\r\n        // Get planetLevel from planetId\r\n        uint8 planetLevel = atlantisPlanets.getPlanetDetails(_planetId).level;\r\n        // REVERT: If _collectionAddresses.length != _tokenIds.length\r\n        if (_collectionAddresses.length != _tokenIds.length) {\r\n            revert InvalidExpeditionInput();\r\n        }\r\n        // REVERT: If staked NFTs is more than limit\r\n        if (_collectionAddresses.length > calculateNFTsStakable(planetLevel)) {\r\n            revert InvalidExpeditionInput();\r\n        }\r\n        // Record the expedition\r\n        expeditions[currentExpeditionId] = Expedition({\r\n            collectionAddresses: _collectionAddresses,\r\n            tokenIds: _tokenIds,\r\n            id: currentExpeditionId,\r\n            planetId: _planetId,\r\n            startTime: block.timestamp,\r\n            endTime: block.timestamp + expeditionDuration,\r\n            owner: msg.sender,\r\n            hasEnded: false\r\n        });\r\n\r\n        // Increment currentExpeditionId\r\n        currentExpeditionId++;\r\n        // Transfer Planet NFT to this contract\r\n        atlantisPlanets.safeTransferFrom(msg.sender, address(this), _planetId);\r\n        // Transfer Staked NFTs to this contract\r\n        for (uint256 i; i < _collectionAddresses.length; i++) {\r\n            // Check if collection address is whitelisted\r\n            if (!whitelistedCollections[_collectionAddresses[i]]) {\r\n                revert NFTCollectionNotWhitelisted();\r\n            }\r\n            IERC721(_collectionAddresses[i]).safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\r\n        }\r\n        // Emit event\r\n        emit ExpeditionStarted(\r\n            msg.sender,\r\n            currentExpeditionId - 1,\r\n            _planetId,\r\n            _tokenIds,\r\n            _collectionAddresses,\r\n            block.timestamp,\r\n            block.timestamp + expeditionDuration\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Starts multiple expeditions without boosting NFTs\r\n     * @param _planetIds PlanetId of planets to send NFTs on expedition\r\n     */\r\n    function startMultipleExpeditions(uint256[] memory _planetIds) external payable {\r\n        // Check that _planetIds is not empty\r\n        require(_planetIds.length > 0, \"Invalid planetIds\");\r\n        require(msg.value == taxFee * _planetIds.length, \"Invalid tax fee\");\r\n        IAtlantisPlanets atlantisPlanets = IAtlantisPlanets(addressRegistry.getAtlantisPlanets());\r\n        // Tax fee ether to treasury\r\n        (bool success, ) = payable(treasury).call{ value: taxFee * _planetIds.length }(\"\");\r\n        require(success, \"Transfer failed\");\r\n        // Create empty arrays for collectionAddresses and tokenIds outside the loop\r\n        address[] memory emptyCollectionAddresses = new address[](0);\r\n        uint256[] memory emptyTokenIds = new uint256[](0);\r\n\r\n        for (uint256 i; i < _planetIds.length; ) {\r\n            // Record the expedition\r\n            expeditions[currentExpeditionId] = Expedition({\r\n                collectionAddresses: emptyCollectionAddresses,\r\n                tokenIds: emptyTokenIds,\r\n                id: currentExpeditionId,\r\n                planetId: _planetIds[i],\r\n                startTime: block.timestamp,\r\n                endTime: block.timestamp + expeditionDuration,\r\n                owner: msg.sender,\r\n                hasEnded: false\r\n            });\r\n\r\n            // Increment currentExpeditionId\r\n            currentExpeditionId++;\r\n            // Transfer Planet NFT to this contract\r\n            atlantisPlanets.safeTransferFrom(msg.sender, address(this), _planetIds[i]);\r\n            // Emit event\r\n            emit ExpeditionStarted(\r\n                msg.sender,\r\n                currentExpeditionId - 1,\r\n                _planetIds[i],\r\n                emptyTokenIds,\r\n                emptyCollectionAddresses,\r\n                block.timestamp,\r\n                block.timestamp + expeditionDuration\r\n            );\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Stops an Atlantis Expedition\r\n     * @param _expeditionId ExpeditionId of expedition to stop\r\n     * @dev - Must be called by the owner of the expedition\r\n     *      - Must be called after the expedition has ended (block.timestamp > block.timestamp)\r\n     *      - Must be called before the expedition has been claimed (hasEnded == false)\r\n     */\r\n    function _endExpedition(uint256 _expeditionId) internal {\r\n        IAtlantisPlanets atlantisPlanets = IAtlantisPlanets(addressRegistry.getAtlantisPlanets());\r\n\r\n        Expedition storage currentExpedition = expeditions[_expeditionId];\r\n\r\n        // REVERT: If expedition has ended\r\n        if (currentExpedition.hasEnded) {\r\n            revert ExpeditionAlreadyEnded();\r\n        }\r\n        // REVERT: If current time is less than end time\r\n        if (currentExpedition.endTime > block.timestamp) {\r\n            revert ExpeditionInProgress();\r\n        }\r\n        // REVERT: If caller is not the owner of the expedition\r\n        if (currentExpedition.owner != msg.sender) revert NotOwnerOfExpedition();\r\n\r\n        // Transfer all staked NFTs back to user\r\n        for (uint256 i; i < currentExpedition.collectionAddresses.length; i++) {\r\n            IERC721(currentExpedition.collectionAddresses[i]).safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                currentExpedition.tokenIds[i]\r\n            );\r\n        }\r\n        // Transfer Planet NFT back to user\r\n        atlantisPlanets.safeTransferFrom(address(this), msg.sender, currentExpedition.planetId);\r\n        _claimReward(_expeditionId);\r\n        currentExpedition.hasEnded = true;\r\n\r\n        emit ExpeditionEnded(msg.sender, _expeditionId, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Ends multiple Atlantis Expeditions\r\n     * @param _expeditionIds ExpeditionIds of expeditions to stop\r\n     * @dev - Must be called by the owner of the expedition\r\n     *      - Must be called after the expedition has ended (block.timestamp > block.timestamp)\r\n     *      - Must be called before the expedition has been claimed (hasEnded == false)\r\n     */\r\n    function endExpeditions(uint256[] calldata _expeditionIds) external nonReentrant {\r\n        // Loop through all expedition ids\r\n        for (uint256 i; i < _expeditionIds.length; i++) {\r\n            _endExpedition(_expeditionIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claims rewards for multiple expeditions\r\n     * @param _expeditionIds ExpeditionIds of expeditions to claim rewards for\r\n     */\r\n    function claimRewards(uint256[] calldata _expeditionIds) external payable nonReentrant {\r\n        require(msg.value == taxFee * _expeditionIds.length, \"Invalid tax fee\");\r\n        // Tax fee ether to treasury\r\n        (bool success, ) = payable(treasury).call{ value: taxFee * _expeditionIds.length }(\"\");\r\n        require(success, \"Transfer failed\");\r\n        // Loop through all expedition ids\r\n        for (uint256 i; i < _expeditionIds.length; i++) {\r\n            // Get expedition\r\n            _claimReward(_expeditionIds[i]);\r\n            Expedition memory currentExpedition = expeditions[_expeditionIds[i]];\r\n            // Emit event\r\n            emit ExpeditionStarted(\r\n                msg.sender,\r\n                _expeditionIds[i],\r\n                currentExpedition.planetId,\r\n                currentExpedition.tokenIds,\r\n                currentExpedition.collectionAddresses,\r\n                block.timestamp,\r\n                block.timestamp + expeditionDuration\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claims rewards for an expedition and continues the expedition\r\n     * @param _expeditionId ExpeditionId of expedition to claim rewards for\r\n     * @dev - Must only be called by the owner of the expedition\r\n     *      - Must only be called after the expedition has ended (block.timestamp > block.timestamp)\r\n     *      - Stardust is minted to the caller\r\n     *      - Atlantisgemstones are minted to the caller\r\n     *      - EndDate is Updated\r\n     */\r\n    function _claimReward(uint256 _expeditionId) internal {\r\n        // check if claimant is owner of expeditionId\r\n        if (expeditions[_expeditionId].owner != msg.sender) {\r\n            revert NotOwnerOfExpedition();\r\n        }\r\n        IERC20 stardust = IERC20(addressRegistry.getStardust());\r\n        IAtlantisGemstones atlantisGemstones = IAtlantisGemstones(addressRegistry.getGemstones());\r\n        // Get expedition\r\n        Expedition storage expedition = expeditions[_expeditionId];\r\n        // Require that expedition hasended = false\r\n        if (expedition.hasEnded) {\r\n            revert ExpeditionAlreadyEnded();\r\n        }\r\n        // Check if expedition has ended\r\n        if (expedition.endTime > block.timestamp) {\r\n            revert ExpeditionInProgress();\r\n        }\r\n\r\n        // Update Expedition startTime and endTime\r\n        expeditions[_expeditionId].startTime = block.timestamp;\r\n        expeditions[_expeditionId].endTime = block.timestamp + expeditionDuration;\r\n\r\n        AtlantisLib.Element planetElement;\r\n        uint256 _gemstoneGenerated;\r\n        uint256 _stardustEarned;\r\n        // Calculate rewards\r\n        (_gemstoneGenerated, planetElement, _stardustEarned) = calculateRewards(_expeditionId);\r\n        // Distribute stardust rewards\r\n        stardust.safeTransfer(msg.sender, _stardustEarned);\r\n        // Distribute gemstone rewards\r\n        atlantisGemstones.mint(msg.sender, uint8(planetElement) + 1, _gemstoneGenerated);\r\n\r\n        // Emit event\r\n        emit RewardsClaimed(\r\n            msg.sender,\r\n            _expeditionId,\r\n            uint8(planetElement) + 1,\r\n            _gemstoneGenerated,\r\n            _stardustEarned,\r\n            expedition.startTime,\r\n            expedition.endTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get Expedition Info\r\n     * @param _expeditionId Expedition Id\r\n     * @return Expedition of given expeditionId\r\n     */\r\n    function getExpeditionInfo(uint256 _expeditionId) external view returns (Expedition memory) {\r\n        return expeditions[_expeditionId];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of stardust earned\r\n     * @param _planetLevel Level of the planet\r\n     * @param _planetOrbit Orbit tier of the planet\r\n     * From Spreadsheet:\r\n     * Stardust earned per expedition =\r\n     * (((planet_level -1) ^ 2) * level_parameter + 1) * ((planet_rarity -1) * rarity_parameter + 1) * stardust_base_rate\r\n     * Planet orbit will always start from 1. Hence, planetOrbit which is planet_rarity, will need to + 1 to match the equation.\r\n     */\r\n    function calculateStardustPerExpedition(uint8 _planetLevel, uint8 _planetOrbit) public view returns (uint256) {\r\n        // If planet level is 0, return baseStardustRate\r\n        if (_planetLevel == 0) {\r\n            return baseStardustRate;\r\n        }\r\n        // Convert _planetLevel and _planetOrbit to uint256\r\n        uint256 __planetLevel = uint256(_planetLevel);\r\n        uint256 __planetOrbit = uint256(_planetOrbit);\r\n        return\r\n            (((((__planetLevel - 1) * DENOMINATOR) ** 2 * levelParameter + DENOMINATOR ** 3) / DENOMINATOR ** 2) *\r\n                (((__planetOrbit) * DENOMINATOR) * rarityParameter + DENOMINATOR ** 2) *\r\n                baseStardustRate) / DENOMINATOR ** 3;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of Gemstones earned\r\n     * @param _planetLevel ExpeditionId of the expedition\r\n     * @param _planetOrbit ExpeditionId of the expedition\r\n     * @param _amountArgonauts ExpeditionId of the expedition\r\n     * From Spreadsheet:\r\n     * Gemstone generated / expedition =\r\n     * roundup(base_Gemstone_rate * planet_rarity * argonauts_Gemstone_multiplier)\r\n     */\r\n    function gemstoneGenerated(\r\n        uint8 _planetLevel,\r\n        uint8 _planetOrbit,\r\n        uint8 _amountArgonauts\r\n    ) public view returns (uint256) {\r\n        uint256 _temp = gemstoneRate[_planetLevel] *\r\n            (rarityMultiplier[_planetOrbit] * (DENOMINATOR / 10)) *\r\n            nftGemstoneMultiplier[_amountArgonauts] *\r\n            (DENOMINATOR / 10);\r\n\r\n        return _roundUp(_temp);\r\n    }\r\n\r\n    function _roundUp(uint256 _number) internal pure returns (uint256) {\r\n        if ((_number % (DENOMINATOR ** 2)) != 0) {\r\n            return _number / (DENOMINATOR ** 2) + 1;\r\n        } else {\r\n            return _number / (DENOMINATOR ** 2);\r\n        }\r\n    }\r\n\r\n    function calculateRewards(uint256 _expeditionId) public view returns (uint256, AtlantisLib.Element, uint256) {\r\n        IAtlantisPlanets atlantisPlanets = IAtlantisPlanets(addressRegistry.getAtlantisPlanets());\r\n\r\n        // Get expedition\r\n        Expedition memory expedition = expeditions[_expeditionId];\r\n        uint256 planetId = expedition.planetId;\r\n\r\n        // Get Planet level and Orbit\r\n        AtlantisLib.Planet memory planet = atlantisPlanets.getPlanetDetails(planetId);\r\n\r\n        // gemstone multiplier is in terms of 100s, 1.2 = 120\r\n        uint256 _gemstoneGenerated = gemstoneGenerated(\r\n            planet.level,\r\n            uint8(planet.orbit),\r\n            uint8(expedition.tokenIds.length)\r\n        );\r\n\r\n        uint256 _stardustEarned = calculateStardustPerExpedition(planet.level, uint8(planet.orbit));\r\n        // Return rewards\r\n        return (_gemstoneGenerated, planet.element, _stardustEarned);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns number of NFTs that can be staked on the planet\r\n     * @param _planetLevel Level of the planet\r\n     */\r\n    function calculateNFTsStakable(uint8 _planetLevel) public pure returns (uint8 nftsStakable) {\r\n        if (_planetLevel >= 0 && _planetLevel < 20) {\r\n            nftsStakable = 0;\r\n        } else if (_planetLevel >= 20 && _planetLevel < 30) {\r\n            nftsStakable = 1;\r\n        } else if (_planetLevel >= 30 && _planetLevel < 40) {\r\n            nftsStakable = 2;\r\n        } else if (_planetLevel >= 40) {\r\n            nftsStakable = 3;\r\n        }\r\n    }\r\n\r\n    // -------------------- ADMIN FUNCTIONS ----------------------\r\n    /**\r\n     * @notice Set the duration of an expedition\r\n     * @param _duration The duration of an expedition in seconds\r\n     */\r\n    function setExpeditionDuration(uint256 _duration) external onlyOwner {\r\n        expeditionDuration = _duration;\r\n        emit ExpeditionDurationUpdated(_duration);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the whitelisted status of a collection\r\n     * @param _collectionAddresses The address of the collection\r\n     * @param _status The whitelisted status of the collection\r\n     * @dev Only whitelisted collections can be staked\r\n     */\r\n    function setWhitelistedCollections(address[] memory _collectionAddresses, bool _status) external onlyOwner {\r\n        for (uint256 i; i < _collectionAddresses.length; i++) {\r\n            whitelistedCollections[_collectionAddresses[i]] = _status;\r\n        }\r\n        emit WhitelistedCollectionsUpdated(_collectionAddresses, _status);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the gemstone rate for a level\r\n     * @param _levels The level of the gemstone\r\n     * @param _rates The rate of the gemstone\r\n     */\r\n    function setGemstoneRate(uint8[] memory _levels, uint256[] memory _rates) external onlyOwner {\r\n        if (_levels.length != _rates.length) revert InvalidSetGemstoneRateInput();\r\n        for (uint256 i; i < _levels.length; i++) {\r\n            gemstoneRate[_levels[i]] = _rates[i];\r\n        }\r\n        emit GemstoneRateUpdated(_levels, _rates);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the gemstone multiplier for a NFT\r\n     * @param _multipliers The multiplier of the rewards\r\n     */\r\n    function setNftGemstoneMultiplier(uint256[] memory _multipliers) external onlyOwner {\r\n        if (_multipliers.length != 4) revert InvalidSetNFTGemstoneMultiplierInput();\r\n\r\n        for (uint256 i; i < _multipliers.length; i++) {\r\n            nftGemstoneMultiplier[i] = _multipliers[i];\r\n        }\r\n        emit NFTGemstoneMultiplierUpdated(_multipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Rarity Multiplier parameter\r\n     */\r\n    function setRarityMultiplier(uint256[] memory _multipliers) external onlyOwner {\r\n        if (_multipliers.length != 4) revert InvalidSetRarityMultiplierInput();\r\n\r\n        for (uint256 i; i < _multipliers.length; i++) {\r\n            rarityMultiplier[i] = _multipliers[i];\r\n        }\r\n        emit RarityMultiplierUpdated(_multipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Base Stardust Rate parameter\r\n     * @param _baseStardustRate The base stardust rewards rate\r\n     */\r\n    function setBaseStardustRate(uint256 _baseStardustRate) external onlyOwner {\r\n        baseStardustRate = _baseStardustRate;\r\n        emit BaseStardustRateUpdated(_baseStardustRate);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the level parameter\r\n     * @param _levelParameter The level parameter for rewards\r\n     */\r\n    function setLevelParameter(uint256 _levelParameter) external onlyOwner {\r\n        levelParameter = _levelParameter;\r\n        emit LevelParameterUpdated(_levelParameter);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the rarity parameter\r\n     * @param _rarityParameter The rarity parameter for rewards\r\n     */\r\n    function setRarityParameter(uint256 _rarityParameter) external onlyOwner {\r\n        rarityParameter = _rarityParameter;\r\n        emit RarityParameterUpdated(_rarityParameter);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Address Registry\r\n     * @param _addressRegistry The address of the Address Registry\r\n     */\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) external onlyOwner {\r\n        addressRegistry = _addressRegistry;\r\n        emit AddressRegistryUpdated(address(_addressRegistry));\r\n    }\r\n\r\n    /**\r\n     * @notice Set the expedition tax fee\r\n     * @param _taxFee The amount tax fee\r\n     */\r\n    function setTaxFee(uint256 _taxFee) external onlyOwner {\r\n        taxFee = _taxFee;\r\n        emit TaxFeeUpdated(_taxFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to withdraw any ERC20 tokens from the contract\r\n     * @param _tokenAddress The token address to withdraw\r\n     * @param _amount Amount to withdraw\r\n     */\r\n    function withdrawERC20(address _tokenAddress, uint256 _amount) external onlyOwner {\r\n        IERC20(_tokenAddress).safeTransfer(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the treasury address\r\n     * @param _treasury Address of treasury\r\n     */\r\n    function setTreasury(address _treasury) external onlyOwner {\r\n        require(_treasury != address(0), \"Invalid treasury address\");\r\n        treasury = _treasury;\r\n        emit TreasuryUpdated(_treasury);\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisAddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./common/AddressRegistry.sol\";\r\n\r\ncontract AtlantisAddressRegistry is Ownable, AddressRegistry {\r\n    bytes32 private constant ARGONAUTS = \"ARGONAUTS\";\r\n    bytes32 private constant ARGO = \"ARGO\";\r\n    bytes32 private constant XARGO = \"XARGO\";\r\n    bytes32 private constant GOLD = \"GOLD\";\r\n    bytes32 private constant STARDUST = \"STARDUST\";\r\n    bytes32 private constant ATLANTIS = \"ATLANTIS\";\r\n    bytes32 private constant ATLANTIS_PLANETS = \"ATLANTIS_PLANETS\";\r\n    bytes32 private constant STAKING_WITH_LOCK = \"STAKING_WITH_LOCK\";\r\n    bytes32 private constant ATLANTIS_GEMSTONES = \"GEMSTONES\";\r\n    bytes32 private constant ATLANTIS_EQUIPMENTS = \"EQUIPMENTS\";\r\n    bytes32 private constant ATLANTIS_SPACESHIPS = \"SPACESHIPS\";\r\n    bytes32 private constant ATLANTIS_RACING = \"RACING\";\r\n    bytes32 private constant ATLANTIS_MARKETPLACE = \"MARKETPLACE\";\r\n    bytes32 private constant ATLANTIS_AUCTION = \"AUCTION\";\r\n    bytes32 private constant STARDUST_PLEDGING = \"PLEDGING\";\r\n    bytes32 private constant GOLD_STAKING = \"GOLD_STAKING\";\r\n    mapping(address => bool) private _addresses;\r\n\r\n    function setArgonauts(address contractAddress) external onlyOwner {\r\n        _setAddress(ARGONAUTS, contractAddress);\r\n    }\r\n\r\n    function setArgo(address contractAddress) external onlyOwner {\r\n        _setAddress(ARGO, contractAddress);\r\n    }\r\n\r\n    function setXargo(address contractAddress) external onlyOwner {\r\n        _setAddress(XARGO, contractAddress);\r\n    }\r\n\r\n    function setGold(address contractAddress) external onlyOwner {\r\n        _setAddress(GOLD, contractAddress);\r\n    }\r\n\r\n    function setStardust(address contractAddress) external onlyOwner {\r\n        _setAddress(STARDUST, contractAddress);\r\n    }\r\n\r\n    function setAtlantis(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS, contractAddress);\r\n    }\r\n\r\n    function setAtlantisPlanets(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_PLANETS, contractAddress);\r\n    }\r\n\r\n    function setStakingWithLock(address contractAddress) external onlyOwner {\r\n        _setAddress(STAKING_WITH_LOCK, contractAddress);\r\n    }\r\n\r\n    function setGemstones(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_GEMSTONES, contractAddress);\r\n    }\r\n\r\n    function setEquipments(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_EQUIPMENTS, contractAddress);\r\n    }\r\n\r\n    function setSpaceships(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_SPACESHIPS, contractAddress);\r\n    }\r\n\r\n    function setRacing(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_RACING, contractAddress);\r\n    }\r\n\r\n    function setMarketplace(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_MARKETPLACE, contractAddress);\r\n    }\r\n\r\n    function setAuction(address contractAddress) external onlyOwner {\r\n        _setAddress(ATLANTIS_AUCTION, contractAddress);\r\n    }\r\n\r\n    function setPledging(address contractAddress) external onlyOwner {\r\n        _setAddress(STARDUST_PLEDGING, contractAddress);\r\n    }\r\n\r\n    function setGoldStaking(address contractAddress) external onlyOwner {\r\n        _setAddress(GOLD_STAKING, contractAddress);\r\n    }\r\n\r\n    function getArgonauts() external view returns (address) {\r\n        return getAddress(ARGONAUTS);\r\n    }\r\n\r\n    function getArgo() external view returns (address) {\r\n        return getAddress(ARGO);\r\n    }\r\n\r\n    function getXargo() external view returns (address) {\r\n        return getAddress(XARGO);\r\n    }\r\n\r\n    function getGold() external view returns (address) {\r\n        return getAddress(GOLD);\r\n    }\r\n\r\n    function getStardust() external view returns (address) {\r\n        return getAddress(STARDUST);\r\n    }\r\n\r\n    function getAtlantis() public view returns (address) {\r\n        return getAddress(ATLANTIS);\r\n    }\r\n\r\n    function getAtlantisPlanets() public view returns (address) {\r\n        return getAddress(ATLANTIS_PLANETS);\r\n    }\r\n\r\n    function getStakingWithLock() external view returns (address) {\r\n        return getAddress(STAKING_WITH_LOCK);\r\n    }\r\n\r\n    function getGemstones() public view returns (address) {\r\n        return getAddress(ATLANTIS_GEMSTONES);\r\n    }\r\n\r\n    function getEquipments() public view returns (address) {\r\n        return getAddress(ATLANTIS_EQUIPMENTS);\r\n    }\r\n\r\n    function getSpaceships() external view returns (address) {\r\n        return getAddress(ATLANTIS_SPACESHIPS);\r\n    }\r\n\r\n    function getRacing() external view returns (address) {\r\n        return getAddress(ATLANTIS_RACING);\r\n    }\r\n\r\n    function getMarketplace() external view returns (address) {\r\n        return getAddress(ATLANTIS_MARKETPLACE);\r\n    }\r\n\r\n    function getAuction() external view returns (address) {\r\n        return getAddress(ATLANTIS_AUCTION);\r\n    }\r\n\r\n    function getPledging() external view returns (address) {\r\n        return getAddress(STARDUST_PLEDGING);\r\n    }\r\n\r\n    function getGoldStaking() external view returns (address) {\r\n        return getAddress(GOLD_STAKING);\r\n    }\r\n\r\n    function isControllerContract(address _contractAddress) external view returns (bool) {\r\n        if (\r\n            _contractAddress == getAtlantis() ||\r\n            _contractAddress == getGemstones() ||\r\n            _contractAddress == getAtlantisPlanets() ||\r\n            _contractAddress == getEquipments()\r\n        ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interface/IAtlantisPlanets.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\n\r\nerror AuctionSettled();\r\nerror AuctionNotInitialized();\r\nerror AuctionNotLive();\r\nerror ReservePriceNotMet();\r\nerror IncrementalPriceNotMet();\r\nerror BidsNotSorted();\r\nerror NonExistentBid();\r\nerror AuctionStillLive();\r\nerror WithdrawFailed();\r\nerror BidIncrementTooLow();\r\nerror NotEOA();\r\n\r\ncontract AtlantisAuction is Ownable, ReentrancyGuard {\r\n    struct Bid {\r\n        address bidder;\r\n        uint192 amount;\r\n        uint64 bidTime;\r\n    }\r\n\r\n    struct BidIndex {\r\n        uint8 index;\r\n        bool isSet;\r\n    }\r\n\r\n    event NewBid(address bidder, uint256 value);\r\n    event BidIncreased(address bidder, uint256 oldValue, uint256 increment);\r\n    event AuctionExtended();\r\n\r\n    // The max number of top bids the auction will accept\r\n    uint256 public constant MAX_NUM_BIDS = 8;\r\n\r\n    // The token contract to mint from\r\n    AtlantisAddressRegistry public addressRegistry;\r\n\r\n    // The minimum amount of time left in an auction after a new bid is created\r\n    uint256 public timeBuffer;\r\n\r\n    // The minimum price accepted in an auction\r\n    uint256 public reservePrice;\r\n\r\n    // The minimum percentage difference between the last bid amount and the current bid\r\n    uint8 public minBidIncrementPercentage;\r\n\r\n    // The minimum amount a user needs to submit for a stacked bid\r\n    uint256 public minStackedBidIncrement;\r\n\r\n    // The start time of the auction\r\n    uint256 public startTime;\r\n\r\n    // The end time of the auction\r\n    uint256 public endTime;\r\n\r\n    // Whether or not the auction has settled.\r\n    bool public auctionSettled;\r\n\r\n    // The current highest bids made in the auction\r\n    Bid[MAX_NUM_BIDS] public activeBids;\r\n\r\n    // The mapping between an address and its active bid. The isSet flag differentiates the default\r\n    // uint value 0 from an actual 0 value.\r\n    mapping(address => BidIndex) public bidIndexes;\r\n\r\n    constructor(\r\n        AtlantisAddressRegistry _addressRegistry,\r\n        uint256 _timeBuffer,\r\n        uint256 _reservePrice,\r\n        uint8 _minBidIncrementPercentage,\r\n        uint256 _minStackedBidIncrement,\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    ) {\r\n        addressRegistry = _addressRegistry;\r\n        timeBuffer = _timeBuffer;\r\n        reservePrice = _reservePrice;\r\n        minBidIncrementPercentage = _minBidIncrementPercentage;\r\n        minStackedBidIncrement = _minStackedBidIncrement;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    modifier onlyEOA() {\r\n        if (tx.origin != msg.sender) {\r\n            revert NotEOA();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Handle users' bids\r\n     * @dev Bids must be made while the auction is live. Bids must meet a minimum reserve price.\r\n     *\r\n     * The first 8 bids made will be accepted as valid. Subsequent bids must be a percentage\r\n     * higher than the lowest of the 8 active bids. When a low bid is replaced, the ETH will\r\n     * be refunded back to the original bidder.\r\n     *\r\n     * If a valid bid comes in within the last `timeBuffer` seconds, the auction will be extended\r\n     * for another `timeBuffer` seconds. This will continue until no new active bids come in.\r\n     *\r\n     * If a wallet makes a bid while it still has an active bid, the second bid will\r\n     * stack on top of the first bid. If the second bid doesn't meet the `minStackedBidIncrement`\r\n     * threshold, an error will be thrown. A wallet will only have one active bid at at time.\r\n     */\r\n    function bid() public payable nonReentrant onlyEOA {\r\n        if (auctionSettled) {\r\n            revert AuctionSettled();\r\n        }\r\n        if (startTime == 0 || endTime == 0) {\r\n            revert AuctionNotInitialized();\r\n        }\r\n        require(block.timestamp > startTime || block.timestamp < endTime, \"Auction has ended\");\r\n\r\n        BidIndex memory existingIndex = bidIndexes[msg.sender];\r\n        if (existingIndex.isSet) {\r\n            // Case when the user already has an active bid\r\n            if (msg.value < minStackedBidIncrement || msg.value == 0) {\r\n                revert BidIncrementTooLow();\r\n            }\r\n\r\n            uint192 oldValue = activeBids[existingIndex.index].amount;\r\n            unchecked {\r\n                activeBids[existingIndex.index].amount = oldValue + uint192(msg.value);\r\n            }\r\n            activeBids[existingIndex.index].bidTime = uint64(block.timestamp);\r\n\r\n            emit BidIncreased(msg.sender, oldValue, msg.value);\r\n        } else {\r\n            if (msg.value < reservePrice || msg.value == 0) {\r\n                revert ReservePriceNotMet();\r\n            }\r\n\r\n            uint8 lowestBidIndex = getBidIndexToUpdate();\r\n            uint256 lowestBidAmount = activeBids[lowestBidIndex].amount;\r\n            address lowestBidder = activeBids[lowestBidIndex].bidder;\r\n\r\n            unchecked {\r\n                if (msg.value < lowestBidAmount + (lowestBidAmount * minBidIncrementPercentage) / 100) {\r\n                    revert IncrementalPriceNotMet();\r\n                }\r\n            }\r\n\r\n            // Refund lowest bidder and remove bidIndexes entry\r\n            if (lowestBidder != address(0)) {\r\n                delete bidIndexes[lowestBidder];\r\n                _transferETH(lowestBidder, lowestBidAmount);\r\n            }\r\n\r\n            activeBids[lowestBidIndex] = Bid({\r\n                bidder: msg.sender,\r\n                amount: uint192(msg.value),\r\n                bidTime: uint64(block.timestamp)\r\n            });\r\n\r\n            bidIndexes[msg.sender] = BidIndex({ index: lowestBidIndex, isSet: true });\r\n\r\n            emit NewBid(msg.sender, msg.value);\r\n        }\r\n\r\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\r\n        if (endTime - block.timestamp < timeBuffer) {\r\n            unchecked {\r\n                endTime = block.timestamp + timeBuffer;\r\n            }\r\n            emit AuctionExtended();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the index of the entry in activeBids to update\r\n     * @dev The index to return will be decided by the following rules:\r\n     * If there are less than MAX_NUM_BIDS bids, the index of the first empty slot is returned.\r\n     * If there are MAX_NUM_BIDS or more bids, the index of the lowest value bid is returned. If\r\n     * there is a tie, the most recent bid with the low amount will be returned. If there is a tie\r\n     * among bidTimes, the highest index is chosen.\r\n     */\r\n    function getBidIndexToUpdate() public view returns (uint8) {\r\n        uint256 minAmount = activeBids[0].amount;\r\n        // If the first value is 0 then we can assume that no bids have been submitted\r\n        if (minAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint8 minIndex = 0;\r\n        uint64 minBidTime = activeBids[0].bidTime;\r\n\r\n        for (uint8 i = 1; i < MAX_NUM_BIDS; ) {\r\n            uint256 bidAmount = activeBids[i].amount;\r\n            uint64 bidTime = activeBids[i].bidTime;\r\n\r\n            // A zero bidAmount means the slot is empty because we enforce non-zero bid amounts\r\n            if (bidAmount == 0) {\r\n                return i;\r\n            } else if (bidAmount < minAmount || (bidAmount == minAmount && bidTime >= minBidTime)) {\r\n                minAmount = bidAmount;\r\n                minIndex = i;\r\n                minBidTime = bidTime;\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Get all active bids.\r\n     * @dev Useful for ethers client to get the entire array at once.\r\n     */\r\n    function getAllActiveBids() external view returns (Bid[MAX_NUM_BIDS] memory) {\r\n        return activeBids;\r\n    }\r\n\r\n    /**\r\n     * @notice Settles the auction and mints a skateboard ticket NFT to each winner.\r\n     * @dev Bids will be sorted in descending order off-chain due to constraints with\r\n     * sorting structs on-chain via a field on the struct, however we will validate the\r\n     * input on-chain before minting the NFTs. The input bids must be in descending order\r\n     * by amount and all input bids must correspond to a bid in the `activeBids` mapping.\r\n     * @dev Duplicate bids can be passed in to circumvent the validation logic. We are ok\r\n     * with this loophole since this function is ownerOnly.\r\n     * @dev Settlement is only possible once the auction is over.\r\n     */\r\n    function settleAuction(Bid[MAX_NUM_BIDS] calldata sortedBids) external onlyOwner nonReentrant {\r\n        IAtlantisPlanets planets = IAtlantisPlanets(addressRegistry.getAtlantisPlanets());\r\n\r\n        if (block.timestamp <= endTime) {\r\n            revert AuctionStillLive();\r\n        }\r\n        if (auctionSettled) {\r\n            revert AuctionSettled();\r\n        }\r\n\r\n        // Validate the input bids\r\n        for (uint256 i = 0; i < MAX_NUM_BIDS; ) {\r\n            Bid memory inputBid = sortedBids[i];\r\n            BidIndex memory bidIndex = bidIndexes[inputBid.bidder];\r\n            if (\r\n                !bidIndex.isSet ||\r\n                activeBids[bidIndex.index].bidder != inputBid.bidder ||\r\n                activeBids[bidIndex.index].amount != inputBid.amount ||\r\n                activeBids[bidIndex.index].bidTime != inputBid.bidTime\r\n            ) {\r\n                revert NonExistentBid();\r\n            }\r\n\r\n            // The zero-th index has nothing to compare against\r\n            if (i != 0) {\r\n                Bid memory prevBid = sortedBids[i - 1];\r\n                if (inputBid.amount > prevBid.amount) {\r\n                    revert BidsNotSorted();\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        // Get addresses from bids\r\n        address[MAX_NUM_BIDS] memory winners;\r\n        for (uint256 i = 0; i < MAX_NUM_BIDS; ) {\r\n            winners[i] = sortedBids[i].bidder;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Mint tickets to auction winners\r\n        // planets.epicMint(winners);\r\n\r\n        auctionSettled = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ETH to a specified address.\r\n     * @dev This function can only be called internally.\r\n     */\r\n    function _transferETH(address to, uint256 value) internal returns (bool) {\r\n        (bool success, ) = to.call{ value: value, gas: 30000 }(new bytes(0));\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the start and end time of the auction.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setAuctionTimes(uint256 _startTime, uint256 _endTime) external onlyOwner {\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction time buffer.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {\r\n        timeBuffer = _timeBuffer;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction reserve price.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setReservePrice(uint256 _reservePrice) external onlyOwner {\r\n        reservePrice = _reservePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction minimum bid increment percentage.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external onlyOwner {\r\n        minBidIncrementPercentage = _minBidIncrementPercentage;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the auction replacing bid buffer amount.\r\n     * @dev Only callable by the owner.\r\n     */\r\n    function setMinReplacementIncrease(uint256 _minStackedBidIncrement) external onlyOwner {\r\n        minStackedBidIncrement = _minStackedBidIncrement;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws the contract value to the owner\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        bool success = _transferETH(msg.sender, address(this).balance);\r\n        if (!success) {\r\n            revert WithdrawFailed();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisEquipments.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interface/IAtlantisEquipments.sol\";\r\nimport \"./interface/IAtlantisGemstones.sol\";\r\nimport \"./interface/IStakingWithLock.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\nimport \"./common/Base64.sol\";\r\n\r\n/// @title Atlantis - Equipment contract\r\n/// @dev Fuse 2 equipment of the same tier to receive 1 from the next tier. Equipment can be equipped on spaceships to boost their speed in a race.\r\ncontract AtlantisEquipments is ERC1155, Pausable, Ownable, IAtlantisEquipments, ReentrancyGuard {\r\n    using Strings for uint256;\r\n    using SafeERC20 for IERC20;\r\n    /// @notice Current payment mode\r\n    PaymentMode public paymentMode;\r\n    /// @notice Current payment token\r\n    IERC20 public paymentToken;\r\n    /// @notice Name of contract\r\n    string public name;\r\n    /// @notice Name of symbol\r\n    string public symbol;\r\n    /// @notice Total supply for each collection ids\r\n    mapping(uint256 => uint256) private _totalSupply;\r\n    /// @notice Base token URI\r\n    string public baseTokenURI;\r\n    /// @notice Max number of tokeniDS\r\n    uint256 public constant TOTAL_TOKEN_IDS = 30;\r\n    /// @notice Mint cost of equipments\r\n    uint256 public mintCost = 200 ether;\r\n    /// @notice Contract address of address registry\r\n    AtlantisAddressRegistry public addressRegistry;\r\n    /// @notice Cost of stardust required\r\n    uint256[5] public stardustCost;\r\n    /// @notice Number of gemstones required\r\n    uint16[5] public gemstonesRequired;\r\n    /// @notice Speeds of equipment\r\n    uint16[10] public equipmentSpeeds;\r\n    /// @notice Nonce used for calculation purposes\r\n    uint256 private nonce;\r\n    /// @notice Address of treasury\r\n    address public treasury;\r\n    /// @notice Max number of gemstones required\r\n    uint16 public constant MAX_GEMSTONES_REQUIRED = 500;\r\n    /// @notice Max stardust cost\r\n    uint256 public constant MAX_STARDUST_COST = 500000 ether;\r\n    /// @notice Max mint cost\r\n    uint256 public constant MAX_MINT_COST = 10000000 ether;\r\n    /// @notice Whitelisted addresses who can call airdrop\r\n    mapping(address => bool) public devAddresses;\r\n\r\n    /**\r\n     * @notice Constructor for Atlantis Equipments\r\n     * @param _name Name of contract\r\n     * @param _symbol Symbol of contract\r\n     * @param baseURI base URI with images\r\n     * @param owner Address of owner\r\n     * @param _registry Registry of Atlantis\r\n     * @param _treasury Address of treaury\r\n     */\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory baseURI,\r\n        address owner,\r\n        AtlantisAddressRegistry _registry,\r\n        address _treasury,\r\n        uint256[5] memory _stardustCost,\r\n        uint16[5] memory _gemstonesRequired,\r\n        uint16[10] memory _equipmentSpeeds\r\n    ) ERC1155(baseURI) {\r\n        // Check that registry and treasury are not address(0)\r\n        require(address(_registry) != address(0), \"AtlantisEquipment: Registry is address(0)\");\r\n        require(_treasury != address(0), \"AtlantisEquipment: Treasury is address(0)\");\r\n        // Set name and symbol\r\n        name = _name;\r\n        symbol = _symbol;\r\n        // Set metadata uri\r\n        setBaseMetadataURI(baseURI);\r\n        // Transform ownership to the owner\r\n        transferOwnership(owner);\r\n        // Get atlantis address\r\n        addressRegistry = _registry;\r\n        // Get treasury\r\n        treasury = _treasury;\r\n        // Initialise stardustCost, gemstonesRequired and equipmentSpeeds\r\n        stardustCost = _stardustCost;\r\n        gemstonesRequired = _gemstonesRequired;\r\n        equipmentSpeeds = _equipmentSpeeds;\r\n\r\n        // Set default payment mode\r\n        paymentMode = PaymentMode.TOKEN;\r\n\r\n        // Initialise paymentToken to stardust\r\n        paymentToken = IERC20(addressRegistry.getStardust());\r\n\r\n        // Add owner to the devAddresses\r\n        devAddresses[owner] = true;\r\n    }\r\n\r\n    // ------------------------- VIEW FUNCTIONS ------------------------------\r\n\r\n    /**\r\n     * @dev Total amount of tokens in with a given id.\r\n     * @return uint256\r\n     */\r\n    function totalSupply(uint256 id) public view returns (uint256) {\r\n        return _totalSupply[id];\r\n    }\r\n\r\n    /**\r\n     * @notice Get ImageURI\r\n     * @param _tokenId The id of the equipment\r\n     * @return returns string of imageURI\r\n     */\r\n    function _getImageURI(uint256 _tokenId) internal view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    _baseURI(),\r\n                    uint256(getElement(_tokenId)).toString(),\r\n                    \"/\",\r\n                    uint256(getLevel(_tokenId)).toString(),\r\n                    \".png\"\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Get token metadata with tokenId\r\n     * @param _tokenId The id of the equipment\r\n     * @return returns string of token metadata\r\n     */\r\n    function uri(uint256 _tokenId) public view override returns (string memory) {\r\n        require(exists(_tokenId), \"Resources: URI query for nonexistent token\");\r\n        string memory _name = _tokenIdToEquipmentNameString(_tokenId);\r\n        string memory json = string(\r\n            abi.encodePacked('{\"name\": \"', _name, \" Level \", uint256(getLevel(_tokenId)).toString(), '\",')\r\n        );\r\n        // Description\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"description\": \"Welcome to the captivating realm of Atlantis, the game-verse and home of the legendary Argonauts. Equipment are valuable items which provides speed boost to your Spaceships. Fuse 2 Equipment of the same level to level it up!\",'\r\n            )\r\n        );\r\n        // Attributes\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"attributes\": [{\"trait_type\": \"Type\", \"value\": \"',\r\n                _name,\r\n                '\"},',\r\n                '{\"trait_type\": \"Level\", \"value\": \"',\r\n                uint256(getLevel(_tokenId)).toString(),\r\n                '\"},',\r\n                '{\"trait_type\": \"Speed\", \"value\": \"',\r\n                uint256(getSpeed(_tokenId)).toString(),\r\n                '\"}],'\r\n            )\r\n        );\r\n        json = Base64.encode(bytes(string(abi.encodePacked(json, '\"image\": \"', _getImageURI(_tokenId), '\"}'))));\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\r\n    }\r\n\r\n    // ------------------------- ADMIN FUNCTIONS ------------------------------\r\n\r\n    /**\r\n     * @dev Will update the base URL of token's URI\r\n     * @param _newBaseMetadataURI New base URL of token's URI\r\n     */\r\n    function setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyOwner {\r\n        baseTokenURI = _newBaseMetadataURI;\r\n        emit BaseMetadataURIUpdated(_newBaseMetadataURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Address Registry contract address\r\n     * @param _addressRegistry Address of Address Registry contract\r\n     */\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) external onlyOwner {\r\n        require(address(_addressRegistry) != address(0), \"AtlantisEquipments: Address Registry is address(0)\");\r\n        addressRegistry = _addressRegistry;\r\n        emit AddressRegistryUpdated(address(_addressRegistry));\r\n    }\r\n\r\n    function random() private view returns (uint) {\r\n        uint randomHash = uint(\r\n            keccak256(\r\n                abi.encodePacked(msg.sender, block.coinbase, block.difficulty, block.gaslimit, block.timestamp, nonce)\r\n            )\r\n        );\r\n        return randomHash % 3;\r\n    }\r\n\r\n    function mint(address _to, uint256 _quantity) public payable {\r\n        uint256 _id;\r\n        if (paymentMode == PaymentMode.CRYPTO) {\r\n            require(msg.value == _quantity * mintCost, \"AtlantisEquipments: Insufficient CRO!\");\r\n        } else {\r\n            // Transfer the required tokens from the user\r\n            require(paymentToken.transferFrom(msg.sender, address(this), mintCost * _quantity), \"Transfer failed\");\r\n        }\r\n\r\n        // Loop through quantity\r\n        for (uint256 i = 0; i < _quantity; i++) {\r\n            _id = random() + 1;\r\n            nonce += 1;\r\n            _mint(_to, _id, 1, \"\");\r\n        }\r\n    }\r\n\r\n    // Set mint cost\r\n    function setMintCost(uint256 _newMintCost) external onlyOwner {\r\n        // Mint cost cannot be above max mint cost\r\n        require(_newMintCost <= MAX_MINT_COST, \"AtlantisEquipments: Mint cost cannot be above max mint cost\");\r\n        mintCost = _newMintCost;\r\n        emit MintCostUpdated(_newMintCost);\r\n    }\r\n\r\n    // Set payment mode\r\n    function setPaymentMode(PaymentMode _paymentMode) public {\r\n        paymentMode = _paymentMode;\r\n        emit PaymentModeUpdated(_paymentMode);\r\n    }\r\n\r\n    // Set payment token\r\n    function setPaymentToken(IERC20 _paymentToken) public onlyOwner {\r\n        // Cannot be 0\r\n        require(address(_paymentToken) != address(0), \"AtlantisEquipments: Payment token cannot be address(0)\");\r\n        paymentToken = _paymentToken;\r\n        emit PaymentTokenUpdated(address(_paymentToken));\r\n    }\r\n\r\n    /**\r\n     * @dev Mint tokens for each id in _ids\r\n     * @param _to          The address to mint tokens to\r\n     * @param _ids         Array of ids to mint\r\n     * @param _quantities  Array of amounts of tokens to mint per id\r\n     * @param _data        Data to pass if receiver is contract\r\n     */\r\n    function batchMint(\r\n        address _to,\r\n        uint256[] memory _ids,\r\n        uint256[] memory _quantities,\r\n        bytes memory _data\r\n    ) public onlyOwner {\r\n        _mintBatch(_to, _ids, _quantities, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all CRO from this account to the owner\r\n     */\r\n    function withdrawFund() external onlyOwner {\r\n        (bool success, ) = payable(treasury).call{ value: address(this).balance }(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    // ------------------------- INTERNAL FUNCTIONS ------------------------------\r\n\r\n    /// @dev Gets baseToken URI\r\n    function _baseURI() internal view returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC1155-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the contract must not be paused.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override(ERC1155) {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\r\n        if (from == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                _totalSupply[ids[i]] += amounts[i];\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                uint256 id = ids[i];\r\n                uint256 amount = amounts[i];\r\n                uint256 supply = _totalSupply[id];\r\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\r\n                unchecked {\r\n                    _totalSupply[id] = supply - amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Indicates whether any token exist with a given id, or not.\r\n     */\r\n    function exists(uint256 _id) public view virtual returns (bool) {\r\n        return _id > 0 && _id <= TOTAL_TOKEN_IDS;\r\n    }\r\n\r\n    /**\r\n     * @dev Get gemstone id from equipment Id\r\n     */\r\n    function getGemstoneIdFromEquipmentId(uint256 _id) public pure returns (uint256) {\r\n        if (_id > 27) {\r\n            revert UpgradeError();\r\n        }\r\n        uint256 _element = (_id % 3);\r\n        uint256 _gemstoneId;\r\n        if (_element == 1) {\r\n            _gemstoneId = 10;\r\n        } else if (_element == 2) {\r\n            _gemstoneId = 11;\r\n        } else if (_element == 0) {\r\n            _gemstoneId = 12;\r\n        }\r\n        return _gemstoneId;\r\n    }\r\n\r\n    /**\r\n     * @notice Get equipment name from tokenId\r\n     * @param _tokenId The id of the equipment\r\n     */\r\n    function _tokenIdToEquipmentNameString(uint256 _tokenId) internal pure returns (string memory) {\r\n        uint256 _element = (_tokenId % 3);\r\n        string memory _elementName;\r\n        if (_element == 1) {\r\n            _elementName = \"Inferno Thrusters\";\r\n        } else if (_element == 2) {\r\n            _elementName = \"Thunderbolt Wings\";\r\n        } else if (_element == 0) {\r\n            _elementName = \"Argonium Exoshell\";\r\n        }\r\n        return _elementName;\r\n    }\r\n\r\n    /**\r\n     * @notice Fuse equipment\r\n     * @param _id The id of the equipment\r\n     * @param _amountToCreate Amount of next tier equipment to create\r\n     */\r\n    function fuseEquipment(uint256 _id, uint16 _amountToCreate) external nonReentrant {\r\n        IAtlantisGemstones atlantisGemstones = IAtlantisGemstones(addressRegistry.getGemstones());\r\n        IStakingWithLock stakingWithLock = IStakingWithLock(addressRegistry.getStakingWithLock());\r\n        // Total fusion cost\r\n        uint256 _fusionCost = calculateFusionCost(_id, _amountToCreate);\r\n\r\n        // gemstone cost\r\n        uint256 _gemstoneCost = calculateGemstonesCost(_id, _amountToCreate);\r\n        // Calculate Equipment required to fuse\r\n        uint256 _amountToBurn = fuseEquipmentsView(_id, _amountToCreate);\r\n        uint256 _toId = _id + 3;\r\n        _burn(msg.sender, _id, _amountToBurn);\r\n        // Mint new Equipment\r\n        _mint(msg.sender, _toId, _amountToCreate, \"\");\r\n        // Burn Gemstone\r\n        atlantisGemstones.burn(msg.sender, getGemstoneIdFromEquipmentId(_id), _gemstoneCost);\r\n        // Burn stardust if _fusionCost is more than 0\r\n        if (_fusionCost > 0) {\r\n            stakingWithLock.unstakeAndBurn(_fusionCost);\r\n        }\r\n        // Emit fuse event\r\n        emit FuseEquipment(msg.sender, _toId, _amountToCreate, totalSupply(_toId));\r\n    }\r\n\r\n    /**\r\n     * @notice Get equipment speed from id\r\n     * @param _id Specific equipment id\r\n     * @return speed of equipment\r\n     */\r\n    function getSpeed(uint256 _id) public view returns (uint16) {\r\n        if (_id > 30) {\r\n            revert IdNotExistsError();\r\n        } else if (_id == 0) {\r\n            return 0;\r\n        }\r\n        uint8 _level = getLevel(_id);\r\n        return equipmentSpeeds[_level - 1];\r\n    }\r\n\r\n    /**\r\n     * @notice Get level of equipment from its id\r\n     * @param _id Specific equipment id\r\n     * @return level of equipment\r\n     */\r\n    function getLevel(uint256 _id) public pure returns (uint8) {\r\n        if (_id > 30) {\r\n            revert IdNotExistsError();\r\n        } else if (_id == 0) {\r\n            return 0;\r\n        }\r\n        // Logic above level 5\r\n        uint8 _level;\r\n        if ((_id % 3) == 0) {\r\n            _level = uint8(_id) / 3;\r\n        } else {\r\n            _level = uint8(_id) / 3 + 1;\r\n        }\r\n\r\n        return _level;\r\n    }\r\n\r\n    /**\r\n     * @notice Get element from id\r\n     * @param _id Specific equipment id\r\n     * @return element\r\n     */\r\n    function getElement(uint256 _id) public pure returns (uint8) {\r\n        if (_id > 30 || _id == 0) {\r\n            revert IdNotExistsError();\r\n        }\r\n        uint8 _element = uint8(_id) % 3;\r\n        return _element;\r\n    }\r\n\r\n    /** Token Ids\r\n     * 1 2 3 Fire Lightning Steel Equipment Level 1\r\n     * 4 5 6 Fire Lightning Steel Equipment Level 2\r\n     * 7 8 9 Fire Lightning Steel Equipment Level 3\r\n     * 10 11 12 Fire Lightning Steel Equipment Level 4\r\n     * 13 14 15 Fire Lightning Steel Equipment Level 5\r\n     * 16 17 18 Fire Lightning Steel Equipment Level 6\r\n     * 19 20 21 Fire Lightning Steel Equipment Level 7\r\n     * 22 23 24 Fire Lightning Steel Equipment Level 8\r\n     * 25 26 27 Fire Lightning Steel Equipment Level 9\r\n     * 28 29 30 Fire Lightning Steel Equipment Level 10\r\n     */\r\n\r\n    /**\r\n     * @notice Calculates cost of fusing equipment\r\n     * @param _id Specific equipment id\r\n     * @param _amountToCreate Amount of next tier equipment to create\r\n     * @return Fusion cost\r\n     */\r\n    function calculateFusionCost(uint256 _id, uint16 _amountToCreate) public view returns (uint256) {\r\n        // Logic for level 1 - 4\r\n        if (_id < 13) {\r\n            return 0;\r\n        } else if (_id > 27) {\r\n            revert UpgradeError();\r\n        }\r\n        // Logic above level 5\r\n        uint8 _level = getLevel(_id);\r\n        return uint256(_amountToCreate) * stardustCost[_level - 5];\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates gemstone cost of fusing equipmenet\r\n     * @param _id Specific equipment id\r\n     * @param _amountToCreate Amount of next tier equipment to create\r\n     * @return Gemstone cost\r\n     */\r\n    function calculateGemstonesCost(uint256 _id, uint16 _amountToCreate) public view returns (uint16) {\r\n        // Logic for level 1 - 4\r\n        if (_id < 13) {\r\n            return 0;\r\n        }\r\n        // Logic above level 5\r\n        uint8 _level;\r\n        if ((_id % 3) == 0) {\r\n            _level = uint8(_id) / 3;\r\n        } else {\r\n            _level = uint8(_id) / 3 + 1;\r\n        }\r\n        return _amountToCreate * gemstonesRequired[_level - 5];\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates how much is require dto fuse to get amountToCreate\r\n     * @param _id Specific equipment id\r\n     * @param _amountToCreate Amount of next tier equipment to create\r\n     * @return amount to fuse\r\n     */\r\n    function fuseEquipmentsView(uint256 _id, uint16 _amountToCreate) public view override returns (uint16) {\r\n        if (!exists(_id) || _amountToCreate == 0) {\r\n            revert UpgradeError();\r\n        }\r\n        // Get amount of gemstones to fuse\r\n        uint16 amountToFuse = 2 * _amountToCreate;\r\n        return amountToFuse;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets stardust costs\r\n     * @param _stardustCost Array of stardust costs\r\n     */\r\n    function setStardustCosts(uint256[] calldata _stardustCost) external onlyOwner {\r\n        // Loop through and set stardust\r\n        for (uint256 i = 0; i < _stardustCost.length; i++) {\r\n            // Check if the provided value is within the allowed range\r\n            require(_stardustCost[i] <= MAX_STARDUST_COST, \"Value exceeds the maximum allowed\");\r\n            stardustCost[i] = _stardustCost[i];\r\n        }\r\n        emit StardustCostsUpdated(_stardustCost);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets gemstones required\r\n     * @param _gemstonesRequired Array of gemstonesRequired\r\n     */\r\n    function setGemstonesRequired(uint16[] memory _gemstonesRequired) external onlyOwner {\r\n        // Loop through and set gemstonesRequired\r\n        for (uint8 i = 0; i < _gemstonesRequired.length; i++) {\r\n            // Check if the provided value is within the allowed range\r\n            require(_gemstonesRequired[i] <= MAX_GEMSTONES_REQUIRED, \"Value exceeds the maximum allowed\");\r\n            gemstonesRequired[i] = _gemstonesRequired[i];\r\n        }\r\n        emit GemstonesRequiredUpdated(_gemstonesRequired);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets speeds of equipments\r\n     * @param _equipmentSpeeds Array of equipment speeds\r\n     */\r\n    function setEquipmentSpeeds(uint16[] memory _equipmentSpeeds) external onlyOwner {\r\n        // Loop through and set equipmentSpeeds\r\n        for (uint8 i = 0; i < _equipmentSpeeds.length; i++) {\r\n            equipmentSpeeds[i] = _equipmentSpeeds[i];\r\n        }\r\n        emit EquipmentSpeedsUpdated(_equipmentSpeeds);\r\n    }\r\n\r\n    /**\r\n     * @dev Airdrop some equipments to an address\r\n     * @param _to          Address of the future owner of the token\r\n     * @param _id          Token ID to mint\r\n     * @param _quantity    Amount of tokens to mint\r\n     * @param _data        Data to pass if receiver is contract\r\n     */\r\n    function airdrop(address _to, uint256 _id, uint256 _quantity, bytes memory _data) external {\r\n        // Only whitelisted addresses can call this function\r\n        require(devAddresses[msg.sender], \"Only whitelisted addresses can call this function\");\r\n        _mint(_to, _id, _quantity, _data);\r\n    }\r\n\r\n    // Whitelist dev addresses\r\n    function whitelistDevAddresses(address[] memory _devAddresses) external onlyOwner {\r\n        for (uint256 i = 0; i < _devAddresses.length; i++) {\r\n            devAddresses[_devAddresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Pause contract in case of emergency\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause contract in case of emergency\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisFaucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\n\r\n// Official incentivised testnet version\r\ncontract AtlantisFaucet is Ownable {\r\n    // Whitelist Mapping\r\n    mapping(address => bool) public whitelisted;\r\n    mapping(address => bool) public dripped;\r\n    AtlantisAddressRegistry public addressRegistry;\r\n\r\n    // // onlyWhitelisted modifier\r\n    // modifier onlyWhitelisted() {\r\n    //     require(whitelisted[msg.sender], \"Faucet: Not whitelisted\");\r\n    //     _;\r\n    // }\r\n\r\n    // receive\r\n    receive() external payable {}\r\n\r\n    constructor(AtlantisAddressRegistry _addressRegistry) {\r\n        addressRegistry = _addressRegistry;\r\n        whitelisted[msg.sender] = true;\r\n    }\r\n\r\n    function drip() external {\r\n        //  require(!dripped[msg.sender], \"Faucet: Already dripped\");\r\n        address argonauts = addressRegistry.getArgonauts();\r\n        address equipment = addressRegistry.getEquipments();\r\n        address gemstones = addressRegistry.getGemstones();\r\n        address spaceships = addressRegistry.getSpaceships();\r\n        address planets = addressRegistry.getAtlantisPlanets();\r\n        address xargo = addressRegistry.getXargo();\r\n        address gold = addressRegistry.getGold();\r\n\r\n        // Transfer 500 cro to user\r\n        //payable(msg.sender).transfer(500 ether);\r\n\r\n        // Transfer 750000 xArgo to user\r\n        (bool success, ) = xargo.call(abi.encodeWithSignature(\"devMint(uint256)\", 750000 ether));\r\n        require(success, \"Faucet: xargo mint failed\");\r\n\r\n        // Transfer 1000000 gold to user\r\n        (success, ) = gold.call(abi.encodeWithSignature(\"mint(uint256,address)\", 1000000 ether, msg.sender));\r\n        require(success, \"Faucet: gold mint failed\");\r\n\r\n        // devMint Gemstones\r\n        for (uint8 i = 1; i <= 3; i++) {\r\n            (success, ) = gemstones.call(\r\n                abi.encodeWithSignature(\"airdrop(address,uint256,uint256,bytes)\", msg.sender, i, 100000, \"0x\")\r\n            );\r\n            require(success, \"Faucet: gemstone mint failed\");\r\n            (success, ) = equipment.call(\r\n                abi.encodeWithSignature(\"airdrop(address,uint256,uint256,bytes)\", msg.sender, i, 1000, \"0x\")\r\n            );\r\n            require(success, \"Faucet: equipment mint failed\");\r\n        }\r\n        // devMint Argonauts using external call\r\n        (success, ) = argonauts.call(abi.encodeWithSignature(\"mint(uint256)\", 30));\r\n        require(success, \"Faucet: argonaut mint failed\");\r\n\r\n        // devMint Spaceships\r\n        uint8[] memory spaceshipRarity = new uint8[](4);\r\n        spaceshipRarity[0] = 0;\r\n        spaceshipRarity[1] = 1;\r\n        spaceshipRarity[2] = 2;\r\n        spaceshipRarity[3] = 3;\r\n        address[] memory addresses = new address[](4);\r\n        addresses[0] = msg.sender;\r\n        addresses[1] = msg.sender;\r\n        addresses[2] = msg.sender;\r\n        addresses[3] = msg.sender;\r\n        (success, ) = spaceships.call(\r\n            abi.encodeWithSignature(\"airdrop(address[],uint8[])\", addresses, spaceshipRarity)\r\n        );\r\n        require(success, \"Faucet: spaceship mint failed\");\r\n        // devMint Planets\r\n        (success, ) = planets.call(abi.encodeWithSignature(\"faucetMint(address)\", msg.sender));\r\n        require(success, \"Faucet: planet mint failed\");\r\n\r\n        // dripped[msg.sender] = true;\r\n    }\r\n\r\n    function whitelistAddresses(address[] calldata _addresses) external onlyOwner {\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            whitelisted[_addresses[i]] = true;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisGemstones.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./interface/IStakingWithLock.sol\";\r\nimport { IAtlantisGemstones } from \"./interface/IAtlantisGemstones.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\nimport \"./common/Base64.sol\";\r\n\r\n/// @title Atlantis - Gemstones contract\r\n/// @dev Fuse 3 gemstones of the same tier to receive 1 from the next tier. Gemstones can be used to upgrade planets and are also required for certain levels of equipment fusion.\r\ncontract AtlantisGemstones is ERC1155, Pausable, Ownable, IAtlantisGemstones, ReentrancyGuard {\r\n    using Strings for uint256;\r\n    /// @notice Address registry contract\r\n    AtlantisAddressRegistry public addressRegistry;\r\n    /// @notice Name of contract\r\n    string public name;\r\n    /// @notice Symbol of contract\r\n    string public symbol;\r\n    /// @notice Base token URI\r\n    string public baseTokenURI;\r\n    /// @notice Total amount of Ids\r\n    uint256 public constant TOTAL_TOKEN_IDS = 12;\r\n    /// @notice Total supply of each tokenId\r\n    mapping(uint256 => uint256) private _totalSupply;\r\n    /// @notice Stardust fusion cost\r\n    uint256 public FUSION_COST = 200 ether;\r\n    /// @notice Whitelisted addresses who can call airdrop\r\n    mapping(address => bool) public devAddresses;\r\n    // ------------------------- EVENTS --------------------------\r\n    event MintGemstone(address indexed _to, uint256 indexed _id, uint256 _amount, uint256 _totalSupply);\r\n    event FuseGemstone(address indexed _from, uint256 indexed _id, uint256 _amount, uint256 _totalSupply);\r\n    error IdNotExistsError();\r\n\r\n    // ----------------------- MODIFIERS -------------------------\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _uri,\r\n        address owner,\r\n        address _registry\r\n    ) ERC1155(_uri) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        addressRegistry = AtlantisAddressRegistry(_registry);\r\n\r\n        setBaseMetadataURI(_uri);\r\n        transferOwnership(owner);\r\n        devAddresses[owner] = true;\r\n    }\r\n\r\n    // ------------------------- PUBLIC FUNCTIONS ------------------------------\r\n    /**\r\n     * @dev Fuse 3 Gemstones to get another Gemstone of a higher tier\r\n     * @param _id The Gemstone id\r\n     * @param _amountToCreate The amount of Gemstones to create\r\n     * Gemstone Upgrade Sheet\r\n     *           Tier 1 -> Tier 2 -> Tier 3 -> Tier 4\r\n     * FIRE      ID 1   -> ID 4   -> ID 7   -> ID 10\r\n     * LIGHTNING ID 2   -> ID 5   -> ID 8   -> ID 11\r\n     * STEEL     ID 3   -> ID 6   -> ID 9   -> ID 12\r\n     */\r\n    function fuseGemstones(uint8 _id, uint8 _toId, uint256 _amountToCreate) external nonReentrant whenNotPaused {\r\n        IStakingWithLock stakingWithLock = IStakingWithLock(addressRegistry.getStakingWithLock());\r\n        // Calculate Gemstone required to fuse\r\n        uint256 _amountToBurn = calculateGemstoneCost(_id, _toId, _amountToCreate);\r\n        // Burn Gemstones\r\n        _burn(msg.sender, _id, _amountToBurn);\r\n        // Mint new Gemstone\r\n        _mint(msg.sender, _toId, _amountToCreate, \"\");\r\n        // Total fusion cost\r\n        uint256 fusionCost = calculateFusionCost(_id, _toId, _amountToCreate);\r\n        // Burn stardust\r\n        stakingWithLock.unstakeAndBurn(fusionCost);\r\n        // Emit fuse event\r\n        emit FuseGemstone(msg.sender, _toId, _amountToCreate, totalSupply(_toId));\r\n    }\r\n\r\n    // View function to calculate fusion cost\r\n    function calculateFusionCost(uint8 _id, uint8 _toId, uint256 _amountToCreate) public view returns (uint256) {\r\n        // Calculate Gemstone required to fuse\r\n        uint256 _amountToBurn = calculateGemstoneCost(_id, _toId, _amountToCreate);\r\n        return (_amountToBurn * FUSION_COST) / 3;\r\n    }\r\n\r\n    // View function to see how many Gemstones required to fuse to amountToCreate\r\n    function calculateGemstoneCost(uint8 _id, uint8 _toId, uint256 _amountToCreate) public view returns (uint256) {\r\n        if (_amountToCreate == 0) revert InvalidInputAmount();\r\n        if (!exists(_id) || !exists(_toId)) revert NonExistentToken();\r\n        if ((_toId % 3 != _id % 3)) revert InvalidElement();\r\n\r\n        if (_id >= _toId) revert InvalidUpgrade();\r\n\r\n        // Require toId to be more than id\r\n        // Require toId to be in multiples of 3 more than id\r\n        // Calculate how many Gemstones to fuse to get toId\r\n        // Get tier difference\r\n        uint8 tierDifference = (_toId - _id) / 3;\r\n        // Get amount of Gemstones to fuse\r\n        uint256 amountToFuse = 3 ** tierDifference * _amountToCreate;\r\n        return amountToFuse;\r\n    }\r\n\r\n    // Setter for fusion cost\r\n    function setFusionCost(uint256 _cost) external onlyOwner {\r\n        FUSION_COST = _cost;\r\n        emit FusionCostUpdated(_cost);\r\n    }\r\n\r\n    // Get element from id\r\n    function getElement(uint256 _id) public pure returns (uint8) {\r\n        if (_id > 12 || _id == 0) {\r\n            revert IdNotExistsError();\r\n        }\r\n        uint8 _element = uint8(_id) % 3;\r\n        return _element;\r\n    }\r\n\r\n    function _tokenIdtoElementString(uint256 _id) internal pure returns (string memory) {\r\n        if (_id > 12) {\r\n            revert IdNotExistsError();\r\n        }\r\n        uint8 _element = uint8(_id) % 3;\r\n        if (_element == 0) {\r\n            return \"Steel\";\r\n        } else if (_element == 1) {\r\n            return \"Fire\";\r\n        } else {\r\n            return \"Lightning\";\r\n        }\r\n    }\r\n\r\n    // Get tier from id\r\n    function getTier(uint256 _id) public pure returns (uint8) {\r\n        if (_id > 12) {\r\n            revert IdNotExistsError();\r\n        }\r\n        uint8 _tier = uint8(_id) / 3;\r\n        if (uint8(_id) % 3 == 0) {\r\n            return _tier;\r\n        } else {\r\n            return _tier + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mints some amount of tokens to an address\r\n     * @param _to          Address of the future owner of the token\r\n     * @param _id          Token ID to mint\r\n     * @param _quantity    Amount of tokens to mint\r\n     */\r\n    function mint(address _to, uint256 _id, uint256 _quantity) external {\r\n        if (!(addressRegistry.isControllerContract(msg.sender) || msg.sender == owner())) revert OnlyAtlantisOrOwner();\r\n        if (!exists(_id)) revert NonExistentToken();\r\n        _mint(_to, _id, _quantity, \"\");\r\n        // emit Mint event\r\n        emit MintGemstone(_to, _id, _quantity, totalSupply(_id));\r\n    }\r\n\r\n    /**\r\n     * @dev Burns some amount of tokens from an address\r\n     */\r\n    function burn(address _user, uint256 _id, uint256 _quantity) external {\r\n        if (!(addressRegistry.isControllerContract(msg.sender) || msg.sender == owner())) revert OnlyAtlantisOrOwner();\r\n        if (!exists(_id)) revert NonExistentToken();\r\n        _burn(_user, _id, _quantity);\r\n    }\r\n\r\n    // ------------------------- PUBLIC VIEW FUNCTIONS ------------------------------\r\n    // Get Image Uri\r\n    /**\r\n     * @notice Get ImageURI\r\n     * @param _tokenId The Gemstone id\r\n     */\r\n    function _getImageURI(uint256 _tokenId) internal view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    _baseURI(),\r\n                    uint256(getElement(_tokenId)).toString(),\r\n                    \"/\",\r\n                    uint256(getTier(_tokenId)).toString(),\r\n                    \".png\"\r\n                )\r\n            );\r\n    }\r\n\r\n    function uri(uint256 _tokenId) public view override returns (string memory) {\r\n        if (!exists(_tokenId)) revert NonExistentToken();\r\n        string memory element = _tokenIdtoElementString(_tokenId);\r\n        string memory json = string(\r\n            abi.encodePacked('{\"name\": \"', element, \" Gemstone Tier \", uint256(getTier(_tokenId)).toString(), '\",')\r\n        );\r\n        // Description\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"description\": \"Welcome to the captivating realm of Atlantis, the game-verse and home of the legendary Argonauts. Gemstones are powerful resources in Atlantis and exist in four different tiers. Acquire Gemstones to level up your planets and equipment parts. Fuse 3 Gemstones of the same tier to get a higher tier Gemstone!\",'\r\n            )\r\n        );\r\n        // Attributes\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"attributes\": [{\"trait_type\": \"Element\", \"value\": \"',\r\n                element,\r\n                '\"},',\r\n                '{\"trait_type\": \"Tier\", \"value\": \"',\r\n                uint256(getTier(_tokenId)).toString(),\r\n                '\"}],'\r\n            )\r\n        );\r\n        json = Base64.encode(bytes(string(abi.encodePacked(json, '\"image\": \"', _getImageURI(_tokenId), '\"}'))));\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\r\n    }\r\n\r\n    // ------------------------- ADMIN FUNCTIONS ------------------------------\r\n\r\n    /**\r\n     * @dev Will update the base URL of token's URI\r\n     * @param _newBaseMetadataURI New base URL of token's URI\r\n     */\r\n    function setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyOwner {\r\n        baseTokenURI = _newBaseMetadataURI;\r\n        emit BaseMetadataURIUpdated(_newBaseMetadataURI);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Address Registry\r\n     * @param _addressRegistry The address of the Address Registry\r\n     */\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) external onlyOwner {\r\n        // Require that the address is not null\r\n        require(address(_addressRegistry) != address(0), \"Address cannot be null\");\r\n        addressRegistry = _addressRegistry;\r\n        emit AddressRegistryUpdated(address(_addressRegistry));\r\n    }\r\n\r\n    // ------------------------- INTERNAL FUNCTIONS ------------------------------\r\n\r\n    /**\r\n     * @dev Gets baseToken URI\r\n     */\r\n    function _baseURI() internal view returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets baseToken URI\r\n     */\r\n    function baseURI() external view returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Total amount of tokens in with a given id.\r\n     */\r\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\r\n        return _totalSupply[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Indicates whether any token exist with a given id, or not.\r\n     * @dev There are only Gemstones with tokenIds 1-12\r\n     */\r\n    function exists(uint256 _id) public view virtual returns (bool) {\r\n        return _id > 0 && _id <= TOTAL_TOKEN_IDS;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC1155-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the contract must not be paused.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override(ERC1155) {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\r\n\r\n        if (from == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                _totalSupply[ids[i]] += amounts[i];\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                uint256 id = ids[i];\r\n                uint256 amount = amounts[i];\r\n                uint256 supply = _totalSupply[id];\r\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\r\n                unchecked {\r\n                    _totalSupply[id] = supply - amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Airdrops some gemstones to an address; for giveaways\r\n     * @param _to          Address of the future owner of the token\r\n     * @param _id          Token ID to mint\r\n     * @param _quantity    Amount of tokens to mint\r\n     * @param _data        Data to pass if receiver is contract\r\n     */\r\n    function airdrop(address _to, uint256 _id, uint256 _quantity, bytes memory _data) external {\r\n        // Only whitelisted addresses can call this function\r\n        require(devAddresses[msg.sender], \"Only whitelisted addresses can call this function\");\r\n        // Only allow ids from 1-12\r\n        if (!exists(_id)) revert NonExistentToken();\r\n        _mint(_to, _id, _quantity, _data);\r\n    }\r\n\r\n    // Whitelist dev addresses\r\n    function whitelistDevAddresses(address[] memory _devAddresses) external onlyOwner {\r\n        for (uint256 i = 0; i < _devAddresses.length; i++) {\r\n            devAddresses[_devAddresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Pause contract in case of emergency\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause contract in case of emergency\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisPlanets.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interface/IAtlantisPlanets.sol\";\r\nimport \"./interface/IAtlantisGemstones.sol\";\r\nimport \"./interface/IStakingWithLock.sol\";\r\nimport \"./common/WithLimitedSupply.sol\";\r\nimport \"./common/RandomlyAssigned.sol\";\r\nimport \"./common/Base64.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/// @title Atlantis Planets Mint Contract\r\n/// @dev Max Supply of 6000 planets\r\n/// @dev First 12 planets are EPIC planets\r\n// Stages\r\n// 0: Before all minting commence\r\n// 1: WhiteList Sale\r\n// 2: Public sale\r\n// 3: Post-Mint (Admin Phase)\r\n// 4: Game Phase\r\n\r\ncontract AtlantisPlanets is ERC721, Ownable, IAtlantisPlanets, RandomlyAssigned {\r\n    using Strings for uint256;\r\n    using ECDSA for bytes32;\r\n\r\n    AtlantisAddressRegistry public addressRegistry;\r\n\r\n    string public baseURI;\r\n\r\n    uint8 public stage;\r\n    uint256 currentSupply;\r\n    uint256 public whitelistPhase;\r\n\r\n    // VIP Whitelist Mint Settings 750 cro\r\n    uint256 public vipMintMaxPerWallet = 10; // VIP Sale Address Mint Cap\r\n    uint256 public vipMintPrice = 0 ether; // VIP Sale Mint Price\r\n    mapping(address => uint256) public vipMintCount;\r\n\r\n    // Whitelist Mint Settings 850 cro\r\n    uint256 public whitelistMintMaxPerWallet = 20; // Private Sale Address Mint Cap\r\n    uint256 public whitelistMintPrice = 1 ether; // Private Sale Mint Price\r\n    mapping(address => uint256) public whitelistMintCount;\r\n    address private whitelistSignerAddress;\r\n\r\n    // Public Sale Mint Settings 950 cro\r\n    uint256 public publicMintPrice = 0 ether;\r\n    uint256 public publicMintMaxPerWallet = type(uint256).max; // Unlimited mint\r\n    mapping(address => uint256) public publicMintCount;\r\n\r\n    // Treasury\r\n    address public treasury;\r\n\r\n    // Levelling\r\n    bytes public levelUpGemstone;\r\n    // xARGO base cost\r\n    uint256 public xArgoBaseCost = 40 ether;\r\n    // stardust base cost\r\n    uint256 public stardustBaseCost = 200 ether;\r\n    // stardust base cost scaling\r\n    uint256 public stardustBaseCostScaling = 25;\r\n    // stardust rarity cost scaling\r\n    uint256 public stardustRarityCostScaling = 20;\r\n    // Mapping of planet token id to planet struct\r\n    mapping(uint256 => AtlantisLib.Planet) public planets;\r\n\r\n    // Variable to track Gemstone tiers\r\n    uint16 public constant gemstoneTiers = 4;\r\n    // Variable to track max planet level\r\n    uint16 public constant maxPlanetLevel = 50;\r\n\r\n    bool public revealed = false;\r\n    string public unrevealedImageURI = \"ipfs://bafybeicabmv4ccbblnnpfq6q5rg5sr2qqq4mc7y7y3tqyfztiwzrkff5vi\";\r\n\r\n    // gemstone token ids is in the following sequence:\r\n    // 1 - Fire 1\r\n    // 2 - Lightning 1\r\n    // 3 - Steel 1\r\n    // 4 - Fire 2\r\n    // 5 - Lightning 2\r\n    // 6 - Steel 2\r\n    // 7 - Fire 3\r\n    // 8 - Lightning 3\r\n    // 9 - Steel 3\r\n    // 10 - Fire 4\r\n    // 11 - Lightning 4\r\n    // 12 - Steel 4\r\n\r\n    // Events\r\n    event PlanetUpgraded(uint256 indexed tokenId, uint256 indexed level);\r\n    event PrivateMint(address indexed to, uint256 amount);\r\n    event PublicMint(address indexed to, uint256 amount);\r\n\r\n    // -------------------- MODIFIERS ----------------------\r\n\r\n    /**\r\n     * @dev Prevent Smart Contracts from calling the functions with this modifier\r\n     */\r\n    modifier onlyEOA() {\r\n        require(msg.sender == tx.origin, \"Planets: must use EOA\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _owner,\r\n        address _whitelistSignerAddress,\r\n        string memory __baseURI,\r\n        AtlantisAddressRegistry _addressRegistry\r\n    ) ERC721(\"Atlantis Planets\", \"PLANETS\") RandomlyAssigned(6000, 13) {\r\n        setTreasury(_owner);\r\n        setWhitelistSignerAddress(_whitelistSignerAddress);\r\n        setBaseURI(__baseURI);\r\n        transferOwnership(_owner);\r\n        currentSupply = 0;\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Revealed Metadata URI\r\n     */\r\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n        baseURI = _newBaseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Unrevealed Metadata URI\r\n     */\r\n    function setUnrevealedImageURI(string memory _newUnrevealedImageURI) public onlyOwner {\r\n        unrevealedImageURI = _newUnrevealedImageURI;\r\n    }\r\n\r\n    // -------------------- ATLANTIS PUBLIC FUNCTIONS ----------------------\r\n\r\n    /**\r\n     * @dev Get gemstone upgrade requirements for upgrading a planet\r\n     * @param _tokenId The token id of the planet\r\n     * @param _levels The number of levels to upgrade\r\n     * @return gemstoneRequirements The gemstone requirements for upgrading the planet\r\n     */\r\n    function getUpgradeRequirements(\r\n        uint256 _tokenId,\r\n        uint8 _levels\r\n    ) internal view returns (uint16[4] memory gemstoneRequirements) {\r\n        // Get planet struct\r\n        AtlantisLib.Planet memory planet = planets[_tokenId];\r\n        uint8 planetLevel = planet.level;\r\n        uint8 newLevel = planetLevel + _levels;\r\n        uint8 orbit = uint8(planet.orbit);\r\n\r\n        if (planetLevel + _levels > maxPlanetLevel) revert ExceededMaxLevel();\r\n\r\n        // Cumulative requirement at target level - Cumulative requirement at current level = requirement for upgrade\r\n        gemstoneRequirements[0] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 0) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 0);\r\n\r\n        gemstoneRequirements[1] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 1) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 1);\r\n\r\n        gemstoneRequirements[2] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 2) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 2);\r\n\r\n        gemstoneRequirements[3] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 3) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 3);\r\n    }\r\n\r\n    /**\r\n     * @notice Get uint16 value from a byte array\r\n     * @param _bytes The byte array\r\n     * @param orbit Orbit of the planet\r\n     * @param level Level of the planet\r\n     * @param tier Tier of the gemstone\r\n     * @dev This function was modified to serve retriving the gemstone upgrade requirements\r\n     */\r\n    function toUint16(\r\n        bytes memory _bytes,\r\n        uint256 orbit,\r\n        uint256 level,\r\n        uint256 tier\r\n    ) internal pure returns (uint16 tempUint) {\r\n        uint256 _start = orbit * 8 + (level - 1) * 32 + tier * 2;\r\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get evolution stage of planet\r\n     * @param level Level of a planet\r\n     */\r\n    function _getPlanetEvolution(\r\n        uint16 level\r\n    ) internal pure returns (AtlantisLib.Evolution evo, string memory evoString) {\r\n        if (level < 20) {\r\n            evo = AtlantisLib.Evolution.ALPHA;\r\n            evoString = \"Alpha\";\r\n        } else if (level >= 20 && level < 30) {\r\n            evo = AtlantisLib.Evolution.BETA;\r\n            evoString = \"Beta\";\r\n        } else if (level >= 30 && level < 40) {\r\n            evo = AtlantisLib.Evolution.GAMMA;\r\n            evoString = \"Gamma\";\r\n        } else if (level >= 40 && level < 50) {\r\n            evo = AtlantisLib.Evolution.DELTA;\r\n            evoString = \"Delta\";\r\n        } else if (level == 50) {\r\n            evo = AtlantisLib.Evolution.EPSILON;\r\n            evoString = \"Epsilon\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get planet details\r\n     * @dev Planet details include: level, element, orbit, onExpedition\r\n     */\r\n    function getPlanetDetails(uint256 _planetId) external view returns (AtlantisLib.Planet memory) {\r\n        AtlantisLib.Planet memory planet = planets[_planetId];\r\n        return planet;\r\n    }\r\n\r\n    /**\r\n     * @notice Return xArgo cost for upgrading a planet\r\n     */\r\n    function getxArgoCost(uint8 currentLevel, uint8 newLevel) internal view returns (uint256 xArgoCost) {\r\n        if (currentLevel == 0 || currentLevel >= newLevel) revert InvalidUpgradeLevel(currentLevel, newLevel);\r\n\r\n        // Loop through all levels and add up xArgo cost\r\n        for (uint256 i = currentLevel; i < newLevel; i++) {\r\n            xArgoCost += xArgoBaseCost * i;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Return stardust cost for upgrading a planet\r\n     * @param currentLevel Current Level of Planet\r\n     * @param newLevel New planet level\r\n     * @param orbit Orbit of planet\r\n     */\r\n    function getStardustCost(\r\n        uint8 currentLevel,\r\n        uint8 newLevel,\r\n        uint8 orbit\r\n    ) internal view returns (uint256 stardustCost) {\r\n        if (currentLevel == 0 || currentLevel >= newLevel) revert InvalidUpgradeLevel(currentLevel, newLevel);\r\n\r\n        // Loop through all levels and add up stardust cost\r\n        for (uint256 i = currentLevel; i < newLevel; i++) {\r\n            stardustCost +=\r\n                (stardustBaseCost *\r\n                    (((i - 1) * stardustBaseCostScaling + 100) * ((orbit) * stardustRarityCostScaling + 100))) /\r\n                10000;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * External function for frontend to retrieve stardust, xArgo, and gemstone costs in 1 multicall\r\n     */\r\n    function getUpgradeCosts(\r\n        uint256 _tokenId,\r\n        uint8 _levels\r\n    ) external view returns (uint256 stardustCost, uint256 xArgoCost, uint16[4] memory gemstoneRequirements) {\r\n        // Get planet struct\r\n        AtlantisLib.Planet memory planet = planets[_tokenId];\r\n        uint8 planetLevel = planet.level;\r\n        uint8 newLevel = planetLevel + _levels;\r\n        uint8 orbit = uint8(planet.orbit);\r\n\r\n        require(planetLevel + _levels <= maxPlanetLevel, \"Planets: Planet cannot be upgraded to this level!\");\r\n\r\n        // Get stardust cost\r\n        stardustCost = getStardustCost(planetLevel, newLevel, orbit);\r\n\r\n        // Get xArgo cost\r\n        xArgoCost = getxArgoCost(planetLevel, newLevel);\r\n\r\n        // Get gemstone requirements\r\n        gemstoneRequirements = getUpgradeRequirements(_tokenId, _levels);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total supply of AtlantisPlanets\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return currentSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade a planet by `_levels` levels\r\n     * @param _tokenId Token ID of planet\r\n     * @param _levels Number of levels to upgrade planet by\r\n     */\r\n    function upgradePlanet(uint256 _tokenId, uint8 _levels) external {\r\n        IERC20 xARGO = IERC20(addressRegistry.getXargo());\r\n        IAtlantisGemstones atlantisGemstones = IAtlantisGemstones(addressRegistry.getGemstones());\r\n        IStakingWithLock stakingWithLock = IStakingWithLock(addressRegistry.getStakingWithLock());\r\n\r\n        // Check if upgrader is owner of planet\r\n        if (ownerOf(_tokenId) != msg.sender) revert NotOwnerOfPlanet();\r\n        // Check if stage 4\r\n        if (stage != 4) revert InvalidStage(stage, 4);\r\n\r\n        AtlantisLib.Planet storage planet = planets[_tokenId];\r\n\r\n        uint8 orbit = uint8(planet.orbit);\r\n\r\n        if (planet.level + _levels > maxPlanetLevel) revert ExceededMaxLevel();\r\n\r\n        // Get xARGO requirements\r\n        uint256 xArgoCost = getxArgoCost(planet.level, planet.level + _levels);\r\n        // Get Stardust requirements\r\n        // Base cost scaling for stardust 0.25 = 25, need math properly\r\n        uint256 stardustCost = getStardustCost(planet.level, planet.level + _levels, orbit);\r\n\r\n        // Get gemstone requirements\r\n        uint16[4] memory gemstoneRequirements = getUpgradeRequirements(_tokenId, _levels);\r\n\r\n        uint16 planetTypeTierStep = 0;\r\n        uint16 step = 1;\r\n        // Increase planet level\r\n        planet.level += _levels;\r\n        while (step <= gemstoneTiers) {\r\n            uint256 toBurn = gemstoneRequirements[step - 1];\r\n            // Burn gemstones\r\n            if (toBurn > 0) {\r\n                atlantisGemstones.burn(msg.sender, uint256(uint256(planet.element) + 1 + planetTypeTierStep), toBurn);\r\n            }\r\n            step++;\r\n            planetTypeTierStep += 3;\r\n        }\r\n        // Transfer xARGO and Stardust to this contract\r\n        xARGO.transferFrom(msg.sender, address(this), xArgoCost);\r\n        if (stardustCost > 0) {\r\n            stakingWithLock.unstakeAndBurn(stardustCost);\r\n        }\r\n\r\n        emit PlanetUpgraded(_tokenId, planet.level);\r\n    }\r\n\r\n    // -------------------- MINT FUNCTIONS --------------------------\r\n\r\n    /**\r\n     * @dev Mint planet (Whitelist only)\r\n     * @param _mintAmount Amount of planets to mint\r\n     * @param nonce Unique Nonce\r\n     * @param signature Signature provided by the signerAddress\r\n     */\r\n    function whitelistMint(\r\n        uint256 _mintAmount,\r\n        bytes memory nonce,\r\n        bytes memory signature\r\n    ) external payable onlyEOA ensureAvailabilityFor(_mintAmount) {\r\n        // Check if user is whitelisted\r\n        if (!whitelistSigned(msg.sender, nonce, signature, whitelistPhase)) revert InvalidSignature();\r\n\r\n        // Check if whitelist sale is open\r\n        if (stage != 1) revert InvalidStage(stage, 1);\r\n        if (whitelistPhase == 1) {\r\n            // Check if enough ETH is sent\r\n            if (msg.value != _mintAmount * vipMintPrice) revert InsufficientCRO(msg.value, _mintAmount * vipMintPrice);\r\n\r\n            // Check if mints does not exceed max wallet allowance for public sale\r\n            if (vipMintCount[msg.sender] + _mintAmount > vipMintMaxPerWallet) revert ExceedMaxMintPerWallet();\r\n\r\n            vipMintCount[msg.sender] += _mintAmount;\r\n        }\r\n        if (whitelistPhase == 2) {\r\n            // Check if enough ETH is sent\r\n            if (msg.value != _mintAmount * whitelistMintPrice)\r\n                revert InsufficientCRO(msg.value, _mintAmount * whitelistMintPrice);\r\n\r\n            // Check if mints does not exceed max wallet allowance for public sale\r\n            if (whitelistMintCount[msg.sender] + _mintAmount > whitelistMintMaxPerWallet)\r\n                revert ExceedMaxMintPerWallet();\r\n\r\n            whitelistMintCount[msg.sender] += _mintAmount;\r\n        }\r\n        currentSupply += _mintAmount;\r\n\r\n        for (uint256 i; i < _mintAmount; i++) {\r\n            _mintPlanet();\r\n        }\r\n        emit PrivateMint(msg.sender, _mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Public Mint\r\n     * @param _mintAmount Amount that is minted\r\n     */\r\n    function mint(uint256 _mintAmount) external payable onlyEOA ensureAvailabilityFor(_mintAmount) {\r\n        // Check if public sale is open\r\n        if (stage != 2) revert InvalidStage(stage, 2);\r\n        publicMintCount[msg.sender] += _mintAmount;\r\n        currentSupply += _mintAmount;\r\n        // Check if enough ETH is sent\r\n        if (msg.value != _mintAmount * publicMintPrice)\r\n            revert InsufficientCRO(msg.value, _mintAmount * publicMintPrice);\r\n        // Check if mints does not exceed total max supply\r\n\r\n        for (uint256 i; i < _mintAmount; i++) {\r\n            _mintPlanet();\r\n        }\r\n        emit PublicMint(msg.sender, _mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint planet\r\n     * @dev Set initial planet level to 1 and random mint to msg.sender\r\n     */\r\n    function _mintPlanet() internal {\r\n        // Get next token Id\r\n        uint256 _tokenId = nextToken();\r\n        // Initialize planet\r\n        planets[_tokenId].level = 1;\r\n        // Mint planet\r\n        _safeMint(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Set whitelist phase\r\n     * @param _whitelistPhase Phase of whitelist\r\n     */\r\n    function setWhitelistPhase(uint256 _whitelistPhase) external onlyOwner {\r\n        whitelistPhase = _whitelistPhase;\r\n    }\r\n\r\n    // -------------------- ATLANTIS ADMIN FUNCTIONS ----------------------\r\n    /**\r\n     * @dev Set planet backgrounds\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _backgrounds Backgrounds of planets\r\n     */\r\n    function setPlanetBackgrounds(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.Background[] calldata _backgrounds\r\n    ) external onlyOwner {\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Loop through planet types and set planet type\r\n        for (uint256 i; i < _backgrounds.length; i++) {\r\n            planets[_tokenIds[i]].background = _backgrounds[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set planet orbit names\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _planetOrbitNames Orbit Names of planets\r\n     */\r\n\r\n    function setPlanetOrbitNames(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.OrbitName[] calldata _planetOrbitNames\r\n    ) external onlyOwner {\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Loop through planet types and set planet type\r\n        for (uint256 i; i < _planetOrbitNames.length; i++) {\r\n            planets[_tokenIds[i]].orbitName = _planetOrbitNames[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set planet orbit\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _planetOrbits Orbit of planets\r\n     */\r\n    function setPlanetOrbits(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.Orbit[] calldata _planetOrbits\r\n    ) external onlyOwner {\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Loop through planet types and set planet type\r\n        for (uint256 i; i < _planetOrbits.length; i++) {\r\n            planets[_tokenIds[i]].orbit = _planetOrbits[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set planet element\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _gemstoneTypes Element of planets\r\n     */\r\n    function setPlanetElements(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.Element[] calldata _gemstoneTypes\r\n    ) external onlyOwner {\r\n        // Require stage 3\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Set planet type\r\n        for (uint256 i; i < _tokenIds.length; i++) {\r\n            planets[_tokenIds[i]].element = _gemstoneTypes[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set level up gemstone costs\r\n     * @param _data gemstone cost packed in bytes\r\n     * @dev _data is packed as follows:\r\n     *     Cumulative cost for each gemstone tier for each planet type\r\n     *              | Common              | Uncommon            | Rare                | Epic\r\n     *              | T1   T2   T3   T4   | T1   T2   T3   T4   | T1   T2   T3   T4   | T1   T2   T3   T4\r\n     *     Level 1  | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 0000 0000 0000 0000\r\n     *     ...\r\n     *     Level 50 | 0122 00af 00e1 0113 | 015c 00d2 010e 014a | 0196 00f5 013b 0181 | 01d0 0118 0168 01b8\r\n     */\r\n    function setLevelUpGemstone(bytes calldata _data) external onlyOwner {\r\n        // Require stage 3\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        levelUpGemstone = _data;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ERC20 Tokens From this contract\r\n     * @param _tokenAddress Address of ERC20 token\r\n     * @param _amount Amount of ERC20 token to withdraw\r\n     */\r\n    function withdrawERC20(IERC20 _tokenAddress, uint256 _amount) external onlyOwner {\r\n        _tokenAddress.transfer(treasury, _amount);\r\n    }\r\n\r\n    // Setters for base costs\r\n    /**\r\n     * @dev Set xArgo And Stardust base costs\r\n     * @param _xArgoBaseCost xArgo base cost\r\n     * @param _stardustBaseCost Stardust base cost\r\n     */\r\n    function setBaseCosts(uint256 _xArgoBaseCost, uint256 _stardustBaseCost) external onlyOwner {\r\n        xArgoBaseCost = _xArgoBaseCost;\r\n        stardustBaseCost = _stardustBaseCost;\r\n    }\r\n\r\n    // Setters for scaling\r\n    /**\r\n     * @dev Set stardust scaling costs\r\n     * @param _stardustBaseCostScaling sd base cost scaling\r\n     * @param _stardustRarityCostScaling Stardust rarity cost scaling\r\n     */\r\n    function setScaling(uint256 _stardustBaseCostScaling, uint256 _stardustRarityCostScaling) external onlyOwner {\r\n        stardustBaseCostScaling = _stardustBaseCostScaling;\r\n        stardustRarityCostScaling = _stardustRarityCostScaling;\r\n    }\r\n\r\n    // -------------------- WHITELIST FUNCTION ----------------------\r\n\r\n    /**\r\n     * @dev Checks if the the signature is signed by a valid signer for whitelist\r\n     * @param sender Address of minter\r\n     * @param nonce Random bytes32 nonce\r\n     * @param signature Signature generated off-chain\r\n     */\r\n    function whitelistSigned(\r\n        address sender,\r\n        bytes memory nonce,\r\n        bytes memory signature,\r\n        uint256 _whitelistPhase\r\n    ) private view returns (bool) {\r\n        bytes32 _hash = keccak256(abi.encodePacked(sender, nonce, _whitelistPhase));\r\n        return whitelistSignerAddress == ECDSA.toEthSignedMessageHash(_hash).recover(signature);\r\n    }\r\n\r\n    // ------------------------- ADMIN FUNCTIONS ----------------------------\r\n\r\n    /**\r\n     * @dev Set stage of minting\r\n     */\r\n    function setStage(uint8 _newStage) public onlyOwner {\r\n        stage = _newStage;\r\n    }\r\n\r\n    /**\r\n     * @dev Toggle Reveal\r\n     */\r\n    function toggleReveal() public onlyOwner {\r\n        revealed = !revealed;\r\n    }\r\n\r\n    /**\r\n     * @dev Set signer address for whitelist mint\r\n     */\r\n    function setWhitelistSignerAddress(address signer) public onlyOwner {\r\n        whitelistSignerAddress = signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Set vip mint max per wallet\r\n     */\r\n    function setVipMaxMintPerWallet(uint256 amount) public onlyOwner {\r\n        vipMintMaxPerWallet = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set vip mint price\r\n     */\r\n    function setVipMintPrice(uint256 _vipMintPrice) public onlyOwner {\r\n        vipMintPrice = _vipMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Set whitelist mint max per wallet\r\n     */\r\n    function setWhitelistMaxMintPerWallet(uint256 amount) public onlyOwner {\r\n        whitelistMintMaxPerWallet = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set public mint price\r\n     */\r\n    function setPublicMintPrice(uint256 _publicMintPrice) public onlyOwner {\r\n        publicMintPrice = _publicMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Set whitelist mint price\r\n     */\r\n    function setWhitelistMintPrice(uint256 _whitelistMintPrice) public onlyOwner {\r\n        whitelistMintPrice = _whitelistMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all CRO from this account to the owner\r\n     */\r\n    function withdrawFund() external onlyOwner {\r\n        (bool success, ) = payable(treasury).call{ value: address(this).balance }(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the treasury address\r\n     */\r\n    function setTreasury(address _treasury) public onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns if given tokenId exists in AtlantisPlanets\r\n     */\r\n    function exists(uint256 tokenId) external view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    // ------------------------- TOKEN METADATA ----------------------------\r\n\r\n    /**\r\n     * @notice Get ImageURI\r\n     */\r\n    function getImageURI(\r\n        AtlantisLib.Background background,\r\n        AtlantisLib.Element element,\r\n        AtlantisLib.OrbitName orbitName,\r\n        AtlantisLib.Evolution evo\r\n    ) public view returns (string memory) {\r\n        if (!revealed) {\r\n            return unrevealedImageURI;\r\n        }\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    _baseURI(),\r\n                    Strings.toString(uint(background)),\r\n                    \"/\",\r\n                    Strings.toString(uint(element)),\r\n                    \"/\",\r\n                    Strings.toString(uint(evo)),\r\n                    \"/\",\r\n                    Strings.toString(uint(orbitName)),\r\n                    \".png\"\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns token metadata\r\n     * @dev Metadata is stored on-chain\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n        // Get Planet\r\n        AtlantisLib.Planet memory planet = planets[tokenId];\r\n\r\n        // Get Tier from Level\r\n        (AtlantisLib.Evolution evo, string memory evoString) = _getPlanetEvolution(planet.level);\r\n\r\n        // Name\r\n        string memory json = string(abi.encodePacked('{\"name\": \"', name(), \" #\", tokenId.toString(), '\",'));\r\n\r\n        // Description\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"description\": \"Welcome to the captivating realm of Atlantis, the game-verse and home of the legendary Argonauts. Planets are coveted lands that hold the key to your success in the game. Acquire planets, embark on exciting expeditions, and earn rewards that will supercharge your growth in Atlantis.\",'\r\n            )\r\n        );\r\n\r\n        // Attributes\r\n        if (!revealed) {\r\n            json = string(abi.encodePacked(json, '\"attributes\": [],'));\r\n        } else {\r\n            json = string(\r\n                abi.encodePacked(\r\n                    json,\r\n                    '\"attributes\": [{\"trait_type\": \"Element\", \"value\": \"',\r\n                    AtlantisLib._planetElementToString(planet.element),\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Background\", \"value\": \"',\r\n                    AtlantisLib._planetBackgroundToString(planet.background),\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Orbit Name\", \"value\": \"',\r\n                    AtlantisLib._planetOrbitTypeToString(planet.orbitName),\r\n                    '\"},'\r\n                )\r\n            );\r\n            json = string(\r\n                abi.encodePacked(\r\n                    json,\r\n                    '{\"trait_type\": \"Orbit\", \"value\": \"',\r\n                    AtlantisLib._planetOrbitToString(planet.orbit),\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Evolution\", \"value\": \"',\r\n                    evoString,\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Level\", \"value\": \"',\r\n                    Strings.toString(planet.level),\r\n                    '\"}],'\r\n                )\r\n            );\r\n        }\r\n\r\n        json = Base64.encode(\r\n            bytes(\r\n                string(\r\n                    abi.encodePacked(\r\n                        json,\r\n                        '\"image\": \"',\r\n                        getImageURI(planet.background, planet.element, planet.orbitName, evo),\r\n                        '\"}'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Address Registry\r\n     * @param _addressRegistry The address of the Address Registry\r\n     */\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) external onlyOwner {\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    function devMint(address _to, uint256 _mintAmount) public ensureAvailabilityFor(_mintAmount) onlyOwner {\r\n        currentSupply += _mintAmount;\r\n        for (uint256 i; i < _mintAmount; i++) {\r\n            // Get next token Id\r\n            uint256 _tokenId = nextToken();\r\n            // Initialize planet\r\n            planets[_tokenId].level = 1;\r\n            // Mint planet\r\n            _safeMint(tx.origin, _tokenId);\r\n        }\r\n\r\n        emit PublicMint(_to, _mintAmount);\r\n    }\r\n\r\n    function devEpicMint(address[12] calldata _auctionWinners) external onlyOwner {\r\n        require(_auctionWinners.length == 12, \"AtlantisPlanets: Invalid length\");\r\n        // Mint token Ids 1-12\r\n        for (uint256 i = 1; i < 13; i++) {\r\n            planets[i].level = 1;\r\n            _safeMint(_auctionWinners[i - 1], i);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisRacing.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\nimport \"./interface/IAtlantisSpaceships.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"./common/SetUtils.sol\";\r\nimport \"./interface/IAtlantisRacing.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/// @title Atlantis - Racing contract\r\n/// @dev Send your Spaceships to race for rewards. Add supported Nft collections to boost speed and earn a larger share of the rewards.\r\ncontract AtlantisRacing is IAtlantisRacing, Ownable, IERC721Receiver, ReentrancyGuard {\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using SetUtils for EnumerableSet.UintSet;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice Address registry contract\r\n    AtlantisAddressRegistry public addressRegistry;\r\n    /// @notice Unix timestamp of season end time\r\n    uint256 public seasonEndTime;\r\n    /// @notice Total reward per second\r\n    uint256 public totalRewardPerSecond;\r\n    /// @notice Precision factor for calculations\r\n    uint256 public immutable ACC_TOKEN_PRECISION;\r\n    /// @notice Unix timestamp of season start time\r\n    uint256 public seasonStartTime;\r\n    /// @notice Max limit of Nfts staked in all pools\r\n    uint256 public constant MAX_NFTS_STAKED = 15;\r\n    /// @notice Number of pools\r\n    uint256 internal constant amountOfPools = 4;\r\n    /// @notice Whether the season has started\r\n    bool public seasonStarted = false;\r\n    /// @notice Information of each respective pool (Global, Common, Uncommon, Rare/Epic)\r\n    mapping(uint256 => PoolInfo) public poolInfo;\r\n    /// @notice Information of each user that stakes spaceships\r\n    mapping(address => UserInfo) public userInfo;\r\n    /// @notice Cached speed\r\n    mapping(uint256 => uint256) public cachedSpeeds;\r\n    /// @notice Multiplier when a user stakes Nfts\r\n    uint256[6] public nftMultiplier;\r\n    /// @notice Mapping of (user) => (tokenId) => (bool) if token is staked\r\n    mapping(address => mapping(uint256 => bool)) public stakedSpaceships;\r\n    /// @notice Mapping of (user) => (PoolId) => address => (EnumerableSet of NFT tokenIds) Number of NFTs staked in each pool\r\n    mapping(address => mapping(uint8 => mapping(address => EnumerableSet.UintSet))) internal stakedNFTs;\r\n\r\n    /// @notice Mapping of address to boolean whitelisted status\r\n    mapping(address => bool) public whitelistedCollections;\r\n    /// @notice All tokenIds currently staked\r\n    mapping(address => mapping(uint8 => EnumerableSet.UintSet)) internal currentlyStakedSpaceshipIds;\r\n    /// @notice All tokenIds currently staked\r\n    mapping(address => EnumerableSet.UintSet) internal currentlyStakedIds;\r\n    /// @notice All tokenIds previously staked\r\n    mapping(address => EnumerableSet.UintSet) internal previouslyStakedIds;\r\n\r\n    /**\r\n     * @notice Constructor for Atlantis Racing\r\n     * @param _registry Address registry contract\r\n     * @param _totalRewardPerSecond Total stardust per second\r\n     * @param _seasonEndTime Season end time\r\n     */\r\n    constructor(\r\n        AtlantisAddressRegistry _registry,\r\n        uint256 _totalRewardPerSecond,\r\n        uint256 _seasonEndTime,\r\n        uint256[] memory _nftMultipliers\r\n    ) {\r\n        require(_nftMultipliers[0] == 10, \"Invalid nft multipliers\");\r\n        require(_seasonEndTime > block.timestamp, \"Invalid season end time\");\r\n        for (uint256 i; i < _nftMultipliers.length; i++) {\r\n            nftMultiplier[i] = _nftMultipliers[i];\r\n        }\r\n        // Set total stardust per second\r\n        totalRewardPerSecond = _totalRewardPerSecond;\r\n\r\n        addressRegistry = _registry;\r\n        // Global race pool, 15% of total\r\n        poolInfo[0].poolType = 0;\r\n        poolInfo[0].rewardPerSecond = (_totalRewardPerSecond * 225) / 1000;\r\n        poolInfo[0].stardustWeightage = 80;\r\n        poolInfo[0].goldWeightage = 20;\r\n        poolInfo[0].lastRewardTime = block.timestamp;\r\n        poolInfo[0].accStardustPerPoint = 0;\r\n        poolInfo[0].totalPoints = 0;\r\n        poolInfo[0].totalCount = 0;\r\n\r\n        // Common race pool, 50% of total\r\n        poolInfo[1].poolType = 1;\r\n        poolInfo[1].rewardPerSecond = (_totalRewardPerSecond * 45) / 100;\r\n        poolInfo[1].stardustWeightage = 80;\r\n        poolInfo[1].goldWeightage = 20;\r\n        poolInfo[1].lastRewardTime = block.timestamp;\r\n        poolInfo[1].accStardustPerPoint = 0;\r\n        poolInfo[1].totalPoints = 0;\r\n        poolInfo[1].totalCount = 0;\r\n\r\n        // Uncommon race pool, 30% of total\r\n        poolInfo[2].poolType = 2;\r\n        poolInfo[2].rewardPerSecond = (_totalRewardPerSecond * 25) / 100;\r\n        poolInfo[2].stardustWeightage = 80;\r\n        poolInfo[2].goldWeightage = 20;\r\n        poolInfo[2].lastRewardTime = block.timestamp;\r\n        poolInfo[2].accStardustPerPoint = 0;\r\n        poolInfo[2].totalPoints = 0;\r\n        poolInfo[2].totalCount = 0;\r\n\r\n        // Rare + Epic race pool, 5% of total\r\n        poolInfo[3].poolType = 3;\r\n        poolInfo[3].rewardPerSecond = (_totalRewardPerSecond * 75) / 1000;\r\n        poolInfo[3].stardustWeightage = 80;\r\n        poolInfo[3].goldWeightage = 20;\r\n        poolInfo[3].lastRewardTime = block.timestamp;\r\n        poolInfo[3].accStardustPerPoint = 0;\r\n        poolInfo[3].totalPoints = 0;\r\n        poolInfo[3].totalCount = 0;\r\n\r\n        // Scratch generation cut off date\r\n        seasonEndTime = _seasonEndTime;\r\n        ACC_TOKEN_PRECISION = 10 ** 18;\r\n\r\n        // Get argonauts from registry\r\n        address argonauts = addressRegistry.getArgonauts();\r\n        // Set whitelisted collections\r\n        whitelistedCollections[argonauts] = true;\r\n    }\r\n\r\n    /**\r\n        onlyOwner functions >:]\r\n    */\r\n\r\n    /**\r\n     * @notice Setter for season end time\r\n     * @param _time season end time in unix timestamp\r\n     */\r\n    function setSeasonEndTime(uint256 _time) public onlyOwner {\r\n        require(_time > block.timestamp, \"Season end time must be in the future\");\r\n        seasonEndTime = _time;\r\n        _massUpdatePools();\r\n        emit SeasonEndTimeChanged(_time);\r\n    }\r\n\r\n    /**\r\n     * @notice Starts the season\r\n     */\r\n    function startSeason() external onlyOwner {\r\n        require(!seasonStarted, \"Season already started\");\r\n        require(block.timestamp < seasonEndTime, \"Season already ended\");\r\n        uint256 currentTime = block.timestamp;\r\n        seasonStartTime = currentTime;\r\n        seasonStarted = true;\r\n        // Update last reward time\r\n        for (uint256 i; i < amountOfPools; i++) {\r\n            poolInfo[i].lastRewardTime = currentTime;\r\n        }\r\n        emit StartSeason(currentTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Ends the season early\r\n     */\r\n    function endSeason() external onlyOwner {\r\n        require(seasonStarted, \"Season not started\");\r\n        require(block.timestamp < seasonEndTime, \"Season already ended\");\r\n        uint256 currentTime = block.timestamp;\r\n        seasonEndTime = currentTime;\r\n        _massUpdatePools();\r\n        emit EndSeason(currentTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Address Registry\r\n     * @param _addressRegistry The address of the Address Registry\r\n     */\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) external onlyOwner {\r\n        addressRegistry = _addressRegistry;\r\n        emit AddressRegistryUpdated(address(_addressRegistry));\r\n    }\r\n\r\n    /**\r\n     * @notice Used to retrieve any stardust on the contract\r\n     */\r\n    function retrieveStardust() external onlyOwner {\r\n        IERC20 stardust = IERC20(addressRegistry.getStardust());\r\n        uint256 total = stardust.balanceOf(address(this));\r\n        stardust.safeTransfer(msg.sender, total);\r\n        emit EmergencyWithdrawStardust(total);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to retrieve any gold on the contract\r\n     */\r\n    function retrieveGold() external onlyOwner {\r\n        IERC20 gold = IERC20(addressRegistry.getGold());\r\n        uint256 total = gold.balanceOf(address(this));\r\n        gold.safeTransfer(msg.sender, total);\r\n        emit EmergencyWithdrawGold(total);\r\n    }\r\n\r\n    /**\r\n     * @notice Stake spaceships to earn stardust + gold\r\n     * @param _ids The ids of the spaceships to stake\r\n     */\r\n    function stakeSpaceships(uint256[] memory _ids) external nonReentrant {\r\n        require(block.timestamp < seasonEndTime, \"Season already ended\");\r\n        IAtlantisSpaceships spaceships = IAtlantisSpaceships(addressRegistry.getSpaceships());\r\n        // Harvest any pending rewards\r\n        if (seasonStarted) {\r\n            _massUpdatePools();\r\n            for (uint8 i; i < amountOfPools; i++) {\r\n                _harvest(i, msg.sender);\r\n            }\r\n        }\r\n        for (uint256 i; i < _ids.length; i++) {\r\n            AtlantisLib.Rarity _type = spaceships.getRarity(_ids[i]);\r\n            // Convert spaceship type to uint256\r\n            uint8 _spaceshipRarity = uint8(_type) + 1;\r\n            // If spaceship type is 4, it is an epic and in same pool as rare, so we set it to 3\r\n            if (_spaceshipRarity == 4) {\r\n                _spaceshipRarity = 3;\r\n            }\r\n            uint256 _speed = spaceships.getSpeed(_ids[i]) * 10;\r\n            cachedSpeeds[_ids[i]] = _speed;\r\n            require(_speed > 0, \"Spaceship speed cannot be 0\");\r\n            currentlyStakedSpaceshipIds[msg.sender][_spaceshipRarity].add(_ids[i]);\r\n            //Take Token and Transfer to Contract for Holding\r\n            IERC721(address(spaceships)).safeTransferFrom(msg.sender, address(this), _ids[i]);\r\n            // Increase to free pool and increase to protected pool\r\n            if (userInfo[msg.sender].boostingNftsPoolCount[_spaceshipRarity] == 0) {\r\n                _increasePoolAndUserStats(_speed, 0, msg.sender, false);\r\n                _increasePoolAndUserStats(_speed, _spaceshipRarity, msg.sender, false);\r\n            } else {\r\n                uint256 _multiplier = nftMultiplier[userInfo[msg.sender].boostingNftsPoolCount[_spaceshipRarity]];\r\n                _increasePoolAndUserStats((_speed * _multiplier) / 10, 0, msg.sender, false);\r\n                _increasePoolAndUserStats((_speed * _multiplier) / 10, _spaceshipRarity, msg.sender, false);\r\n            }\r\n            stakedSpaceships[msg.sender][_ids[i]] = true;\r\n            userInfo[msg.sender].spaceshipsStaked++;\r\n            emit Stake(msg.sender, _ids[i], _speed);\r\n        }\r\n        _updateRewardDebts(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake spaceships\r\n     * @param _ids The ids of the spaceships to unstake\r\n     */\r\n    function unstakeSpaceships(uint256[] calldata _ids) external nonReentrant {\r\n        IAtlantisSpaceships spaceships = IAtlantisSpaceships(addressRegistry.getSpaceships());\r\n\r\n        require(userInfo[msg.sender].spaceshipsStaked >= _ids.length, \"Not enough spaceships staked\");\r\n        // Harvest any pending rewards\r\n        if (seasonStarted) {\r\n            _massUpdatePools();\r\n            for (uint8 i; i < amountOfPools; i++) {\r\n                _harvest(i, msg.sender);\r\n            }\r\n        }\r\n\r\n        for (uint256 i; i < _ids.length; i++) {\r\n            // if id found in stakedSpaceships, unstake it\r\n            uint256 _id = _ids[i];\r\n            require(stakedSpaceships[msg.sender][_id], \"Spaceship not staked\");\r\n            uint8 _spaceshipRarity = uint8(spaceships.getRarity(_id)) + 1;\r\n            uint256 _speed = cachedSpeeds[_id];\r\n            if (_spaceshipRarity == 4) {\r\n                _spaceshipRarity = 3;\r\n            }\r\n\r\n            // decrease for free pool and protected pool\r\n            if (userInfo[msg.sender].boostingNftsPoolCount[_spaceshipRarity] == 0) {\r\n                _decreasePoolAndUserStats(_speed, 0, msg.sender, false);\r\n                _decreasePoolAndUserStats(_speed, _spaceshipRarity, msg.sender, false);\r\n            } else {\r\n                uint256 _multiplier = nftMultiplier[userInfo[msg.sender].boostingNftsPoolCount[_spaceshipRarity]];\r\n                _decreasePoolAndUserStats((_speed * _multiplier) / 10, 0, msg.sender, false);\r\n                _decreasePoolAndUserStats((_speed * _multiplier) / 10, _spaceshipRarity, msg.sender, false);\r\n            }\r\n\r\n            stakedSpaceships[msg.sender][_id] = false;\r\n            userInfo[msg.sender].spaceshipsStaked--;\r\n            currentlyStakedSpaceshipIds[msg.sender][_spaceshipRarity].remove(_ids[i]);\r\n            // transfer spaceship back to user\r\n            IERC721(address(spaceships)).safeTransferFrom(address(this), msg.sender, _id);\r\n            emit Unstaked(msg.sender, _id);\r\n        }\r\n        _updateRewardDebts(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes given nfts and uses them to boost the given pool.\r\n     * @param _pid  Id of the pool to boost\r\n     * @param _collectionAddresses Array of collection addresses\r\n     * @param _nfts Array of token ids to stake\r\n     */\r\n    function stakeNfts(\r\n        uint8 _pid,\r\n        address[] calldata _collectionAddresses,\r\n        uint256[] calldata _nfts\r\n    ) external nonReentrant {\r\n        require(block.timestamp < seasonEndTime, \"Season already ended\");\r\n        // Require pid to be 1-3 only\r\n        require(_pid >= 1 && _pid <= 3, \"Invalid pool id\");\r\n        require(_nfts.length == _collectionAddresses.length, \"NFTs and collection addresses must be same length\");\r\n        if (seasonStarted) {\r\n            _massUpdatePools();\r\n            for (uint8 i; i < amountOfPools; i++) {\r\n                _harvest(i, msg.sender);\r\n            }\r\n        }\r\n        // Get userInfo\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        require(user.boostingNftsCount + _nfts.length <= MAX_NFTS_STAKED, \"Too many NFTs staked\");\r\n        for (uint256 i; i < _collectionAddresses.length; i++) {\r\n            // Check whitelisted nfts\r\n            require(whitelistedCollections[_collectionAddresses[i]], \"Collection not whitelisted\");\r\n        }\r\n        uint256 _initialNftsCount = user.boostingNftsPoolCount[_pid];\r\n        for (uint256 i; i < _collectionAddresses.length; i++) {\r\n            user.boostingNfts[_pid][_collectionAddresses[i]].push(_nfts[i]);\r\n\r\n            // print currentNfts length\r\n            user.boostingNftsPoolCount[_pid]++;\r\n            user.boostingNftsCount++;\r\n            _stake(_pid, _collectionAddresses[i], _nfts[i]);\r\n        }\r\n        uint256 _currentSpeed = user.totalSpeeds[_pid];\r\n        uint256 _initialMultiplier = nftMultiplier[_initialNftsCount];\r\n        uint256 _multiplier = nftMultiplier[userInfo[msg.sender].boostingNftsPoolCount[_pid]];\r\n        _decreasePoolAndUserStats(_currentSpeed - (_currentSpeed * 10) / _initialMultiplier, 0, msg.sender, true);\r\n        _decreasePoolAndUserStats(_currentSpeed - (_currentSpeed * 10) / _initialMultiplier, _pid, msg.sender, true);\r\n        _currentSpeed = userInfo[msg.sender].totalSpeeds[_pid];\r\n        _increasePoolAndUserStats((_currentSpeed * _multiplier) / 10 - _currentSpeed, 0, msg.sender, true);\r\n        _increasePoolAndUserStats((_currentSpeed * _multiplier) / 10 - _currentSpeed, _pid, msg.sender, true);\r\n        _updateRewardDebts(msg.sender);\r\n        emit StakeNfts(_pid, msg.sender, _nfts.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes nfts without unboosting the pool\r\n     * @param _pid  Id of the farm to unstake the nfts from\r\n     * @param _collectionAddresses Array of nft contract addresses\r\n     * @param _nfts Array of structs containing the nft contract and token id to unstake\r\n     */\r\n    function unstakeNfts(\r\n        uint8 _pid,\r\n        address[] calldata _collectionAddresses,\r\n        uint256[] calldata _nfts\r\n    ) external nonReentrant {\r\n        require(_nfts.length == _collectionAddresses.length, \"NFTs and collection addresses must be same length\");\r\n        require(_pid >= 1 && _pid <= 3, \"Invalid pool id\");\r\n        if (seasonStarted) {\r\n            _massUpdatePools();\r\n            for (uint8 i; i < amountOfPools; i++) {\r\n                _harvest(i, msg.sender);\r\n            }\r\n        }\r\n        uint256 _initialNftsCount = userInfo[msg.sender].boostingNftsPoolCount[_pid];\r\n        for (uint256 i; i < _collectionAddresses.length; i++) {\r\n            _removeNftFromPool(_pid, _collectionAddresses[i], _nfts[i]);\r\n            _unstake(_pid, _collectionAddresses[i], _nfts[i]);\r\n        }\r\n        uint256 _currentSpeed = userInfo[msg.sender].totalSpeeds[_pid];\r\n        uint256 _initialMultiplier = nftMultiplier[_initialNftsCount];\r\n        uint256 _multiplier = nftMultiplier[userInfo[msg.sender].boostingNftsPoolCount[_pid]];\r\n        _decreasePoolAndUserStats(_currentSpeed - (_currentSpeed * 10) / _initialMultiplier, 0, msg.sender, true);\r\n        _decreasePoolAndUserStats(_currentSpeed - (_currentSpeed * 10) / _initialMultiplier, _pid, msg.sender, true);\r\n        _currentSpeed = userInfo[msg.sender].totalSpeeds[_pid];\r\n        _increasePoolAndUserStats((_currentSpeed * _multiplier) / 10 - _currentSpeed, 0, msg.sender, true);\r\n        _increasePoolAndUserStats((_currentSpeed * _multiplier) / 10 - _currentSpeed, _pid, msg.sender, true);\r\n        _updateRewardDebts(msg.sender);\r\n        emit UnstakeNfts(_pid, msg.sender, _nfts.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Get tokenIds of a given collection currently staked by specific user\r\n     * @param _pid  Pool id\r\n     * @param _collectionAddress  Address of the collection contract\r\n     * @param _staker  User for whom to retrieve staked token ids\r\n     * @return Array of tokenIds which are currently staked by the user for the given token contract\r\n     */\r\n    function getCurrentlyStakedTokenIds(\r\n        uint8 _pid,\r\n        address _collectionAddress,\r\n        address _staker\r\n    ) external view returns (uint256[] memory) {\r\n        return stakedNFTs[_staker][_pid][_collectionAddress].toArray();\r\n    }\r\n\r\n    /**\r\n     * @notice Get tokenIds of a given collection currently staked by any user\r\n     * @param _collectionAddress  Address of the collection contract\r\n     * @return Array of tokenIds which are currently staked for the given token contract\r\n     */\r\n    function getCurrentlyStakedTokenIds(address _collectionAddress) external view returns (uint256[] memory) {\r\n        return currentlyStakedIds[_collectionAddress].toArray();\r\n    }\r\n\r\n    /**\r\n     * @notice Get tokenIds of a given collection that have ever been staked by any user\r\n     * @param _collectionAddress  Address of the collection contract\r\n     * @return Array of tokenIds which have ever been staked for the given token contract\r\n     */\r\n    function getPreviouslyStakedTokenIds(address _collectionAddress) external view returns (uint256[] memory) {\r\n        return previouslyStakedIds[_collectionAddress].toArray();\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest all rewards for msg.sender\r\n     */\r\n    function getRewards() external nonReentrant {\r\n        _massUpdatePools();\r\n        for (uint8 i; i < amountOfPools; i++) {\r\n            _harvest(i, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest rewards for a certain poolId for msg.sender\r\n     * @param _pid Pool id\r\n     */\r\n    function getReward(uint8 _pid) external nonReentrant {\r\n        _massUpdatePools();\r\n        _harvest(_pid, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards for a certain poolId and user\r\n     * @param _user  User address\r\n     * @param _pid Pool id\r\n     * @return rewards  Array of rewards [stardust, gold]\r\n     */\r\n    function viewRewards(address _user, uint8 _pid) external view returns (uint256[2] memory) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256[2] memory rewards;\r\n        uint256 currentTime = block.timestamp;\r\n        if (currentTime >= seasonEndTime) {\r\n            currentTime = seasonEndTime;\r\n        }\r\n        PoolInfo memory pool = poolInfo[_pid];\r\n        if (!seasonStarted || pool.totalPoints == 0) {\r\n            rewards[0] = 0;\r\n            rewards[1] = 0;\r\n        } else {\r\n            uint256 accStardustPerPoint = pool.accStardustPerPoint;\r\n            uint256 multiplier = currentTime - pool.lastRewardTime;\r\n            uint256 total = multiplier * pool.rewardPerSecond;\r\n            accStardustPerPoint += ((total * ACC_TOKEN_PRECISION) / pool.totalPoints);\r\n            uint256 accStardust = (userInfo[_user].totalSpeeds[_pid] * accStardustPerPoint) / ACC_TOKEN_PRECISION;\r\n            uint256 pending = accStardust - user.rewardDebts[_pid];\r\n            uint256 stardustAmount = (pending * poolInfo[_pid].stardustWeightage) / 100;\r\n            uint256 goldAmount = pending - stardustAmount;\r\n            rewards[0] = stardustAmount;\r\n            rewards[1] = goldAmount;\r\n        }\r\n\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice View the total speeds of a user across all pools\r\n     * @param _user  User address\r\n     * @return totalSpeeds  Array of total speeds [Global, Common, Uncommon, Rare/Epic]\r\n     */\r\n    function viewTotalSpeeds(address _user) external view returns (uint256[4] memory) {\r\n        // Get userinfo memory\r\n        UserInfo storage user = userInfo[_user];\r\n        return user.totalSpeeds;\r\n    }\r\n\r\n    /**\r\n     * @notice View number of spaceships staked by user\r\n     * @param _user  User address\r\n     * @return spaceshipsStaked  Number of spaceships staked\r\n     */\r\n    function viewSpaceshipsStaked(address _user) external view returns (uint256) {\r\n        // Get userinfo memory\r\n        UserInfo storage user = userInfo[_user];\r\n        return user.spaceshipsStaked;\r\n    }\r\n\r\n    /**\r\n     * @notice View number of NFTs staked by user\r\n     * @param _pid Pool id\r\n     * @param _collectionAddress  Address of the collection contract\r\n     * @param _user  User address\r\n     * @return boostingNfts Array of nft ids\r\n     */\r\n    function viewBoostingNfts(\r\n        uint8 _pid,\r\n        address _collectionAddress,\r\n        address _user\r\n    ) external view returns (uint256[] memory) {\r\n        // Get userinfo storage\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256[] storage boostingNfts = user.boostingNfts[_pid][_collectionAddress];\r\n        uint256[] memory result = new uint256[](boostingNfts.length);\r\n        // Copy boosting nfts to memory\r\n        for (uint256 i = 0; i < boostingNfts.length; i++) {\r\n            result[i] = boostingNfts[i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice View boosting nfts count in a specific pool\r\n     * @param _user  User address\r\n     * @param _pid Pool id\r\n     * @return number of boosting nfts in a specific pool\r\n     */\r\n    function viewBoostingNftsPoolCount(address _user, uint8 _pid) external view returns (uint256) {\r\n        // Get userinfo memory\r\n        UserInfo storage user = userInfo[_user];\r\n        return user.boostingNftsPoolCount[_pid];\r\n    }\r\n\r\n    /**\r\n     * @notice View currently staked spaceship ids\r\n     * @param _user  User address\r\n     * @param _pid Pool id\r\n     * @return spaceshipIds Array of spaceship ids\r\n     */\r\n    function viewCurrentlyStakedSpaceships(address _user, uint8 _pid) external view returns (uint256[] memory) {\r\n        return currentlyStakedSpaceshipIds[_user][_pid].toArray();\r\n    }\r\n\r\n    /**\r\n     * @notice View pool info\r\n     * @param _pid Pool id\r\n     */\r\n    function viewPoolInfo(uint256 _pid) external view returns (PoolInfo memory) {\r\n        return poolInfo[_pid];\r\n    }\r\n\r\n    /**\r\n     * @notice Updates pool's core values\r\n     * @param _pid The pool id\r\n     */\r\n    function _updatePool(uint256 _pid) internal {\r\n        uint256 currentTime = block.timestamp;\r\n        // Check if season is over\r\n        if (seasonEndTime <= currentTime) {\r\n            currentTime = seasonEndTime;\r\n        }\r\n        // Update based on pool type\r\n        if (poolInfo[_pid].totalPoints > 0) {\r\n            uint256 stardustReward = (currentTime - poolInfo[_pid].lastRewardTime) * poolInfo[_pid].rewardPerSecond;\r\n            poolInfo[_pid].accStardustPerPoint += ((stardustReward * ACC_TOKEN_PRECISION) / poolInfo[_pid].totalPoints);\r\n        }\r\n\r\n        poolInfo[_pid].lastRewardTime = currentTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates all pools core values\r\n     */\r\n    function _massUpdatePools() internal {\r\n        for (uint256 i; i < amountOfPools; i++) {\r\n            _updatePool(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward debts of user\r\n     * @param _user User address\r\n     */\r\n    function _updateRewardDebts(address _user) internal {\r\n        for (uint256 i; i < amountOfPools; i++) {\r\n            userInfo[_user].rewardDebts[i] =\r\n                (userInfo[_user].totalSpeeds[i] * poolInfo[i].accStardustPerPoint) /\r\n                ACC_TOKEN_PRECISION;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for staking nfts\r\n     * @param _pid The pool id to stake Nfts in\r\n     * @param _collectionAddress The address of the collection the nft is from\r\n     * @param _tokenId The id of the nft to stake\r\n     */\r\n    function _stake(uint8 _pid, address _collectionAddress, uint256 _tokenId) internal virtual {\r\n        require(!stakedNFTs[msg.sender][_pid][_collectionAddress].contains(_tokenId), \"NFT already staked\");\r\n        // Transfer ERC721 from user\r\n        IERC721(_collectionAddress).safeTransferFrom(msg.sender, address(this), _tokenId);\r\n\r\n        // Update stakers specific data\r\n        stakedNFTs[msg.sender][_pid][_collectionAddress].add(_tokenId);\r\n        // Update token specific data\r\n        currentlyStakedIds[_collectionAddress].add(_tokenId);\r\n        previouslyStakedIds[_collectionAddress].add(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for unstaking Nfts\r\n     * @param _pid The pool id to unstake Nfts from\r\n     * @param _collectionAddress The address of the collection the Nft is from\r\n     * @param _tokenId The id of the Nft to unstake\r\n     */\r\n    function _unstake(uint8 _pid, address _collectionAddress, uint256 _tokenId) internal virtual {\r\n        require(_isTokenStaked(_pid, msg.sender, _collectionAddress, _tokenId), \"NFT not staked\");\r\n        // Update tokens currently staked\r\n        stakedNFTs[msg.sender][_pid][_collectionAddress].remove(_tokenId);\r\n        currentlyStakedIds[_collectionAddress].remove(_tokenId);\r\n        // Transfer ERC721 from user\r\n        IERC721(_collectionAddress).safeTransferFrom(address(this), msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether a specific token is currently staked by a specific user\r\n     * @param _pid  Pool id\r\n     * @param _staker  User for whom to retrieve staked token ids\r\n     * @param _collectionAddress Address of the collection the token is from\r\n     * @param _tokenId TokenId to check for staking\r\n     * @return bool True if token is staked by user, false otherwise\r\n     */\r\n    function _isTokenStaked(\r\n        uint8 _pid,\r\n        address _staker,\r\n        address _collectionAddress,\r\n        uint256 _tokenId\r\n    ) internal view returns (bool) {\r\n        return stakedNFTs[_staker][_pid][_collectionAddress].contains(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Increase pool and user stats\r\n     * @param _speed Speed to increase\r\n     * @param _pid Pool id\r\n     * @param _user User address\r\n     * @param _nft Is boosting nft or not\r\n     */\r\n    function _increasePoolAndUserStats(uint256 _speed, uint8 _pid, address _user, bool _nft) internal {\r\n        poolInfo[_pid].totalPoints += _speed;\r\n        if (_speed > 0 && !_nft) {\r\n            poolInfo[_pid].totalCount++;\r\n        }\r\n        userInfo[_user].totalSpeeds[_pid] += _speed;\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease pool and user stats\r\n     * @param _speed Speed to decrease\r\n     * @param _pid Pool id\r\n     * @param _user User address\r\n     * @param _nft Is boosting nft or not\r\n     */\r\n    function _decreasePoolAndUserStats(uint256 _speed, uint8 _pid, address _user, bool _nft) internal {\r\n        poolInfo[_pid].totalPoints -= _speed;\r\n        if (_speed > 0 && !_nft) {\r\n            poolInfo[_pid].totalCount--;\r\n        }\r\n        userInfo[_user].totalSpeeds[_pid] -= _speed;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for harvesting rewards\r\n     * @param _pid Pool id\r\n     * @param _user User address\r\n     * @return pending Pending rewards\r\n     */\r\n    function _harvest(uint8 _pid, address _user) internal returns (uint256 pending) {\r\n        IERC20 gold = IERC20(addressRegistry.getGold());\r\n        IERC20 stardust = IERC20(addressRegistry.getStardust());\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 oldShares = userInfo[_user].totalSpeeds[_pid];\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (oldShares > 0) {\r\n            uint256 accStardust = (oldShares * pool.accStardustPerPoint) / ACC_TOKEN_PRECISION;\r\n            pending = accStardust - user.rewardDebts[_pid];\r\n        }\r\n        if (pending > 0) {\r\n            user.rewardDebts[_pid] = (oldShares * pool.accStardustPerPoint) / ACC_TOKEN_PRECISION;\r\n        }\r\n        // Split total into 80% stardust, 20% gold\r\n        stardust.safeTransfer(_user, (pending * poolInfo[_pid].stardustWeightage) / 100);\r\n        gold.safeTransfer(_user, (pending * poolInfo[_pid].goldWeightage) / 100);\r\n        emit Payout(\r\n            _pid,\r\n            _user,\r\n            (pending * poolInfo[_pid].goldWeightage) / 100,\r\n            (pending * poolInfo[_pid].stardustWeightage) / 100\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Remove nfts from pool\r\n     * @param _pid  Pool id\r\n     * @param _collectionAddress Nft collection address\r\n     * @param _tokenId  Nft id\r\n     */\r\n    function _removeNftFromPool(uint8 _pid, address _collectionAddress, uint256 _tokenId) internal {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256[] storage currentNfts = user.boostingNfts[_pid][_collectionAddress];\r\n        for (uint256 i; i < currentNfts.length; i++) {\r\n            uint256 currentNft = currentNfts[i];\r\n            if (currentNft == _tokenId) {\r\n                currentNfts[i] = currentNfts[currentNfts.length - 1];\r\n                currentNfts.pop();\r\n                user.boostingNftsPoolCount[_pid]--;\r\n                user.boostingNftsCount--;\r\n                return;\r\n            }\r\n        }\r\n        revert(\"Nft not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Set the whitelisted status of a collection\r\n     * @param _collectionAddresses The address of the collection\r\n     * @param _status The whitelisted status of the collection\r\n     * @dev Only whitelisted collections can be staked\r\n     */\r\n    function setWhitelistedCollections(address[] memory _collectionAddresses, bool _status) external onlyOwner {\r\n        for (uint256 i; i < _collectionAddresses.length; i++) {\r\n            whitelistedCollections[_collectionAddresses[i]] = _status;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice For receiving ERC721 tokens\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/AtlantisSpaceships.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"./interface/IAtlantisSpaceships.sol\";\r\nimport \"./interface/IAtlantisEquipments.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\nimport \"./common/Base64.sol\";\r\n\r\n/// @title Atlantis Spaceships Mint Contract\r\n/// @dev Race your spaceships on the racing contract! Equip equipments to boost speed!\r\ncontract AtlantisSpaceships is ERC721, Ownable, IAtlantisSpaceships, IERC1155Receiver, ReentrancyGuard {\r\n    using Strings for uint256;\r\n\r\n    AtlantisAddressRegistry public addressRegistry;\r\n\r\n    string public baseURI;\r\n\r\n    uint256 public currentSupply;\r\n    uint256 public currentIndex = 1;\r\n    // Mapping of spaceshipIDs to spaceships\r\n    mapping(uint256 => Spaceship) public spaceships;\r\n\r\n    // Events\r\n    event EquipmentModified(\r\n        uint256 indexed spaceshipId,\r\n        string fireEquipmentString,\r\n        string lightningEquipmentString,\r\n        string steelEquipmentString,\r\n        uint256 speed\r\n    );\r\n    event PublicMint(address indexed to);\r\n    event AddressRegistryUpdated(address indexed newAddressRegistry);\r\n    event BaseURIUpdated(string indexed newBaseURI);\r\n    event SpaceshipRaritySet(uint256 indexed spaceshipId, string rarityString, uint256 speed);\r\n\r\n    constructor(\r\n        address _owner,\r\n        string memory __baseURI,\r\n        AtlantisAddressRegistry _addressRegistry\r\n    ) ERC721(\"Atlantis Spaceships\", \"SPACESHIPS\") {\r\n        setBaseURI(__baseURI);\r\n        transferOwnership(_owner);\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    // -------------------- ATLANTIS FUNCTIONS --------------------------\r\n    /** Token Ids of equipments\r\n     * 1 2 3 Fire Lightning Steel Equipment Level 1\r\n     * 4 5 6 Fire Lightning Steel Equipment Level 2\r\n     * 7 8 9 Fire Lightning Steel Equipment Level 3\r\n     * 10 11 12 Fire Lightning Steel Equipment Level 4\r\n     * 13 14 15 Fire Lightning Steel Equipment Level 5\r\n     * 16 17 18 Fire Lightning Steel Equipment Level 6\r\n     * 19 20 21 Fire Lightning Steel Equipment Level 7\r\n     * 22 23 24 Fire Lightning Steel Equipment Level 8\r\n     * 25 26 27 Fire Lightning Steel Equipment Level 9\r\n     * 28 29 30 Fire Lightning Steel Equipment Level 10\r\n     */\r\n\r\n    function modifyEquipment(\r\n        uint256 _spaceshipId,\r\n        uint256 _fireEquipmentId,\r\n        uint256 _lightningEquipmentId,\r\n        uint256 _steelEquipmentId\r\n    ) external nonReentrant {\r\n        // Check if the spaceship is owned by the caller if not throw notOwner error\r\n        if (ownerOf(_spaceshipId) != msg.sender) {\r\n            revert NotOwner();\r\n        }\r\n        IAtlantisEquipments atlantisEquipments = IAtlantisEquipments(addressRegistry.getEquipments());\r\n        // Get spaceship\r\n        Spaceship storage spaceship = spaceships[_spaceshipId];\r\n\r\n        // Set spaceship Equipments to new Equipments\r\n        _equipHelper(spaceship.fireEquipmentId, _fireEquipmentId, 1);\r\n        _equipHelper(spaceship.lightningEquipmentId, _lightningEquipmentId, 2);\r\n        _equipHelper(spaceship.steelEquipmentId, _steelEquipmentId, 0);\r\n\r\n        spaceship.fireEquipmentId = _fireEquipmentId;\r\n        spaceship.lightningEquipmentId = _lightningEquipmentId;\r\n        spaceship.steelEquipmentId = _steelEquipmentId;\r\n\r\n        emit EquipmentModified(\r\n            _spaceshipId,\r\n            atlantisEquipments.getLevel(_fireEquipmentId) != 0\r\n                ? uint256(atlantisEquipments.getLevel(_fireEquipmentId)).toString()\r\n                : \"Unequipped\",\r\n            atlantisEquipments.getLevel(_lightningEquipmentId) != 0\r\n                ? uint256(atlantisEquipments.getLevel(_lightningEquipmentId)).toString()\r\n                : \"Unequipped\",\r\n            atlantisEquipments.getLevel(_steelEquipmentId) != 0\r\n                ? uint256(atlantisEquipments.getLevel(_steelEquipmentId)).toString()\r\n                : \"Unequipped\",\r\n            getSpeed(_spaceshipId)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to handle equipping\r\n     * @param _oldId Token ID of old equipment\r\n     * @param _newId Token ID of new equipment\r\n     * @param _element Element of equipment\r\n     */\r\n    function _equipHelper(uint256 _oldId, uint256 _newId, uint8 _element) internal {\r\n        IAtlantisEquipments atlantisEquipments = IAtlantisEquipments(addressRegistry.getEquipments());\r\n\r\n        // Do nothing if oldId and newId are the same\r\n        if (_oldId == _newId) {\r\n            return;\r\n        }\r\n        // Check that newId is the correct element if not throw wrongelement\r\n        if (_newId != 0 && atlantisEquipments.getElement(_newId) != _element) {\r\n            revert WrongElement();\r\n        }\r\n        // Check if newId is not zero\r\n        if (_newId != 0) {\r\n            // Transfer newId to contract\r\n            IERC1155(address(atlantisEquipments)).safeTransferFrom(msg.sender, address(this), _newId, 1, \"\");\r\n        }\r\n        // Check if oldId is not zero\r\n        if (_oldId != 0) {\r\n            // Transfer oldId to owner\r\n            IERC1155(address(atlantisEquipments)).safeTransferFrom(address(this), msg.sender, _oldId, 1, \"\");\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @notice Get details of a spaceship from its id\r\n     * @param _tokenId Token ID of spaceship\r\n     */\r\n    function getSpaceship(uint256 _tokenId) external view returns (SpaceshipData memory) {\r\n        SpaceshipData memory _spaceshipData = SpaceshipData(spaceships[_tokenId], getSpeed(_tokenId));\r\n        return _spaceshipData;\r\n    }\r\n\r\n    /**\r\n     * @notice Get speed of a spaceship from its id\r\n     * @param _tokenId Token ID of spaceship\r\n     */\r\n\r\n    function getSpeed(uint256 _tokenId) public view returns (uint256) {\r\n        IAtlantisEquipments atlantisEquipments = IAtlantisEquipments(addressRegistry.getEquipments());\r\n        // Get spaceship\r\n        Spaceship memory spaceship = spaceships[_tokenId];\r\n        // Get rarity\r\n        AtlantisLib.Rarity _rarity = spaceship.rarity;\r\n        uint16 fireSpeed = atlantisEquipments.getSpeed(spaceship.fireEquipmentId);\r\n        uint16 lightningSpeed = atlantisEquipments.getSpeed(spaceship.lightningEquipmentId);\r\n        uint16 steelSpeed = atlantisEquipments.getSpeed(spaceship.steelEquipmentId);\r\n\r\n        return (uint16(_rarity) + 1) * (fireSpeed + lightningSpeed + steelSpeed + 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Get rarity of a spaceship from its id\r\n     * @param _tokenId Token ID of spaceship\r\n     */\r\n    function getRarity(uint256 _tokenId) external view returns (AtlantisLib.Rarity) {\r\n        // Check exists\r\n        require(_exists(_tokenId), \"Spaceship does not exist\");\r\n        // Get spaceship\r\n        Spaceship memory spaceship = spaceships[_tokenId];\r\n        return spaceship.rarity;\r\n    }\r\n\r\n    /**\r\n     * @dev Set rarity of all spaceships\r\n     * @param _tokenId Token id of spaceship\r\n     * @param _rarity Rarity of spaceship\r\n     */\r\n    function setSpaceshipRarity(uint256 _tokenId, AtlantisLib.Rarity _rarity) internal {\r\n        spaceships[_tokenId].rarity = _rarity;\r\n        uint256 _speed = getSpeed(_tokenId);\r\n        emit SpaceshipRaritySet(_tokenId, _spaceshipRarityToString(_rarity), _speed);\r\n    }\r\n\r\n    // -------------------- ATLANTIS METADATA FUNCTIONS --------------------------\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     * @param _rarity Rarity of spaceship\r\n     * @return String of planet orbit\r\n     */\r\n    function _spaceshipRarityToString(AtlantisLib.Rarity _rarity) internal pure returns (string memory) {\r\n        if (_rarity == AtlantisLib.Rarity.COMMON) {\r\n            return \"Common\";\r\n        } else if (_rarity == AtlantisLib.Rarity.UNCOMMON) {\r\n            return \"Uncommon\";\r\n        } else if (_rarity == AtlantisLib.Rarity.RARE) {\r\n            return \"Rare\";\r\n        } else if (_rarity == AtlantisLib.Rarity.EPIC) {\r\n            return \"Epic\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get ImageURI\r\n     * @param _rarity Rarity of spaceship\r\n     * @param _lightningLevel Lightning level of spaceship\r\n     * @param _fireLevel Fire level of spaceship\r\n     * @param _steelLevel Steel level of spaceship\r\n     */\r\n    function getImageURI(\r\n        AtlantisLib.Rarity _rarity,\r\n        uint8 _lightningLevel,\r\n        uint8 _fireLevel,\r\n        uint8 _steelLevel\r\n    ) public view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    _baseURI(),\r\n                    uint256(_rarity).toString(),\r\n                    \"/\",\r\n                    uint256(AtlantisLib._getEquipmentTier(_steelLevel)).toString(),\r\n                    \"/\",\r\n                    uint256(AtlantisLib._getEquipmentTier(_fireLevel)).toString(),\r\n                    \"/\",\r\n                    uint256(AtlantisLib._getEquipmentTier(_lightningLevel)).toString(),\r\n                    \".png\"\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns token metadata\r\n     * @param _tokenId Token ID of spaceship\r\n     * @dev Metadata is stored on-chain\r\n     * @dev Metadata is stored in JSON format\r\n     * @return String of token metadata\r\n     */\r\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\r\n        _requireMinted(_tokenId);\r\n        IAtlantisEquipments atlantisEquipments = IAtlantisEquipments(addressRegistry.getEquipments());\r\n        // Get Spaceship\r\n        Spaceship memory spaceship = spaceships[_tokenId];\r\n\r\n        // Get rarity\r\n        AtlantisLib.Rarity rarity = spaceship.rarity;\r\n\r\n        // Name\r\n        string memory json = string(abi.encodePacked('{\"name\": \"', name(), \" #\", _tokenId.toString(), '\",'));\r\n\r\n        uint8 lightningLevel = atlantisEquipments.getLevel(spaceship.lightningEquipmentId);\r\n        uint8 fireLevel = atlantisEquipments.getLevel(spaceship.fireEquipmentId);\r\n        uint8 steelLevel = atlantisEquipments.getLevel(spaceship.steelEquipmentId);\r\n\r\n        string memory lightningString = lightningLevel != 0 ? uint256(lightningLevel).toString() : \"Unequipped\";\r\n        string memory fireString = fireLevel != 0 ? uint256(fireLevel).toString() : \"Unequipped\";\r\n        string memory steelString = steelLevel != 0 ? uint256(steelLevel).toString() : \"Unequipped\";\r\n        // Description\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"description\": \"Welcome to the captivating realm of Atlantis, the game-verse and home of the legendary Argonauts. Acquire Spaceships to take part in the Atlantis race and earn attractive rewards!\",'\r\n            )\r\n        );\r\n\r\n        // Attributes\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"attributes\": [{\"trait_type\": \"Rarity\", \"value\": \"',\r\n                _spaceshipRarityToString(rarity),\r\n                '\"},',\r\n                '{\"trait_type\": \"Thunderbolt Wings Level\", \"value\": \"',\r\n                lightningString,\r\n                '\"},',\r\n                '{\"trait_type\": \"Inferno Thrusters Level\", \"value\": \"',\r\n                fireString,\r\n                '\"},',\r\n                '{\"trait_type\": \"Argonium Exoshell Level\", \"value\": \"',\r\n                steelString,\r\n                '\"},'\r\n            )\r\n        );\r\n\r\n        json = string(\r\n            abi.encodePacked(json, '{\"trait_type\": \"Speed\", \"value\": \"', uint256(getSpeed(_tokenId)).toString(), '\"}],')\r\n        );\r\n\r\n        json = Base64.encode(\r\n            bytes(\r\n                string(\r\n                    abi.encodePacked(\r\n                        json,\r\n                        '\"image\": \"',\r\n                        getImageURI(rarity, lightningLevel, fireLevel, steelLevel),\r\n                        '\"}'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\r\n    }\r\n\r\n    // -------------------- MINT FUNCTIONS --------------------------\r\n\r\n    /**\r\n     * @notice Public Mint\r\n     * @param _address Address of user\r\n     */\r\n    function _mintOne(address _address) internal {\r\n        currentSupply += 1;\r\n        _safeMint(_address, currentIndex);\r\n        currentIndex += 1;\r\n\r\n        emit PublicMint(_address);\r\n    }\r\n\r\n    /**\r\n     * @notice Airdrop multiple nfts to multiple addresses\r\n     * @param _addresses All addresses that will receive nfts\r\n     * @param _rarities Amount of nfts that will be minted for each address\r\n     */\r\n    function airdrop(address[] calldata _addresses, uint8[] calldata _rarities) external onlyOwner {\r\n        // Check that both arrays are the same length\r\n        require(_addresses.length == _rarities.length, \"Arrays must be the same length\");\r\n        for (uint256 i; i < _addresses.length; i++) {\r\n            _mintOne(_addresses[i]);\r\n            setSpaceshipRarity(currentIndex - 1, AtlantisLib.Rarity(_rarities[i]));\r\n        }\r\n    }\r\n\r\n    // ------------------------- OWNER FUNCTIONS ----------------------------\r\n    /**\r\n     * @dev Set Metadata URI\r\n     * @param _newBaseURI new base uri\r\n     */\r\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n        baseURI = _newBaseURI;\r\n        emit BaseURIUpdated(_newBaseURI);\r\n    }\r\n\r\n    // Set Address registry\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) public onlyOwner {\r\n        addressRegistry = _addressRegistry;\r\n        emit AddressRegistryUpdated(address(_addressRegistry));\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if token exists\r\n     * @param tokenId Token ID\r\n     */\r\n    function exists(uint256 tokenId) external view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total supply of spaceships\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return currentSupply;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external pure returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external pure returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/common/AddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ncontract AddressRegistry {\r\n    mapping(bytes32 => address) public addresses;\r\n\r\n    function getAddress(bytes32 _identifier) public view returns (address) {\r\n        return addresses[_identifier];\r\n    }\r\n\r\n    function _setAddress(bytes32 _identifier, address contractAddress) internal {\r\n        addresses[_identifier] = contractAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/common/AtlantisLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nlibrary AtlantisLib {\r\n    enum Orbit {\r\n        COMMON, // 0\r\n        UNCOMMON, // 1\r\n        RARE, // 2\r\n        EPIC // 3\r\n    }\r\n\r\n    enum OrbitName {\r\n        HALO_RING, //0\r\n        PANDORA, //1\r\n        ATLAS, //2\r\n        METIS, //3\r\n        ENTWINED, //4\r\n        RAINBOW_CLOUDS, //5\r\n        GALATICA, //6\r\n        ASTEROIDS, //7\r\n        INTERSTELLAR_PINK, //8\r\n        INTERSTELLAR_GRADIENT, //9\r\n        // Epic planets\r\n        INTERSTELLAR_GOLD //10\r\n    }\r\n\r\n    enum Background {\r\n        PURPLE_HUES, //0\r\n        BROWN_HUES, //1\r\n        WAVY, //2\r\n        SHOOTING_STARS, //3\r\n        // Epic planets\r\n        GOLD_HUES, //4\r\n        GOLD_SHOOTING_STARS, //5\r\n        WAVY_GOLD, //6\r\n        GOLD_SKIES //7\r\n    }\r\n\r\n    enum Evolution {\r\n        ALPHA, // 1-19\r\n        BETA, // 20-29\r\n        GAMMA, // 30-39\r\n        DELTA, // 40-49\r\n        EPSILON // 50\r\n    }\r\n\r\n    enum Element {\r\n        FIRE, // 0\r\n        LIGHTNING, // 1\r\n        STEEL // 2\r\n    }\r\n\r\n    struct Planet {\r\n        uint8 level; // Max Level: 50\r\n        Element element;\r\n        Orbit orbit;\r\n        OrbitName orbitName;\r\n        Background background;\r\n        bool onExpedition;\r\n    }\r\n\r\n    enum Rarity {\r\n        COMMON,\r\n        UNCOMMON,\r\n        RARE,\r\n        EPIC\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet element as string\r\n     */\r\n    function _planetElementToString(AtlantisLib.Element element) internal pure returns (string memory) {\r\n        if (element == AtlantisLib.Element.FIRE) {\r\n            return \"Fire\";\r\n        } else if (element == AtlantisLib.Element.STEEL) {\r\n            return \"Steel\";\r\n        } else if (element == AtlantisLib.Element.LIGHTNING) {\r\n            return \"Lightning\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     */\r\n    function _planetOrbitToString(AtlantisLib.Orbit orbit) internal pure returns (string memory) {\r\n        if (orbit == AtlantisLib.Orbit.COMMON) {\r\n            return \"Common\";\r\n        } else if (orbit == AtlantisLib.Orbit.UNCOMMON) {\r\n            return \"Uncommon\";\r\n        } else if (orbit == AtlantisLib.Orbit.RARE) {\r\n            return \"Rare\";\r\n        } else if (orbit == AtlantisLib.Orbit.EPIC) {\r\n            return \"Epic\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get tier of equipment based on level\r\n     * @param level Level of an equipment\r\n     */\r\n    function _getEquipmentTier(uint8 level) internal pure returns (AtlantisLib.Rarity tier) {\r\n        if (level < 1) {\r\n            tier = AtlantisLib.Rarity.COMMON;\r\n        } else if (level >= 1 && level < 5) {\r\n            tier = AtlantisLib.Rarity.UNCOMMON;\r\n        } else if (level >= 5 && level < 8) {\r\n            tier = AtlantisLib.Rarity.RARE;\r\n        } else if (level >= 8 && level <= 10) {\r\n            tier = AtlantisLib.Rarity.EPIC;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     */\r\n    function _planetOrbitTypeToString(AtlantisLib.OrbitName orbitName) internal pure returns (string memory) {\r\n        if (orbitName == AtlantisLib.OrbitName.HALO_RING) {\r\n            return \"Halo Ring\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.PANDORA) {\r\n            return \"Pandora\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.ATLAS) {\r\n            return \"Atlas\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.METIS) {\r\n            return \"Metis\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.ENTWINED) {\r\n            return \"Entwined\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.RAINBOW_CLOUDS) {\r\n            return \"Rainbow Clouds\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.GALATICA) {\r\n            return \"Galatica\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.ASTEROIDS) {\r\n            return \"Asteroids\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.INTERSTELLAR_PINK) {\r\n            return \"Interstellar Pink\";\r\n        } else if (orbitName == AtlantisLib.OrbitName.INTERSTELLAR_GRADIENT) {\r\n            return \"Interstellar Gradient\";\r\n            // Epic planets\r\n        } else if (orbitName == AtlantisLib.OrbitName.INTERSTELLAR_GOLD) {\r\n            return \"Interstellar Gold\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns planet orbit as string\r\n     */\r\n    function _planetBackgroundToString(AtlantisLib.Background background) internal pure returns (string memory) {\r\n        if (background == AtlantisLib.Background.PURPLE_HUES) {\r\n            return \"Purple Hues\";\r\n        } else if (background == AtlantisLib.Background.BROWN_HUES) {\r\n            return \"Brown Hues\";\r\n        } else if (background == AtlantisLib.Background.WAVY) {\r\n            return \"Wavy\";\r\n        } else if (background == AtlantisLib.Background.SHOOTING_STARS) {\r\n            return \"Shooting Stars\";\r\n            // Epic planets\r\n        } else if (background == AtlantisLib.Background.WAVY_GOLD) {\r\n            return \"Wavy Gold\";\r\n        } else if (background == AtlantisLib.Background.GOLD_SHOOTING_STARS) {\r\n            return \"Gold Shooting Stars\";\r\n        } else if (background == AtlantisLib.Background.GOLD_HUES) {\r\n            return \"Gold Hues\";\r\n        } else if (background == AtlantisLib.Background.GOLD_SKIES) {\r\n            return \"Gold Skies\";\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Base64\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @notice Provides a function for encoding some bytes in base64\r\nlibrary Base64 {\r\n    string internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return \"\";\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {\r\n\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                dataPtr := add(dataPtr, 3)\r\n\r\n                // read 3 bytes\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "contracts/common/ERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./IERC721A.sol\";\r\n\r\n/**\r\n * @dev Interface of ERC721 token receiver.\r\n */\r\ninterface ERC721A__IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721A\r\n *\r\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\r\n * Non-Fungible Token Standard, including the Metadata extension.\r\n * Optimized for lower gas during batch mints.\r\n *\r\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\r\n * starting from `_startTokenId()`.\r\n *\r\n * Assumptions:\r\n *\r\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\r\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\r\n */\r\ncontract ERC721A is IERC721A {\r\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\r\n    struct TokenApprovalRef {\r\n        address value;\r\n    }\r\n\r\n    // =============================================================\r\n    //                           CONSTANTS\r\n    // =============================================================\r\n\r\n    // Mask of an entry in packed address data.\r\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n\r\n    // The bit position of `numberMinted` in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\r\n\r\n    // The bit position of `numberBurned` in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\r\n\r\n    // The bit position of `aux` in packed address data.\r\n    uint256 private constant _BITPOS_AUX = 192;\r\n\r\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\r\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n\r\n    // The bit position of `startTimestamp` in packed ownership.\r\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\r\n\r\n    // The bit mask of the `burned` bit in packed ownership.\r\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\r\n\r\n    // The bit position of the `nextInitialized` bit in packed ownership.\r\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\r\n\r\n    // The bit mask of the `nextInitialized` bit in packed ownership.\r\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n\r\n    // The bit position of `extraData` in packed ownership.\r\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\r\n\r\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\r\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\r\n\r\n    // The mask of the lower 160 bits for addresses.\r\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n\r\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\r\n    // This limit is to prevent overflows on the address data entries.\r\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\r\n    // is required to cause an overflow, which is unrealistic.\r\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\r\n\r\n    // The `Transfer` event signature is given by:\r\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    // =============================================================\r\n    //                            STORAGE\r\n    // =============================================================\r\n\r\n    // The next token ID to be minted.\r\n    uint256 private _currentIndex;\r\n\r\n    // The number of tokens burned.\r\n    uint256 private _burnCounter;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to ownership details\r\n    // An empty struct value does not necessarily mean the token is unowned.\r\n    // See {_packedOwnershipOf} implementation for details.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..159]   `addr`\r\n    // - [160..223] `startTimestamp`\r\n    // - [224]      `burned`\r\n    // - [225]      `nextInitialized`\r\n    // - [232..255] `extraData`\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n\r\n    // Mapping owner address to address data.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..63]    `balance`\r\n    // - [64..127]  `numberMinted`\r\n    // - [128..191] `numberBurned`\r\n    // - [192..255] `aux`\r\n    mapping(address => uint256) private _packedAddressData;\r\n\r\n    // Mapping from token ID to approved address.\r\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // =============================================================\r\n    //                          CONSTRUCTOR\r\n    // =============================================================\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    // =============================================================\r\n    //                   TOKEN COUNTING OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the starting token ID.\r\n     * To change the starting token ID, please override this function.\r\n     */\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     */\r\n    function _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        // Counter underflow is impossible as _burnCounter cannot be incremented\r\n        // more than `_currentIndex - _startTokenId()` times.\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view virtual returns (uint256) {\r\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\r\n        // and it is initialized to `_startTokenId()`.\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens burned.\r\n     */\r\n    function _totalBurned() internal view virtual returns (uint256) {\r\n        return _burnCounter;\r\n    }\r\n\r\n    // =============================================================\r\n    //                    ADDRESS DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens minted by `owner`.\r\n     */\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens burned by or on behalf of `owner`.\r\n     */\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     */\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\r\n    }\r\n\r\n    /**\r\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     * If there are multiple variables, please pack them into a uint64.\r\n     */\r\n    function _setAux(address owner, uint64 aux) internal virtual {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        // Cast `aux` with assembly to avoid redundant masking.\r\n        assembly {\r\n            auxCasted := aux\r\n        }\r\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        // The interface IDs are constants representing the first 4 bytes\r\n        // of the XOR of all function selectors in the interface.\r\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\r\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\r\n    }\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    // =============================================================\r\n    //                     OWNERSHIPS OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around over time.\r\n     */\r\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\r\n     */\r\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\r\n     */\r\n    function _initializeOwnershipAt(uint256 index) internal virtual {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the packed ownership data of `tokenId`.\r\n     */\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    // If not burned.\r\n                    if (packed & _BITMASK_BURNED == 0) {\r\n                        // Invariant:\r\n                        // There will always be an initialized ownership slot\r\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\r\n                        // before an unintialized ownership slot\r\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\r\n                        // Hence, `curr` will not underflow.\r\n                        //\r\n                        // We can directly compare the packed value.\r\n                        // If the address is zero, packed will be zero.\r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\r\n     */\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & _BITMASK_BURNED != 0;\r\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Packs ownership data into a single uint256.\r\n     */\r\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\r\n        assembly {\r\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\r\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\r\n     */\r\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\r\n        // For branchless setting of the `nextInitialized` flag.\r\n        assembly {\r\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\r\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      APPROVAL OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) public payable virtual override {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId].value = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId].value;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted. See {_mint}.\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex && // If within bounds,\r\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\r\n     */\r\n    function _isSenderApprovedOrOwner(\r\n        address approvedAddress,\r\n        address owner,\r\n        address msgSender\r\n    ) private pure returns (bool result) {\r\n        assembly {\r\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\r\n            // `msgSender == owner || msgSender == approvedAddress`.\r\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\r\n     */\r\n    function _getApprovedSlotAndAddress(\r\n        uint256 tokenId\r\n    ) private view returns (uint256 approvedAddressSlot, address approvedAddress) {\r\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\r\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\r\n        assembly {\r\n            approvedAddressSlot := tokenApproval.slot\r\n            approvedAddress := sload(approvedAddressSlot)\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      TRANSFER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public payable virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        // The nested ifs save around 20+ gas over a compound boolean condition.\r\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\r\n        unchecked {\r\n            // We can directly increment and decrement the balances.\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            // Updates:\r\n            // - `address` to the next owner.\r\n            // - `startTimestamp` to the timestamp of transfering.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `true`.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public payable virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public payable virtual override {\r\n        transferFrom(from, to, tokenId);\r\n        if (to.code.length != 0)\r\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a set of serially-ordered token IDs\r\n     * are about to be transferred. This includes minting.\r\n     * And also called before burning one token.\r\n     *\r\n     * `startTokenId` - the first token ID to be transferred.\r\n     * `quantity` - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a set of serially-ordered token IDs\r\n     * have been transferred. This includes minting.\r\n     * And also called after one token has been burned.\r\n     *\r\n     * `startTokenId` - the first token ID to be transferred.\r\n     * `quantity` - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` has been minted for `to`.\r\n     * - When `to` is zero, `tokenId` has been burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _afterTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\r\n\r\n    /**\r\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\r\n     *\r\n     * `from` - Previous owner of the given token ID.\r\n     * `to` - Target address that will receive the token.\r\n     * `tokenId` - Token ID to be transferred.\r\n     * `_data` - Optional data to send along with the call.\r\n     *\r\n     * Returns whether the call correctly returned the expected magic value.\r\n     */\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\r\n            bytes4 retval\r\n        ) {\r\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else {\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                        MINT OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _mint(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\r\n        // `tokenId` has a maximum limit of 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance += quantity`.\r\n            // - `numberMinted += quantity`.\r\n            //\r\n            // We can directly add to the `balance` and `numberMinted`.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - `address` to the owner.\r\n            // - `startTimestamp` to the timestamp of minting.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `quantity == 1`.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            uint256 toMasked;\r\n            uint256 end = startTokenId + quantity;\r\n\r\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\r\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\r\n            // The assembly, together with the surrounding Solidity code, have been\r\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\r\n            assembly {\r\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n                toMasked := and(to, _BITMASK_ADDRESS)\r\n                // Emit the `Transfer` event.\r\n                log4(\r\n                    0, // Start of data (0, since no data).\r\n                    0, // End of data (0, since no data).\r\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\r\n                    0, // `address(0)`.\r\n                    toMasked, // `to`.\r\n                    startTokenId // `tokenId`.\r\n                )\r\n\r\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\r\n                // that overflows uint256 will make the loop run out of gas.\r\n                // The compiler will optimize the `iszero` away for performance.\r\n                for {\r\n                    let tokenId := add(startTokenId, 1)\r\n                } iszero(eq(tokenId, end)) {\r\n                    tokenId := add(tokenId, 1)\r\n                } {\r\n                    // Emit the `Transfer` event. Similar to above.\r\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\r\n                }\r\n            }\r\n            if (toMasked == 0) revert MintToZeroAddress();\r\n\r\n            _currentIndex = end;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * This function is intended for efficient minting only during contract creation.\r\n     *\r\n     * It emits only one {ConsecutiveTransfer} as defined in\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\r\n     * instead of a sequence of {Transfer} event(s).\r\n     *\r\n     * Calling this function outside of contract creation WILL make your contract\r\n     * non-compliant with the ERC721 standard.\r\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\r\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {ConsecutiveTransfer} event.\r\n     */\r\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance += quantity`.\r\n            // - `numberMinted += quantity`.\r\n            //\r\n            // We can directly add to the `balance` and `numberMinted`.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - `address` to the owner.\r\n            // - `startTimestamp` to the timestamp of minting.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `quantity == 1`.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\r\n\r\n            _currentIndex = startTokenId + quantity;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * See {_mint}.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _safeMint(address to, uint256 quantity, bytes memory _data) internal virtual {\r\n        _mint(to, quantity);\r\n\r\n        unchecked {\r\n            if (to.code.length != 0) {\r\n                uint256 end = _currentIndex;\r\n                uint256 index = end - quantity;\r\n                do {\r\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } while (index < end);\r\n                // Reentrancy protection.\r\n                if (_currentIndex != end) revert();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\r\n     */\r\n    function _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, \"\");\r\n    }\r\n\r\n    // =============================================================\r\n    //                        BURN OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Equivalent to `_burn(tokenId, false)`.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        address from = address(uint160(prevOwnershipPacked));\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        if (approvalCheck) {\r\n            // The nested ifs save around 20+ gas over a compound boolean condition.\r\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance -= 1`.\r\n            // - `numberBurned += 1`.\r\n            //\r\n            // We can directly decrement the balance, and increment the number burned.\r\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\r\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\r\n\r\n            // Updates:\r\n            // - `address` to the last owner.\r\n            // - `startTimestamp` to the timestamp of burning.\r\n            // - `burned` to `true`.\r\n            // - `nextInitialized` to `true`.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                from,\r\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                     EXTRA DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Directly sets the extra data for the ownership data `index`.\r\n     */\r\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\r\n        uint256 packed = _packedOwnerships[index];\r\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\r\n        uint256 extraDataCasted;\r\n        // Cast `extraData` with assembly to avoid redundant masking.\r\n        assembly {\r\n            extraDataCasted := extraData\r\n        }\r\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\r\n        _packedOwnerships[index] = packed;\r\n    }\r\n\r\n    /**\r\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\r\n     * Intended to be overridden by the cosumer contract.\r\n     *\r\n     * `previousExtraData` - the value of `extraData` before transfer.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _extraData(address from, address to, uint24 previousExtraData) internal view virtual returns (uint24) {}\r\n\r\n    /**\r\n     * @dev Returns the next extra data for the packed ownership data.\r\n     * The returned result is shifted into position.\r\n     */\r\n    function _nextExtraData(address from, address to, uint256 prevOwnershipPacked) private view returns (uint256) {\r\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\r\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\r\n    }\r\n\r\n    // =============================================================\r\n    //                       OTHER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the message sender (defaults to `msg.sender`).\r\n     *\r\n     * If you are writing GSN compatible contracts, you need to override this function.\r\n     */\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a uint256 to its ASCII string decimal representation.\r\n     */\r\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\r\n            let m := add(mload(0x40), 0xa0)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, m)\r\n            // Assign the `str` to the end.\r\n            str := sub(m, 0x20)\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 1)\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                // prettier-ignore\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Interface of ERC721A.\r\n */\r\ninterface IERC721A {\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error ApprovalQueryForNonexistentToken();\r\n\r\n    /**\r\n     * Cannot query the balance for the zero address.\r\n     */\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    /**\r\n     * Cannot mint to the zero address.\r\n     */\r\n    error MintToZeroAddress();\r\n\r\n    /**\r\n     * The quantity of tokens minted must be more than zero.\r\n     */\r\n    error MintZeroQuantity();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error OwnerQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token must be owned by `from`.\r\n     */\r\n    error TransferFromIncorrectOwner();\r\n\r\n    /**\r\n     * Cannot safely transfer to a contract that does not implement the\r\n     * ERC721Receiver interface.\r\n     */\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /**\r\n     * Cannot transfer to the zero address.\r\n     */\r\n    error TransferToZeroAddress();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error URIQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\r\n     */\r\n    error MintERC2309QuantityExceedsLimit();\r\n\r\n    /**\r\n     * The `extraData` cannot be set on an unintialized ownership slot.\r\n     */\r\n    error OwnershipNotInitializedForExtraData();\r\n\r\n    // =============================================================\r\n    //                            STRUCTS\r\n    // =============================================================\r\n\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        // Stores the start time of ownership with minimal overhead for tokenomics.\r\n        uint64 startTimestamp;\r\n        // Whether the token has been burned.\r\n        bool burned;\r\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\r\n        uint24 extraData;\r\n    }\r\n\r\n    // =============================================================\r\n    //                         TOKEN COUNTERS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                            IERC721\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables\r\n     * (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\r\n     * checking first that contract recipients are aware of the ERC721 protocol\r\n     * to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move\r\n     * this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\r\n     * whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external payable;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    // =============================================================\r\n    //                           IERC2309\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\r\n     * (inclusive) is transferred from `from` to `to`, as defined in the\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\r\n     *\r\n     * See {_mintERC2309} for more details.\r\n     */\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\r\n}\r\n"
    },
    "contracts/common/IMintBurnToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IMintBurnToken {\r\n    function mintTo(address to, uint256 amount) external returns (bool);\r\n\r\n    function burn(uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "contracts/common/MockArgonauts.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./ERC721A.sol\";\r\nimport \"../AtlantisAddressRegistry.sol\";\r\n\r\n/// @title Argonauts Mint Contract v2\r\ncontract MockArgonauts is ERC721A {\r\n    address addressRegistry;\r\n\r\n    constructor(address _addressRegistry) ERC721A(\"Argonauts\", \"ARGONAUTS\") {\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    // -------------------- MINT FUNCTIONS --------------------------\r\n    // TODO: FOR INCENTIVISED TESTNET SET THIS TO ONLY MINT BY FAUCET\r\n    function mint(uint256 _mintAmount) external {\r\n        _safeMint(tx.origin, _mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return \"https://argonauts-nft.herokuapp.com/metadata/\";\r\n    }\r\n\r\n    function exists(uint256 tokenId) external view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    function baseURI() external view returns (string memory) {\r\n        return _baseURI();\r\n    }\r\n}\r\n"
    },
    "contracts/common/MockERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Mock ERC1155 contract for testing purposes\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\n\r\ncontract MockERC1155 is ERC1155 {\r\n    constructor() ERC1155(\"testURI\") {}\r\n\r\n    function mint(address account, uint256 id, uint256 amount, bytes memory data) external {\r\n        _mint(account, id, amount, data);\r\n    }\r\n\r\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external {\r\n        _mintBatch(to, ids, amounts, data);\r\n    }\r\n}\r\n"
    },
    "contracts/common/MockWCRO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/// @title Argonauts Mint Contract\r\ncontract MockWCRO is ERC20 {\r\n    constructor() ERC20(\"MockWCRO\", \"mWCRO\") {}\r\n\r\n    function devMint(uint256 _amount) external {\r\n        _mint(tx.origin, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/common/MockXARGO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/// @title Argonauts Mint Contract\r\ncontract XARGO is ERC20 {\r\n    constructor() ERC20(\"MockXARGO\", \"mXARGO\") {}\r\n\r\n    function devMint(uint256 _amount) external {\r\n        _mint(tx.origin, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/common/RandomlyAssigned.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./WithLimitedSupply.sol\";\r\n\r\n/// @author 1001.digital\r\n/// @title Randomly assign tokenIDs from a given set of tokens (PSEUDORANDOM).\r\nabstract contract RandomlyAssigned is WithLimitedSupply {\r\n    // Used for random index assignment\r\n    mapping(uint256 => uint256) private tokenMatrix;\r\n\r\n    // The initial token ID\r\n    uint256 private startFrom;\r\n\r\n    /// Instantiate the contract\r\n    /// @param _totalMaxSupply how many tokens this collection should hold\r\n    /// @param _startFrom the tokenID with which to start counting\r\n    constructor(uint256 _totalMaxSupply, uint256 _startFrom)\r\n        WithLimitedSupply(_totalMaxSupply)\r\n    {\r\n        startFrom = _startFrom;\r\n    }\r\n\r\n    /// Get the next token ID\r\n    /// @dev Randomly gets a new token ID and keeps track of the ones that are still available.\r\n    /// @return the next token ID\r\n    function nextToken()\r\n        internal\r\n        override\r\n        ensureAvailability\r\n        returns (uint256)\r\n    {\r\n        uint256 maxIndex = totalMaxSupply() - tokenCount();\r\n        uint256 random = uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    msg.sender,\r\n                    block.coinbase,\r\n                    block.difficulty,\r\n                    block.gaslimit,\r\n                    block.timestamp\r\n                )\r\n            )\r\n        ) % maxIndex;\r\n\r\n        uint256 value = 0;\r\n        if (tokenMatrix[random] == 0) {\r\n            // If this matrix position is empty, set the value to the generated random number.\r\n            value = random;\r\n        } else {\r\n            // Otherwise, use the previously stored number from the matrix.\r\n            value = tokenMatrix[random];\r\n        }\r\n\r\n        // If the last available tokenID is still unused...\r\n        if (tokenMatrix[maxIndex - 1] == 0) {\r\n            // ...store that ID in the current matrix position.\r\n            tokenMatrix[random] = maxIndex - 1;\r\n        } else {\r\n            // ...otherwise copy over the stored number to the current matrix position.\r\n            tokenMatrix[random] = tokenMatrix[maxIndex - 1];\r\n        }\r\n\r\n        // Increment counts\r\n        super.nextToken();\r\n\r\n        return value + startFrom;\r\n    }\r\n}\r\n"
    },
    "contracts/common/SetUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nlibrary SetUtils {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    /// @dev Converst an iterable set of addresses to a corresponding array\r\n    function toArray(EnumerableSet.AddressSet storage _set) internal view returns (address[] memory) {\r\n        uint256 numElements = _set.length();\r\n        address[] memory elements = new address[](numElements);\r\n        for (uint256 i = 0; i < numElements; ++i) {\r\n            elements[i] = _set.at(i);\r\n        }\r\n        return elements;\r\n    }\r\n\r\n    /// @dev Converst an iterable set of uint to a corresponding array\r\n    function toArray(EnumerableSet.UintSet storage _set) internal view returns (uint256[] memory) {\r\n        uint256 numElements = _set.length();\r\n        uint256[] memory elements = new uint256[](numElements);\r\n        for (uint256 i = 0; i < numElements; ++i) {\r\n            elements[i] = _set.at(i);\r\n        }\r\n        return elements;\r\n    }\r\n}\r\n"
    },
    "contracts/common/WithLimitedSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\n/// @title A token tracker that limits the token supply and increments token IDs on each new mint.\r\nabstract contract WithLimitedSupply {\r\n    using Counters for Counters.Counter;\r\n\r\n    /// @dev Emitted when the supply of this collection changes\r\n    event SupplyChanged(uint256 supply);\r\n\r\n    // Keeps track of how many we have minted\r\n    Counters.Counter private _tokenCount;\r\n\r\n    /// @dev The maximum count of tokens this token tracker will hold.\r\n    uint256 private _totalMaxSupply;\r\n\r\n    /// Instanciate the contract\r\n    /// @param totalMaxSupply_ how many tokens this collection should hold\r\n    constructor(uint256 totalMaxSupply_) {\r\n        _totalMaxSupply = totalMaxSupply_;\r\n    }\r\n\r\n    /// @dev Get the max Supply\r\n    /// @return the maximum token count\r\n    function totalMaxSupply() public view virtual returns (uint256) {\r\n        return _totalMaxSupply;\r\n    }\r\n\r\n    /// @dev Get the current token count\r\n    /// @return the created token count\r\n    function tokenCount() public view returns (uint256) {\r\n        return _tokenCount.current();\r\n    }\r\n\r\n    /// @dev Check whether tokens are still available\r\n    /// @return the available token count\r\n    function availableTokenCount() public view returns (uint256) {\r\n        return totalMaxSupply() - tokenCount();\r\n    }\r\n\r\n    /// @dev Increment the token count and fetch the latest count\r\n    /// @return the next token id\r\n    function nextToken() internal virtual returns (uint256) {\r\n        uint256 token = _tokenCount.current();\r\n\r\n        _tokenCount.increment();\r\n\r\n        return token;\r\n    }\r\n\r\n    /// @dev Check whether another token is still available\r\n    modifier ensureAvailability() {\r\n        require(availableTokenCount() > 0, \"No more tokens available\");\r\n        _;\r\n    }\r\n\r\n    /// @param amount Check whether number of tokens are still available\r\n    /// @dev Check whether tokens are still available\r\n    modifier ensureAvailabilityFor(uint256 amount) {\r\n        require(availableTokenCount() >= amount, \"Requested number of tokens not available\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/ERC1155Burner.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\n// Import IERC1155Receiver\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\n\r\ncontract ERC1155Burner is IERC1155Receiver {\r\n    // The address of the ERC-1155 token contract\r\n    IERC1155 private immutable _erc1155Token;\r\n\r\n    // Mapping of user to burnt\r\n    mapping(address => uint256) public burnt;\r\n\r\n    // Event to emit when tokens are burned\r\n    event TokensBurned(address indexed user, uint256 indexed tokenId, uint256 amount);\r\n\r\n    constructor(IERC1155 erc1155Token) {\r\n        _erc1155Token = erc1155Token;\r\n    }\r\n\r\n    function burnTokens(uint256 tokenId, uint256 amount) external {\r\n        // Update mapping to reflect burnt tokens\r\n        burnt[msg.sender] += amount;\r\n        // Transfer tokens to the zero address\r\n        _erc1155Token.safeTransferFrom(msg.sender, address(0x0000dead), tokenId, amount, \"\");\r\n        // Emit the TokensBurned event\r\n        emit TokensBurned(msg.sender, tokenId, amount);\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        // Add your custom logic for handling ERC1155 token transfers\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        // Add your custom logic for handling ERC1155 token transfers\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n"
    },
    "contracts/GoldPledging.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract GoldPledging is Ownable, Pausable, ReentrancyGuard {\r\n    // Using SafeERC20 for IERC20\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How many Gold tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n    }\r\n\r\n    // Info of Pool\r\n    struct PoolInfo {\r\n        uint256 lastRewardBlock; // Last block number that Rewards distribution occurs.\r\n        uint256 accRewardPerShare; // Accumulated reward per share, times 1e12. See below.\r\n    }\r\n\r\n    // Gold Token\r\n    IERC20 public gold;\r\n\r\n    // Stardust Token\r\n    IERC20 public stardust;\r\n\r\n    // rewards created per block.\r\n    uint256 public rewardPerBlock;\r\n\r\n    uint256 public totalGold;\r\n    // Info.\r\n    PoolInfo public poolInfo;\r\n    // Info of each user that stakes Gold tokens.\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    // The block number when mining starts.\r\n    uint256 public startBlock;\r\n    // The block number when mining ends.\r\n    uint256 public bonusEndBlock;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n    event PoolUpdate(uint256 accRewardPerShare, uint256 lastRewardBlock);\r\n    event EmissionsModified(uint256 rewardPerBlock, uint256 startBlock, uint256 bonusEndBlock, uint256 lastRewardBlock);\r\n\r\n    constructor(address _gold, address _stardust, uint256 _rewardPerBlock, uint256 _startBlock, uint256 _endBlock) {\r\n        // Require both gold and stardust to not be the zero address\r\n        require(_gold != address(0), \"GoldPledging: gold address cannot be 0x0\");\r\n        require(_stardust != address(0), \"GoldPledging: stardust address cannot be 0x0\");\r\n        stardust = IERC20(_stardust);\r\n        gold = IERC20(_gold);\r\n        // Require the end block to be greater than the start block\r\n        require(_endBlock > _startBlock, \"GoldPledging: endBlock must be greater than startBlock\");\r\n        // Require that startBlock cannot be in the past\r\n        require(block.number < _startBlock, \"GoldPledging: startBlock must be in the future\");\r\n        rewardPerBlock = _rewardPerBlock;\r\n        startBlock = _startBlock;\r\n        bonusEndBlock = _endBlock;\r\n\r\n        // staking pool\r\n        poolInfo = PoolInfo({ lastRewardBlock: startBlock, accRewardPerShare: 0 });\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\r\n        if (_to <= bonusEndBlock) {\r\n            return _to - _from;\r\n        } else if (_from >= bonusEndBlock) {\r\n            return 0;\r\n        } else {\r\n            return bonusEndBlock - _from;\r\n        }\r\n    }\r\n\r\n    // View function to see pending Tokens on frontend.\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 accRewardPerShare = pool.accRewardPerShare;\r\n        uint256 stakedSupply = totalGold;\r\n        if (block.number > pool.lastRewardBlock && stakedSupply != 0) {\r\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n            uint256 tokenReward = multiplier * rewardPerBlock;\r\n            accRewardPerShare = accRewardPerShare + ((tokenReward * 1e12) / stakedSupply);\r\n        }\r\n        return (user.amount * accRewardPerShare) / 1e12 - user.rewardDebt;\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool() public {\r\n        if (block.number <= poolInfo.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 goldSupply = totalGold;\r\n        if (goldSupply == 0) {\r\n            poolInfo.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\r\n        uint256 tokenReward = multiplier * rewardPerBlock;\r\n\r\n        poolInfo.accRewardPerShare = poolInfo.accRewardPerShare + ((tokenReward * 1e12) / goldSupply);\r\n        poolInfo.lastRewardBlock = block.number;\r\n        emit PoolUpdate(poolInfo.accRewardPerShare, poolInfo.lastRewardBlock);\r\n    }\r\n\r\n    // Deposit Gold tokens to farm Stardust\r\n    function deposit(uint256 _amount) external nonReentrant whenNotPaused {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        updatePool();\r\n        totalGold += _amount;\r\n        if (user.amount > 0) {\r\n            uint256 pending = (user.amount * poolInfo.accRewardPerShare) / 1e12 - user.rewardDebt;\r\n            if (pending > 0) {\r\n                stardust.safeTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            gold.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount + _amount;\r\n        }\r\n        user.rewardDebt = (user.amount * poolInfo.accRewardPerShare) / 1e12;\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw Gold tokens\r\n    function withdraw(uint256 _amount) external nonReentrant whenNotPaused {\r\n        require(_amount > 0, \"amount 0\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not enough\");\r\n\r\n        updatePool();\r\n        totalGold -= _amount;\r\n        uint256 pending = (user.amount * poolInfo.accRewardPerShare) / 1e12 - user.rewardDebt;\r\n\r\n        if (pending > 0) {\r\n            stardust.safeTransfer(msg.sender, pending);\r\n        }\r\n\r\n        if (_amount > 0) {\r\n            gold.safeTransfer(address(msg.sender), _amount);\r\n            user.amount = user.amount - _amount;\r\n        }\r\n        user.rewardDebt = (user.amount * poolInfo.accRewardPerShare) / 1e12;\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        gold.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, amount);\r\n    }\r\n\r\n    // Modify rate of Stardust farming.\r\n    function modifyEmissions(uint256 _rewardPerBlock, uint256 _startBlock, uint256 _endBlock) external onlyOwner {\r\n        // Check that the start block is greater than the current block\r\n        require(block.number < _startBlock, \"GoldPledging: startBlock must be in the future\");\r\n        // Check that endBlock is greater than startBlock\r\n        require(_endBlock > _startBlock, \"GoldPledging: endBlock must be greater than startBlock\");\r\n        rewardPerBlock = _rewardPerBlock;\r\n        startBlock = _startBlock;\r\n        bonusEndBlock = _endBlock;\r\n        poolInfo.lastRewardBlock = startBlock;\r\n        emit EmissionsModified(rewardPerBlock, startBlock, bonusEndBlock, poolInfo.lastRewardBlock);\r\n    }\r\n\r\n    // Pause from Pausable\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    // Unpause from Pausable\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n}\r\n"
    },
    "contracts/interface/IAtlantis.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IAtlantisGemstones } from \"./IAtlantisGemstones.sol\";\r\nimport { IAtlantisPlanets } from \"./IAtlantisPlanets.sol\";\r\nimport { AtlantisLib } from \"../common/AtlantisLib.sol\";\r\n\r\ninterface IAtlantis {\r\n    /**\r\n     * The nft staked must belong to an approved collection\r\n     */\r\n    error NFTCollectionNotWhitelisted();\r\n\r\n    /**\r\n     * The length of tokenIds should not be 0\r\n     */\r\n    error TokenIdInputEmpty();\r\n\r\n    /**\r\n     * The length of tokenIds and collectionAddress must be the same\r\n     */\r\n    error ArrayLengthMismatch();\r\n\r\n    /**\r\n     * Expeditton in progress\r\n     */\r\n    error ExpeditionInProgress();\r\n\r\n    /**\r\n     * Not the owner of the expedition\r\n     */\r\n    error NotOwnerOfExpedition();\r\n\r\n    /**\r\n     * Expedition already ended\r\n     */\r\n    error ExpeditionAlreadyEnded();\r\n    /**\r\n     * Invalid expedition input\r\n     */\r\n    error InvalidExpeditionInput();\r\n    /**\r\n     * Invalid gemstone rate input\r\n     */\r\n    error InvalidSetGemstoneRateInput();\r\n    /**\r\n     * Invalid inputs while setting NFTGemstoneMultiplier\r\n     */\r\n    error InvalidSetNFTGemstoneMultiplierInput();\r\n    /**\r\n     * Invalid inputs while setting RarityMultiplier\r\n     */\r\n    error InvalidSetRarityMultiplierInput();\r\n    /**\r\n     * @notice Expedition struct\r\n     * @param collectionAddresses addresses of collections that corresponds to tokenIds array\r\n     * @param tokenIds Array of tokenIds for boosting expedition rewards\r\n     * @param id Id of expedition\r\n     * @param planetId Id of planet which expedition was started with\r\n     * @param startTime Start time of the expedition\r\n     * @param endTime End time of the expedition\r\n     * @param owner Address of user who started expedition\r\n     * @param hasEnded Shows whether expedition has ended or not\r\n     */\r\n    struct Expedition {\r\n        address[] collectionAddresses;\r\n        uint256[] tokenIds;\r\n        uint256 id;\r\n        uint256 planetId;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        address owner;\r\n        bool hasEnded;\r\n    }\r\n\r\n    function startExpedition(\r\n        uint256 _planetId,\r\n        address[] memory _collectionAddresses,\r\n        uint256[] memory _tokenIds\r\n    ) external payable;\r\n\r\n    function endExpeditions(uint256[] memory _expeditionIds) external;\r\n\r\n    function claimRewards(uint256[] memory _expeditionIds) external payable;\r\n\r\n    function getExpeditionInfo(uint256 _expeditionId) external view returns (Expedition memory);\r\n\r\n    function setExpeditionDuration(uint256 _duration) external;\r\n\r\n    /**\r\n     * @notice Event emitted when expedition is started\r\n     * @param user Address of user who started expedition\r\n     * @param expeditionId Id of expedition\r\n     * @param planetId Id of planet which expedition was started with\r\n     * @param tokenIds Array of tokenIds for boosting expedition rewards\r\n     * @param collectionAddresses addresses of collections that corresponds to tokenIds array\r\n     * @param startTime Start time of the expedition\r\n     * @param endTime End time of the expedition\r\n     */\r\n    event ExpeditionStarted(\r\n        address indexed user,\r\n        uint256 indexed expeditionId,\r\n        uint256 planetId,\r\n        uint256[] tokenIds,\r\n        address[] collectionAddresses,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when expedition is ended\r\n     * @param user Address of user who ended expedition\r\n     * @param expeditionId Id of expedition\r\n     * @param timeEnded Time when expedition ended\r\n     */\r\n    event ExpeditionEnded(address indexed user, uint256 indexed expeditionId, uint256 timeEnded);\r\n    /**\r\n     * @notice Event emitted when rewards are claimed\r\n     * @param user Address of user who started expedition\r\n     * @param expeditionId Id of expedition\r\n     * @param gemstoneId Id of gemstone claimed as rewards\r\n     * @param gemstoneGenerated Amount of gemstone returned from this expedition\r\n     * @param stardust Amount of stardust returned from this expedition\r\n     * @param startTime Start time of the expedition\r\n     * @param endTime End time of the expedition\r\n     */\r\n    event RewardsClaimed(\r\n        address indexed user,\r\n        uint256 indexed expeditionId,\r\n        uint256 indexed gemstoneId,\r\n        uint256 gemstoneGenerated,\r\n        uint256 stardust,\r\n        uint256 startTime, // New startTime of the expedition\r\n        uint256 endTime // New endTime of the expedition\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when expedition duration is changed\r\n     * @param newDuration New duration of expedition\r\n     */\r\n    event ExpeditionDurationUpdated(uint256 newDuration);\r\n\r\n    /**\r\n     * @notice Event emitted when whitelisted collections are updated\r\n     * @param collections Array of whitelisted collections\r\n     * @param isWhitelisted Bool to show if collection is whitelisted or not\r\n     */\r\n    event WhitelistedCollectionsUpdated(address[] collections, bool isWhitelisted);\r\n\r\n    /**\r\n     * @notice Event emitted when gemstone rate is updated\r\n     * @param _levels Array of levels\r\n     * @param _rates Array of rates\r\n     */\r\n    event GemstoneRateUpdated(uint8[] _levels, uint256[] _rates);\r\n\r\n    /**\r\n     * @notice Event emitted when NFTGemstoneMultiplier is updated\r\n     * @param newMultipliers Array of multipliers\r\n     */\r\n    event NFTGemstoneMultiplierUpdated(uint256[] newMultipliers);\r\n\r\n    /**\r\n     * @notice Event emitted when RarityMultiplier is updated\r\n     * @param newMultipliers Array of multipliers\r\n     */\r\n    event RarityMultiplierUpdated(uint256[] newMultipliers);\r\n\r\n    /**\r\n     * @notice Event emitted when BaseStardustRate is updated\r\n     * @param newRate New rate\r\n     */\r\n    event BaseStardustRateUpdated(uint256 newRate);\r\n\r\n    /**\r\n     * @notice Event emitted when level parameter is updated\r\n     * @param newParameter New parameter\r\n     */\r\n    event LevelParameterUpdated(uint256 newParameter);\r\n\r\n    /**\r\n     * @notice Event emitted when rarity parameter is updated\r\n     * @param newParameter New parameter\r\n     */\r\n    event RarityParameterUpdated(uint256 newParameter);\r\n\r\n    /**\r\n     * @notice Event emitted when registry is updated\r\n     * @param newRegistry New registry address\r\n     */\r\n    event AddressRegistryUpdated(address newRegistry);\r\n\r\n    /**\r\n     * @notice Event emitted when tax fee is updated\r\n     * @param newFee New tax fee\r\n     */\r\n    event TaxFeeUpdated(uint256 newFee);\r\n\r\n    /**\r\n     * @notice Event emitted when treasury is updated\r\n     * @param newTreasury New treasury address\r\n     */\r\n    event TreasuryUpdated(address newTreasury);\r\n}\r\n"
    },
    "contracts/interface/IAtlantisEquipments.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\ninterface IAtlantisEquipments {\r\n    // ------------------------- EVENTS --------------------------\r\n    event FuseEquipment(address indexed _from, uint256 indexed _id, uint256 _amount, uint256 _totalSupply);\r\n    event BaseMetadataURIUpdated(string _baseMetadataURI);\r\n    event TokenURIUpdated(uint256 indexed _id, string _tokenURI);\r\n    event AddressRegistryUpdated(address _address);\r\n    event StardustCostsUpdated(uint256[] _stardustCosts);\r\n    event GemstonesRequiredUpdated(uint16[] _gemstonesRequired);\r\n    event EquipmentSpeedsUpdated(uint16[] _equipmentSpeeds);\r\n    event MintCostUpdated(uint256 _mintCost);\r\n    event PaymentModeUpdated(PaymentMode _paymentMode);\r\n    event PaymentTokenUpdated(address _paymentToken);\r\n    // ------------------------- ERRORS --------------------------\r\n    error UpgradeError();\r\n    error IdNotExistsError();\r\n\r\n    /// @notice Enum for payment mode\r\n    enum PaymentMode {\r\n        CRYPTO,\r\n        TOKEN\r\n    }\r\n\r\n    function fuseEquipment(uint256 _id, uint16 _amountToCreate) external;\r\n\r\n    function calculateFusionCost(uint256 _id, uint16 _amountToCreate) external view returns (uint256);\r\n\r\n    function fuseEquipmentsView(uint256 _id, uint16 _amountToCreate) external view returns (uint16);\r\n\r\n    function getLevel(uint256 _id) external pure returns (uint8);\r\n\r\n    function getSpeed(uint256 _id) external view returns (uint16);\r\n\r\n    function setStardustCosts(uint256[] calldata _stardustCost) external;\r\n\r\n    function getElement(uint256 _id) external pure returns (uint8);\r\n}\r\n"
    },
    "contracts/interface/IAtlantisGemstones.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IAtlantisGemstones is IERC1155 {\r\n    error NonExistentToken();\r\n    error OnlyAtlantisOrOwner();\r\n    error InvalidInputAmount();\r\n    error InvalidElement();\r\n    error InvalidUpgrade();\r\n\r\n    function fuseGemstones(uint8 _id, uint8 _toId, uint256 _amountToCreate) external;\r\n\r\n    function burn(address _user, uint256 _id, uint256 _quantity) external;\r\n\r\n    function mint(address _to, uint256 _id, uint256 _quantity) external;\r\n\r\n    event FusionCostUpdated(uint256 _newCost);\r\n    event BaseMetadataURIUpdated(string _newBaseMetadataURI);\r\n    event AddressRegistryUpdated(address _newAddressRegistry);\r\n}\r\n"
    },
    "contracts/interface/IAtlantisPlanets.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n// Import AtlantisLib\r\nimport { AtlantisLib } from \"../common/AtlantisLib.sol\";\r\n\r\ninterface IAtlantisPlanets is IERC721 {\r\n    error AuctionSettled();\r\n\r\n    /**\r\n     * The signature must be by the correct signer\r\n     */\r\n    error InvalidSignature();\r\n\r\n    /**\r\n     * The minting stage must be correct\r\n     */\r\n    error InvalidStage(uint8 currentStage, uint8 requiredStage);\r\n\r\n    /**\r\n     * The collection has exceeded the max supply\r\n     */\r\n    error ExceededMaxSupply();\r\n\r\n    /**\r\n     * The user has exceeded allowed mint count\r\n     */\r\n    error ExceedMaxMintPerWallet();\r\n\r\n    /**\r\n     * The planet has exceeded the max level\r\n     */\r\n    error ExceededMaxLevel();\r\n\r\n    /**\r\n     * Error thrown when user queries an unknown OrbitId\r\n     */\r\n    error UnknownOrbit();\r\n\r\n    /**\r\n     * Error thrown when user queries an unknown ElementId\r\n     */\r\n    error UnknownElement();\r\n\r\n    /**\r\n     * Error thrown when user queries an unknown PlanetId\r\n     */\r\n    error InvalidUpgradeLevel(uint8 currentLevel, uint8 newLevel);\r\n    /**\r\n     * User is not the owner of planet\r\n     */\r\n    error NotOwnerOfPlanet();\r\n\r\n    error InsufficientCRO(uint256 amountPaid, uint256 amountRequired);\r\n\r\n    error InvalidInput();\r\n\r\n    function upgradePlanet(uint256 _tokenId, uint8 _levels) external;\r\n\r\n    function getUpgradeCosts(\r\n        uint256 _tokenId,\r\n        uint8 _levels\r\n    ) external view returns (uint256 stardustCost, uint256 xArgoCost, uint16[4] memory gemstoneRequirements);\r\n\r\n    function getPlanetDetails(uint256 _planetId) external view returns (AtlantisLib.Planet memory);\r\n\r\n    function setPlanetElements(uint256[] memory _tokenIds, AtlantisLib.Element[] memory _gemstoneType) external;\r\n\r\n    function setPlanetOrbits(uint256[] memory _tokenIds, AtlantisLib.Orbit[] memory _planetsOrbit) external;\r\n}\r\n"
    },
    "contracts/interface/IAtlantisRacing.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\ninterface IAtlantisRacing {\r\n    /**\r\n        Structs\r\n    */\r\n    struct PoolInfo {\r\n        uint256 poolType;\r\n        uint256 rewardPerSecond;\r\n        uint256 stardustWeightage;\r\n        uint256 goldWeightage;\r\n        uint256 lastRewardTime;\r\n        uint256 accStardustPerPoint;\r\n        uint256 totalPoints;\r\n        uint256 totalCount;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256[4] totalSpeeds;\r\n        uint256[4] rewardDebts;\r\n        uint256 spaceshipsStaked;\r\n        mapping(uint8 => mapping(address => uint256[])) boostingNfts;\r\n        uint256 boostingNftsCount;\r\n        mapping(uint8 => uint8) boostingNftsPoolCount;\r\n    }\r\n    event Stake(address indexed user, uint256 indexed tokenID, uint256 shipScore);\r\n    event Unstaked(address indexed user, uint256 indexed tokenID);\r\n    event Payout(uint8 poolId, address indexed user, uint256 goldAmount, uint256 stardustAmount);\r\n    event EmergencyWithdraw(address user, uint256 tokenID);\r\n    event EmergencyWithdrawStardust(uint256 amount);\r\n    event EmergencyWithdrawGold(uint256 amount);\r\n    event StakeNfts(uint256 indexed pid, address indexed user, uint256 numOfNfts);\r\n    event UnstakeNfts(uint256 indexed pid, address indexed user, uint256 numOfNfts);\r\n    event SeasonEndTimeChanged(uint256 newEndTime);\r\n    event StartSeason(uint256 startTime);\r\n    event EndSeason(uint256 endTime);\r\n    event AddressRegistryUpdated(address newAddressRegistry);\r\n\r\n    /**\r\n        Functions\r\n    */\r\n    function stakeSpaceships(uint256[] memory _ids) external;\r\n\r\n    function unstakeSpaceships(uint256[] memory _ids) external;\r\n\r\n    function stakeNfts(uint8 _pid, address[] calldata _collectionAddresses, uint256[] calldata _nfts) external;\r\n\r\n    function unstakeNfts(uint8 _pid, address[] calldata _collectionAddresses, uint256[] calldata _nfts) external;\r\n\r\n    function viewRewards(address _user, uint8 _poolId) external view returns (uint256[2] memory);\r\n\r\n    function getRewards() external;\r\n\r\n    function viewTotalSpeeds(address _user) external view returns (uint256[4] memory);\r\n\r\n    function viewBoostingNfts(\r\n        uint8 _pid,\r\n        address _collectionAddress,\r\n        address _user\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function viewPoolInfo(uint256 _pid) external view returns (PoolInfo memory);\r\n\r\n    function getCurrentlyStakedTokenIds(\r\n        uint8 _pid,\r\n        address _collectionAddress,\r\n        address _staker\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function getPreviouslyStakedTokenIds(address _collectionAddress) external view returns (uint256[] memory);\r\n}\r\n"
    },
    "contracts/interface/IAtlantisSpaceships.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport { AtlantisLib } from \"../common/AtlantisLib.sol\";\r\n\r\ninterface IAtlantisSpaceships {\r\n    error NotOwner();\r\n    error WrongElement();\r\n\r\n    struct Spaceship {\r\n        AtlantisLib.Rarity rarity;\r\n        uint256 fireEquipmentId;\r\n        uint256 lightningEquipmentId;\r\n        uint256 steelEquipmentId;\r\n    }\r\n\r\n    struct SpaceshipData {\r\n        Spaceship spaceship;\r\n        uint256 speed;\r\n    }\r\n\r\n    function modifyEquipment(\r\n        uint256 _spaceshipId,\r\n        uint256 _fireEquipmentId,\r\n        uint256 _lightningEquipmentId,\r\n        uint256 _steelEquipmentId\r\n    ) external;\r\n\r\n    function getSpaceship(uint256 _tokenId) external view returns (SpaceshipData memory);\r\n\r\n    function getSpeed(uint256 _tokenId) external view returns (uint256);\r\n\r\n    function getRarity(uint256 _tokenId) external view returns (AtlantisLib.Rarity);\r\n}\r\n"
    },
    "contracts/interface/IGold.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IGold is IERC20 {}\r\n"
    },
    "contracts/interface/IMintBurnToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IMintBurnToken is IERC20 {\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n\r\n    function burn(uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "contracts/interface/IStakingWithLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n\r\ninterface IStakingWithLock {\r\n     function unstakeAndBurn(uint256 _amount) external;\r\n\r\n}\r\n"
    },
    "contracts/interface/IStardust.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IStardust is IERC20 {\r\n    function unstake(uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/MockAtlantisPlanets.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interface/IAtlantisPlanets.sol\";\r\nimport \"./interface/IAtlantisGemstones.sol\";\r\nimport \"./interface/IStakingWithLock.sol\";\r\nimport \"./common/WithLimitedSupply.sol\";\r\nimport \"./common/RandomlyAssigned.sol\";\r\nimport \"./common/Base64.sol\";\r\nimport \"./AtlantisAddressRegistry.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/// @title Atlantis Planets Mint Contract\r\n/// @dev Max Supply of 6000 planets\r\n/// @dev First 12 planets are EPIC planets\r\n// Stages\r\n// 0: Before all minting commence\r\n// 1: WhiteList Sale\r\n// 2: Public sale\r\n// 3: Post-Mint (Admin Phase)\r\n// 4: Game Phase\r\n\r\ncontract MockAtlantisPlanets is ERC721, Ownable, IAtlantisPlanets, RandomlyAssigned {\r\n    using Strings for uint256;\r\n    using ECDSA for bytes32;\r\n\r\n    AtlantisAddressRegistry public addressRegistry;\r\n\r\n    string public baseURI;\r\n\r\n    uint8 public stage;\r\n    uint256 currentSupply;\r\n    uint256 public whitelistPhase;\r\n\r\n    // VIP Whitelist Mint Settings 750 cro\r\n    uint256 public vipMintMaxPerWallet = 10; // VIP Sale Address Mint Cap\r\n    uint256 public vipMintPrice = 0 ether; // VIP Sale Mint Price\r\n    mapping(address => uint256) public vipMintCount;\r\n\r\n    // Whitelist Mint Settings 850 cro\r\n    uint256 public whitelistMintMaxPerWallet = 20; // Private Sale Address Mint Cap\r\n    uint256 public whitelistMintPrice = 1 ether; // Private Sale Mint Price\r\n    mapping(address => uint256) public whitelistMintCount;\r\n    address private whitelistSignerAddress;\r\n\r\n    // Public Sale Mint Settings 950 cro\r\n    uint256 public publicMintPrice = 0 ether;\r\n    uint256 public publicMintMaxPerWallet = type(uint256).max; // Unlimited mint\r\n    mapping(address => uint256) public publicMintCount;\r\n\r\n    // Treasury\r\n    address public treasury;\r\n\r\n    // Levelling\r\n    bytes public levelUpGemstone;\r\n    // xARGO base cost\r\n    uint256 public xArgoBaseCost = 200 ether;\r\n    // stardust base cost\r\n    uint256 public stardustBaseCost = 200 ether;\r\n    // stardust base cost scaling\r\n    uint256 public stardustBaseCostScaling = 25;\r\n    // stardust rarity cost scaling\r\n    uint256 public stardustRarityCostScaling = 20;\r\n    // Mapping of planet token id to planet struct\r\n    mapping(uint256 => AtlantisLib.Planet) public planets;\r\n\r\n    // Variable to track Gemstone tiers\r\n    uint16 public constant gemstoneTiers = 4;\r\n    // Variable to track max planet level\r\n    uint16 public constant maxPlanetLevel = 50;\r\n\r\n    bool public revealed = false;\r\n    string public unrevealedImageURI = \"ipfs://bafybeicabmv4ccbblnnpfq6q5rg5sr2qqq4mc7y7y3tqyfztiwzrkff5vi\";\r\n\r\n    // gemstone token ids is in the following sequence:\r\n    // 1 - Fire 1\r\n    // 2 - Lightning 1\r\n    // 3 - Steel 1\r\n    // 4 - Fire 2\r\n    // 5 - Lightning 2\r\n    // 6 - Steel 2\r\n    // 7 - Fire 3\r\n    // 8 - Lightning 3\r\n    // 9 - Steel 3\r\n    // 10 - Fire 4\r\n    // 11 - Lightning 4\r\n    // 12 - Steel 4\r\n\r\n    // Events\r\n    event PlanetUpgraded(uint256 indexed tokenId, uint256 indexed level);\r\n    event PrivateMint(address indexed to, uint256 amount);\r\n    event PublicMint(address indexed to, uint256 amount);\r\n\r\n    // -------------------- MODIFIERS ----------------------\r\n\r\n    /**\r\n     * @dev Prevent Smart Contracts from calling the functions with this modifier\r\n     */\r\n    modifier onlyEOA() {\r\n        require(msg.sender == tx.origin, \"Planets: must use EOA\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _owner,\r\n        address _whitelistSignerAddress,\r\n        string memory __baseURI,\r\n        AtlantisAddressRegistry _addressRegistry\r\n    ) ERC721(\"Atlantis Planets\", \"PLANETS\") RandomlyAssigned(6000, 13) {\r\n        setTreasury(_owner);\r\n        setWhitelistSignerAddress(_whitelistSignerAddress);\r\n        setBaseURI(__baseURI);\r\n        transferOwnership(_owner);\r\n        currentSupply = 0;\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Revealed Metadata URI\r\n     */\r\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n        baseURI = _newBaseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Unrevealed Metadata URI\r\n     */\r\n    function setUnrevealedImageURI(string memory _newUnrevealedImageURI) public onlyOwner {\r\n        unrevealedImageURI = _newUnrevealedImageURI;\r\n    }\r\n\r\n    // -------------------- ATLANTIS PUBLIC FUNCTIONS ----------------------\r\n\r\n    /**\r\n     * @dev Get gemstone upgrade requirements for upgrading a planet\r\n     * @param _tokenId The token id of the planet\r\n     * @param _levels The number of levels to upgrade\r\n     * @return gemstoneRequirements The gemstone requirements for upgrading the planet\r\n     */\r\n    function getUpgradeRequirements(\r\n        uint256 _tokenId,\r\n        uint8 _levels\r\n    ) internal view returns (uint16[4] memory gemstoneRequirements) {\r\n        // Get planet struct\r\n        AtlantisLib.Planet memory planet = planets[_tokenId];\r\n        uint8 planetLevel = planet.level;\r\n        uint8 newLevel = planetLevel + _levels;\r\n        uint8 orbit = uint8(planet.orbit);\r\n\r\n        if (planetLevel + _levels > maxPlanetLevel) revert ExceededMaxLevel();\r\n\r\n        // Cumulative requirement at target level - Cumulative requirement at current level = requirement for upgrade\r\n        gemstoneRequirements[0] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 0) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 0);\r\n\r\n        gemstoneRequirements[1] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 1) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 1);\r\n\r\n        gemstoneRequirements[2] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 2) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 2);\r\n\r\n        gemstoneRequirements[3] =\r\n            toUint16(levelUpGemstone, orbit, newLevel, 3) -\r\n            toUint16(levelUpGemstone, orbit, planetLevel, 3);\r\n    }\r\n\r\n    /**\r\n     * @notice Get uint16 value from a byte array\r\n     * @param _bytes The byte array\r\n     * @param orbit Orbit of the planet\r\n     * @param level Level of the planet\r\n     * @param tier Tier of the gemstone\r\n     * @dev This function was modified to serve retriving the gemstone upgrade requirements\r\n     */\r\n    function toUint16(\r\n        bytes memory _bytes,\r\n        uint256 orbit,\r\n        uint256 level,\r\n        uint256 tier\r\n    ) internal pure returns (uint16 tempUint) {\r\n        uint256 _start = orbit * 8 + (level - 1) * 32 + tier * 2;\r\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get evolution stage of planet\r\n     * @param level Level of a planet\r\n     */\r\n    function _getPlanetEvolution(\r\n        uint16 level\r\n    ) internal pure returns (AtlantisLib.Evolution evo, string memory evoString) {\r\n        if (level < 20) {\r\n            evo = AtlantisLib.Evolution.ALPHA;\r\n            evoString = \"Alpha\";\r\n        } else if (level >= 20 && level < 30) {\r\n            evo = AtlantisLib.Evolution.BETA;\r\n            evoString = \"Beta\";\r\n        } else if (level >= 30 && level < 40) {\r\n            evo = AtlantisLib.Evolution.GAMMA;\r\n            evoString = \"Gamma\";\r\n        } else if (level >= 40 && level < 50) {\r\n            evo = AtlantisLib.Evolution.DELTA;\r\n            evoString = \"Delta\";\r\n        } else if (level == 50) {\r\n            evo = AtlantisLib.Evolution.EPSILON;\r\n            evoString = \"Epsilon\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get planet details\r\n     * @dev Planet details include: level, element, orbit, onExpedition\r\n     */\r\n    function getPlanetDetails(uint256 _planetId) external view returns (AtlantisLib.Planet memory) {\r\n        AtlantisLib.Planet memory planet = planets[_planetId];\r\n        return planet;\r\n    }\r\n\r\n    /**\r\n     * @notice Return xArgo cost for upgrading a planet\r\n     */\r\n    function getxArgoCost(uint8 currentLevel, uint8 newLevel) internal view returns (uint256 xArgoCost) {\r\n        if (currentLevel == 0 || currentLevel >= newLevel) revert InvalidUpgradeLevel(currentLevel, newLevel);\r\n\r\n        // Loop through all levels and add up xArgo cost\r\n        for (uint256 i = currentLevel; i < newLevel; i++) {\r\n            xArgoCost += xArgoBaseCost * i;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Return stardust cost for upgrading a planet\r\n     * @param currentLevel Current Level of Planet\r\n     * @param newLevel New planet level\r\n     * @param orbit Orbit of planet\r\n     */\r\n    function getStardustCost(\r\n        uint8 currentLevel,\r\n        uint8 newLevel,\r\n        uint8 orbit\r\n    ) internal view returns (uint256 stardustCost) {\r\n        if (currentLevel == 0 || currentLevel >= newLevel) revert InvalidUpgradeLevel(currentLevel, newLevel);\r\n\r\n        // Loop through all levels and add up stardust cost\r\n        for (uint256 i = currentLevel; i < newLevel; i++) {\r\n            stardustCost +=\r\n                (stardustBaseCost *\r\n                    (((i - 1) * stardustBaseCostScaling + 100) * ((orbit) * stardustRarityCostScaling + 100))) /\r\n                10000;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * External function for frontend to retrieve stardust, xArgo, and gemstone costs in 1 multicall\r\n     */\r\n    function getUpgradeCosts(\r\n        uint256 _tokenId,\r\n        uint8 _levels\r\n    ) external view returns (uint256 stardustCost, uint256 xArgoCost, uint16[4] memory gemstoneRequirements) {\r\n        // Get planet struct\r\n        AtlantisLib.Planet memory planet = planets[_tokenId];\r\n        uint8 planetLevel = planet.level;\r\n        uint8 newLevel = planetLevel + _levels;\r\n        uint8 orbit = uint8(planet.orbit);\r\n\r\n        require(planetLevel + _levels <= maxPlanetLevel, \"Planets: Planet cannot be upgraded to this level!\");\r\n\r\n        // Get stardust cost\r\n        stardustCost = getStardustCost(planetLevel, newLevel, orbit);\r\n\r\n        // Get xArgo cost\r\n        xArgoCost = getxArgoCost(planetLevel, newLevel);\r\n\r\n        // Get gemstone requirements\r\n        gemstoneRequirements = getUpgradeRequirements(_tokenId, _levels);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total supply of AtlantisPlanets\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return currentSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade a planet by `_levels` levels\r\n     * @param _tokenId Token ID of planet\r\n     * @param _levels Number of levels to upgrade planet by\r\n     */\r\n    function upgradePlanet(uint256 _tokenId, uint8 _levels) external {\r\n        IERC20 xARGO = IERC20(addressRegistry.getXargo());\r\n        IAtlantisGemstones atlantisGemstones = IAtlantisGemstones(addressRegistry.getGemstones());\r\n        IStakingWithLock stakingWithLock = IStakingWithLock(addressRegistry.getStakingWithLock());\r\n\r\n        // Check if upgrader is owner of planet\r\n        if (ownerOf(_tokenId) != msg.sender) revert NotOwnerOfPlanet();\r\n        // Check if stage 4\r\n        if (stage != 4) revert InvalidStage(stage, 4);\r\n\r\n        AtlantisLib.Planet storage planet = planets[_tokenId];\r\n\r\n        uint8 orbit = uint8(planet.orbit);\r\n\r\n        if (planet.level + _levels > maxPlanetLevel) revert ExceededMaxLevel();\r\n\r\n        // Get xARGO requirements\r\n        uint256 xArgoCost = getxArgoCost(planet.level, planet.level + _levels);\r\n        // Get Stardust requirements\r\n        // Base cost scaling for stardust 0.25 = 25, need math properly\r\n        uint256 stardustCost = getStardustCost(planet.level, planet.level + _levels, orbit);\r\n\r\n        // Get gemstone requirements\r\n        uint16[4] memory gemstoneRequirements = getUpgradeRequirements(_tokenId, _levels);\r\n\r\n        uint16 planetTypeTierStep = 0;\r\n        uint16 step = 1;\r\n        // Increase planet level\r\n        planet.level += _levels;\r\n        while (step <= gemstoneTiers) {\r\n            uint256 toBurn = gemstoneRequirements[step - 1];\r\n            // Burn gemstones\r\n            if (toBurn > 0) {\r\n                atlantisGemstones.burn(msg.sender, uint256(uint256(planet.element) + 1 + planetTypeTierStep), toBurn);\r\n            }\r\n            step++;\r\n            planetTypeTierStep += 3;\r\n        }\r\n        // Transfer xARGO and Stardust to this contract\r\n        xARGO.transferFrom(msg.sender, address(this), xArgoCost);\r\n        if (stardustCost > 0) {\r\n            stakingWithLock.unstakeAndBurn(stardustCost);\r\n        }\r\n\r\n        emit PlanetUpgraded(_tokenId, planet.level);\r\n    }\r\n\r\n    // -------------------- MINT FUNCTIONS --------------------------\r\n\r\n    /**\r\n     * @dev Mint planet (Whitelist only)\r\n     * @param _mintAmount Amount of planets to mint\r\n     * @param nonce Unique Nonce\r\n     * @param signature Signature provided by the signerAddress\r\n     */\r\n    function whitelistMint(\r\n        uint256 _mintAmount,\r\n        bytes memory nonce,\r\n        bytes memory signature\r\n    ) external payable onlyEOA ensureAvailabilityFor(_mintAmount) {\r\n        // Check if user is whitelisted\r\n        if (!whitelistSigned(msg.sender, nonce, signature, whitelistPhase)) revert InvalidSignature();\r\n\r\n        // Check if whitelist sale is open\r\n        if (stage != 1) revert InvalidStage(stage, 1);\r\n        if (whitelistPhase == 1) {\r\n            // Check if enough ETH is sent\r\n            if (msg.value != _mintAmount * vipMintPrice) revert InsufficientCRO(msg.value, _mintAmount * vipMintPrice);\r\n\r\n            // Check if mints does not exceed max wallet allowance for public sale\r\n            if (vipMintCount[msg.sender] + _mintAmount > vipMintMaxPerWallet) revert ExceedMaxMintPerWallet();\r\n\r\n            vipMintCount[msg.sender] += _mintAmount;\r\n        }\r\n        if (whitelistPhase == 2) {\r\n            // Check if enough ETH is sent\r\n            if (msg.value != _mintAmount * whitelistMintPrice)\r\n                revert InsufficientCRO(msg.value, _mintAmount * whitelistMintPrice);\r\n\r\n            // Check if mints does not exceed max wallet allowance for public sale\r\n            if (whitelistMintCount[msg.sender] + _mintAmount > whitelistMintMaxPerWallet)\r\n                revert ExceedMaxMintPerWallet();\r\n\r\n            whitelistMintCount[msg.sender] += _mintAmount;\r\n        }\r\n        currentSupply += _mintAmount;\r\n\r\n        for (uint256 i; i < _mintAmount; i++) {\r\n            _mintPlanet();\r\n        }\r\n        emit PrivateMint(msg.sender, _mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Public Mint\r\n     * @param _mintAmount Amount that is minted\r\n     */\r\n    function mint(uint256 _mintAmount) external payable onlyEOA ensureAvailabilityFor(_mintAmount) {\r\n        // Check if public sale is open\r\n        if (stage != 2) revert InvalidStage(stage, 2);\r\n        publicMintCount[msg.sender] += _mintAmount;\r\n        currentSupply += _mintAmount;\r\n        // Check if enough ETH is sent\r\n        if (msg.value != _mintAmount * publicMintPrice)\r\n            revert InsufficientCRO(msg.value, _mintAmount * publicMintPrice);\r\n        // Check if mints does not exceed total max supply\r\n\r\n        for (uint256 i; i < _mintAmount; i++) {\r\n            _mintPlanet();\r\n        }\r\n        emit PublicMint(msg.sender, _mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint planet\r\n     * @dev Set initial planet level to 1 and random mint to msg.sender\r\n     */\r\n    function _mintPlanet() internal {\r\n        // Get next token Id\r\n        uint256 _tokenId = nextToken();\r\n        // Initialize planet\r\n        planets[_tokenId].level = 1;\r\n        // Mint planet\r\n        _safeMint(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Set whitelist phase\r\n     * @param _whitelistPhase Phase of whitelist\r\n     */\r\n    function setWhitelistPhase(uint256 _whitelistPhase) external onlyOwner {\r\n        whitelistPhase = _whitelistPhase;\r\n    }\r\n\r\n    // -------------------- ATLANTIS ADMIN FUNCTIONS ----------------------\r\n    /**\r\n     * @dev Set planet backgrounds\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _backgrounds Backgrounds of planets\r\n     */\r\n    function setPlanetBackgrounds(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.Background[] calldata _backgrounds\r\n    ) external onlyOwner {\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Loop through planet types and set planet type\r\n        for (uint256 i; i < _backgrounds.length; i++) {\r\n            planets[_tokenIds[i]].background = _backgrounds[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set planet orbit names\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _planetOrbitNames Orbit Names of planets\r\n     */\r\n\r\n    function setPlanetOrbitNames(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.OrbitName[] calldata _planetOrbitNames\r\n    ) external onlyOwner {\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Loop through planet types and set planet type\r\n        for (uint256 i; i < _planetOrbitNames.length; i++) {\r\n            planets[_tokenIds[i]].orbitName = _planetOrbitNames[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set planet orbit\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _planetOrbits Orbit of planets\r\n     */\r\n    function setPlanetOrbits(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.Orbit[] calldata _planetOrbits\r\n    ) external onlyOwner {\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Loop through planet types and set planet type\r\n        for (uint256 i; i < _planetOrbits.length; i++) {\r\n            planets[_tokenIds[i]].orbit = _planetOrbits[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set planet element\r\n     * @param _tokenIds Token ID of planets\r\n     * @param _gemstoneTypes Element of planets\r\n     */\r\n    function setPlanetElements(\r\n        uint256[] calldata _tokenIds,\r\n        AtlantisLib.Element[] calldata _gemstoneTypes\r\n    ) external onlyOwner {\r\n        // Require stage 3\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        // Set planet type\r\n        for (uint256 i; i < _tokenIds.length; i++) {\r\n            planets[_tokenIds[i]].element = _gemstoneTypes[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set level up gemstone costs\r\n     * @param _data gemstone cost packed in bytes\r\n     * @dev _data is packed as follows:\r\n     *     Cumulative cost for each gemstone tier for each planet type\r\n     *              | Common              | Uncommon            | Rare                | Epic\r\n     *              | T1   T2   T3   T4   | T1   T2   T3   T4   | T1   T2   T3   T4   | T1   T2   T3   T4\r\n     *     Level 1  | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 0000 0000 0000 0000 | 0000 0000 0000 0000\r\n     *     ...\r\n     *     Level 50 | 0122 00af 00e1 0113 | 015c 00d2 010e 014a | 0196 00f5 013b 0181 | 01d0 0118 0168 01b8\r\n     */\r\n    function setLevelUpGemstone(bytes calldata _data) external onlyOwner {\r\n        // Require stage 3\r\n        if (stage != 3) revert InvalidStage(stage, 3);\r\n        levelUpGemstone = _data;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ERC20 Tokens From this contract\r\n     * @param _tokenAddress Address of ERC20 token\r\n     * @param _amount Amount of ERC20 token to withdraw\r\n     */\r\n    function withdrawERC20(IERC20 _tokenAddress, uint256 _amount) external onlyOwner {\r\n        _tokenAddress.transfer(treasury, _amount);\r\n    }\r\n\r\n    // Setters for base costs\r\n    /**\r\n     * @dev Set xArgo And Stardust base costs\r\n     * @param _xArgoBaseCost xArgo base cost\r\n     * @param _stardustBaseCost Stardust base cost\r\n     */\r\n    function setBaseCosts(uint256 _xArgoBaseCost, uint256 _stardustBaseCost) external onlyOwner {\r\n        xArgoBaseCost = _xArgoBaseCost;\r\n        stardustBaseCost = _stardustBaseCost;\r\n    }\r\n\r\n    // Setters for scaling\r\n    /**\r\n     * @dev Set stardust scaling costs\r\n     * @param _stardustBaseCostScaling sd base cost scaling\r\n     * @param _stardustRarityCostScaling Stardust rarity cost scaling\r\n     */\r\n    function setScaling(uint256 _stardustBaseCostScaling, uint256 _stardustRarityCostScaling) external onlyOwner {\r\n        stardustBaseCostScaling = _stardustBaseCostScaling;\r\n        stardustRarityCostScaling = _stardustRarityCostScaling;\r\n    }\r\n\r\n    // -------------------- WHITELIST FUNCTION ----------------------\r\n\r\n    /**\r\n     * @dev Checks if the the signature is signed by a valid signer for whitelist\r\n     * @param sender Address of minter\r\n     * @param nonce Random bytes32 nonce\r\n     * @param signature Signature generated off-chain\r\n     */\r\n    function whitelistSigned(\r\n        address sender,\r\n        bytes memory nonce,\r\n        bytes memory signature,\r\n        uint256 _whitelistPhase\r\n    ) private view returns (bool) {\r\n        bytes32 _hash = keccak256(abi.encodePacked(sender, nonce, _whitelistPhase));\r\n        return whitelistSignerAddress == ECDSA.toEthSignedMessageHash(_hash).recover(signature);\r\n    }\r\n\r\n    // ------------------------- ADMIN FUNCTIONS ----------------------------\r\n\r\n    /**\r\n     * @dev Set stage of minting\r\n     */\r\n    function setStage(uint8 _newStage) public onlyOwner {\r\n        stage = _newStage;\r\n    }\r\n\r\n    /**\r\n     * @dev Toggle Reveal\r\n     */\r\n    function toggleReveal() public onlyOwner {\r\n        revealed = !revealed;\r\n    }\r\n\r\n    /**\r\n     * @dev Set signer address for whitelist mint\r\n     */\r\n    function setWhitelistSignerAddress(address signer) public onlyOwner {\r\n        whitelistSignerAddress = signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Set vip mint max per wallet\r\n     */\r\n    function setVipMaxMintPerWallet(uint256 amount) public onlyOwner {\r\n        vipMintMaxPerWallet = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set vip mint price\r\n     */\r\n    function setVipMintPrice(uint256 _vipMintPrice) public onlyOwner {\r\n        vipMintPrice = _vipMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Set whitelist mint max per wallet\r\n     */\r\n    function setWhitelistMaxMintPerWallet(uint256 amount) public onlyOwner {\r\n        whitelistMintMaxPerWallet = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set public mint price\r\n     */\r\n    function setPublicMintPrice(uint256 _publicMintPrice) public onlyOwner {\r\n        publicMintPrice = _publicMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Set whitelist mint price\r\n     */\r\n    function setWhitelistMintPrice(uint256 _whitelistMintPrice) public onlyOwner {\r\n        whitelistMintPrice = _whitelistMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all CRO from this account to the owner\r\n     */\r\n    function withdrawFund() external onlyOwner {\r\n        (bool success, ) = payable(treasury).call{ value: address(this).balance }(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the treasury address\r\n     */\r\n    function setTreasury(address _treasury) public onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns if given tokenId exists in AtlantisPlanets\r\n     */\r\n    function exists(uint256 tokenId) external view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    // ------------------------- TOKEN METADATA ----------------------------\r\n\r\n    /**\r\n     * @notice Get ImageURI\r\n     */\r\n    function getImageURI(\r\n        AtlantisLib.Background background,\r\n        AtlantisLib.Element element,\r\n        AtlantisLib.OrbitName orbitName,\r\n        AtlantisLib.Evolution evo\r\n    ) public view returns (string memory) {\r\n        if (!revealed) {\r\n            return unrevealedImageURI;\r\n        }\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    _baseURI(),\r\n                    Strings.toString(uint(background)),\r\n                    \"/\",\r\n                    Strings.toString(uint(element)),\r\n                    \"/\",\r\n                    Strings.toString(uint(evo)),\r\n                    \"/\",\r\n                    Strings.toString(uint(orbitName)),\r\n                    \".png\"\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns token metadata\r\n     * @dev Metadata is stored on-chain\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n        // Get Planet\r\n        AtlantisLib.Planet memory planet = planets[tokenId];\r\n\r\n        // Get Tier from Level\r\n        (AtlantisLib.Evolution evo, string memory evoString) = _getPlanetEvolution(planet.level);\r\n\r\n        // Name\r\n        string memory json = string(abi.encodePacked('{\"name\": \"', name(), \" #\", tokenId.toString(), '\",'));\r\n\r\n        // Description\r\n        json = string(\r\n            abi.encodePacked(\r\n                json,\r\n                '\"description\": \"Welcome to the captivating realm of Atlantis, the game-verse and home of the legendary Argonauts. Planets are coveted lands that hold the key to your success in the game. Acquire planets, embark on exciting expeditions, and earn rewards that will supercharge your growth in Atlantis.\",'\r\n            )\r\n        );\r\n\r\n        // Attributes\r\n        if (!revealed) {\r\n            json = string(abi.encodePacked(json, '\"attributes\": [],'));\r\n        } else {\r\n            json = string(\r\n                abi.encodePacked(\r\n                    json,\r\n                    '\"attributes\": [{\"trait_type\": \"Element\", \"value\": \"',\r\n                    AtlantisLib._planetElementToString(planet.element),\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Background\", \"value\": \"',\r\n                    AtlantisLib._planetBackgroundToString(planet.background),\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Orbit Name\", \"value\": \"',\r\n                    AtlantisLib._planetOrbitTypeToString(planet.orbitName),\r\n                    '\"},'\r\n                )\r\n            );\r\n            json = string(\r\n                abi.encodePacked(\r\n                    json,\r\n                    '{\"trait_type\": \"Orbit\", \"value\": \"',\r\n                    AtlantisLib._planetOrbitToString(planet.orbit),\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Evolution\", \"value\": \"',\r\n                    evoString,\r\n                    '\"},',\r\n                    '{\"trait_type\": \"Level\", \"value\": \"',\r\n                    Strings.toString(planet.level),\r\n                    '\"}],'\r\n                )\r\n            );\r\n        }\r\n\r\n        json = Base64.encode(\r\n            bytes(\r\n                string(\r\n                    abi.encodePacked(\r\n                        json,\r\n                        '\"image\": \"',\r\n                        getImageURI(planet.background, planet.element, planet.orbitName, evo),\r\n                        '\"}'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Address Registry\r\n     * @param _addressRegistry The address of the Address Registry\r\n     */\r\n    function setAddressRegistry(AtlantisAddressRegistry _addressRegistry) external onlyOwner {\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    function devMint(address _to, uint256 _mintAmount) public ensureAvailabilityFor(_mintAmount) onlyOwner {\r\n        currentSupply += _mintAmount;\r\n        for (uint256 i; i < _mintAmount; i++) {\r\n            // Get next token Id\r\n            uint256 _tokenId = nextToken();\r\n            // Initialize planet\r\n            planets[_tokenId].level = 1;\r\n            // Mint planet\r\n            _safeMint(tx.origin, _tokenId);\r\n        }\r\n\r\n        emit PublicMint(_to, _mintAmount);\r\n    }\r\n\r\n    function faucetMint(address _to) public {\r\n        currentSupply += 12;\r\n        // Mint 3 fire planets, common uncommon rare epic\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 _tokenId;\r\n\r\n            _tokenId = mintAndSetProperties(_to, AtlantisLib.Element.FIRE, AtlantisLib.Orbit(i));\r\n            setOrbitAndBackground(_tokenId, i);\r\n\r\n            _tokenId = mintAndSetProperties(_to, AtlantisLib.Element.LIGHTNING, AtlantisLib.Orbit(i));\r\n            setOrbitAndBackground(_tokenId, i);\r\n\r\n            _tokenId = mintAndSetProperties(_to, AtlantisLib.Element.STEEL, AtlantisLib.Orbit(i));\r\n            setOrbitAndBackground(_tokenId, i);\r\n        }\r\n    }\r\n\r\n    function mintAndSetProperties(\r\n        address _to,\r\n        AtlantisLib.Element element,\r\n        AtlantisLib.Orbit orbit\r\n    ) internal returns (uint256 _tokenId) {\r\n        _tokenId = nextToken();\r\n        _safeMint(_to, _tokenId);\r\n        planets[_tokenId].element = element;\r\n        planets[_tokenId].level = 1;\r\n        planets[_tokenId].orbit = orbit;\r\n        return _tokenId;\r\n    }\r\n\r\n    function setOrbitAndBackground(uint256 _tokenId, uint256 i) internal {\r\n        if (i == 0) {\r\n            planets[_tokenId].orbitName = AtlantisLib.OrbitName.HALO_RING;\r\n            planets[_tokenId].background = AtlantisLib.Background.PURPLE_HUES;\r\n        } else if (i == 1) {\r\n            planets[_tokenId].orbitName = AtlantisLib.OrbitName.RAINBOW_CLOUDS;\r\n            planets[_tokenId].background = AtlantisLib.Background.WAVY;\r\n        } else if (i == 2) {\r\n            planets[_tokenId].orbitName = AtlantisLib.OrbitName.INTERSTELLAR_GRADIENT;\r\n            planets[_tokenId].background = AtlantisLib.Background.SHOOTING_STARS;\r\n        } else {\r\n            planets[_tokenId].orbitName = AtlantisLib.OrbitName.INTERSTELLAR_GOLD;\r\n            planets[_tokenId].background = AtlantisLib.Background.GOLD_SKIES;\r\n        }\r\n    }\r\n\r\n    function devEpicMint(address[12] calldata _auctionWinners) external onlyOwner {\r\n        require(_auctionWinners.length == 12, \"AtlantisPlanets: Invalid length\");\r\n        // Mint token Ids 1-12\r\n        for (uint256 i = 1; i < 13; i++) {\r\n            planets[i].level = 1;\r\n            _safeMint(_auctionWinners[i - 1], i);\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}