{
  "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_symbol",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_baseURI",
          "type": "string"
        },
        {
          "internalType": "uint16",
          "name": "maxSupply_",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "withdrawAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_whitelistSignerAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_incentiveAddress",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "_whitelistMaxMint",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "_whitelistMintPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_publicMintPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint96",
          "name": "_feeNumerator",
          "type": "uint96"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AccountBalanceOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BalanceQueryForZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTokenId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NewOwnerIsZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoHandoverRequest",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoMoreTokenIds",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotOwnerNorApproved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TokenAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TokenDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferFromIncorrectOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferToNonERC721ReceiverImplementer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferToZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WithdrawFailed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isApproved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipHandoverCanceled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipHandoverRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "newStage",
          "type": "uint8"
        }
      ],
      "name": "StageChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MAX_SUPPLY",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TEAM_ADDRESS",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cancelOwnershipHandover",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "completeOwnershipHandover",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "result",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hasMinted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "result",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "result",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "ownershipHandoverExpiresAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "publicMint",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "publicMintPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "requestOwnershipHandover",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_baseURI",
          "type": "string"
        }
      ],
      "name": "reveal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revealed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "salePrice",
          "type": "uint256"
        }
      ],
      "name": "royaltyInfo",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isApproved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_baseURI_",
          "type": "string"
        }
      ],
      "name": "setBaseURI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_receiver",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_feeNumerator",
          "type": "uint96"
        }
      ],
      "name": "setDefaultRoyalty",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_publicMintPrice",
          "type": "uint256"
        }
      ],
      "name": "setPublicMintPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "_newStage",
          "type": "uint8"
        }
      ],
      "name": "setStage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_receiver",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_feeNumerator",
          "type": "uint96"
        }
      ],
      "name": "setTokenRoyalty",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_whitelistMintPrice",
          "type": "uint256"
        }
      ],
      "name": "setWhitelistMintPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newSigner",
          "type": "address"
        }
      ],
      "name": "setWhitelistSignerAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newWithdrawAddress",
          "type": "address"
        }
      ],
      "name": "setWithdrawAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stage",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "whitelistMaxMint",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_nonce",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "whitelistMint",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "whitelistMintCount",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "whitelistMintPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "whitelistSignerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
  "receipt": {
    "to": null,
    "from": "0x6A8f07700CaF7d76BA3Ef4E8C8d0674894587877",
    "contractAddress": "0x0f844c528B1699C455D9D898F9395240e4D73911",
    "transactionIndex": 1,
    "gasUsed": "7379599",
    "logsBloom": "0x0200010105000004010400046490829216404000040000c092c001004020010008002102421200000000820c8080440200d0201200100084a006004080208441022240b040a0000100022018100000000005044004808800c00020080008082c100e080aab0102021000000000800c0400880608028082000301001000042448000000181004000000240605c020204021830080010001102280405010403a0260001220880004800806b0044080132004006800029022000804080008000050100020420892004000082001080000c00440001103204090021012050111220000c400000c160018801010024001c20000400a800000044902004800a0220200",
    "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f",
    "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000006a8f07700caf7d76ba3ef4e8c8d0674894587877"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000007b9"
        ],
        "data": "0x",
        "logIndex": 1,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000786"
        ],
        "data": "0x",
        "logIndex": 2,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c8a"
        ],
        "data": "0x",
        "logIndex": 3,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000005c9"
        ],
        "data": "0x",
        "logIndex": 4,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000179"
        ],
        "data": "0x",
        "logIndex": 5,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000010b8"
        ],
        "data": "0x",
        "logIndex": 6,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c01"
        ],
        "data": "0x",
        "logIndex": 7,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000725"
        ],
        "data": "0x",
        "logIndex": 8,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000f17"
        ],
        "data": "0x",
        "logIndex": 9,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000b05"
        ],
        "data": "0x",
        "logIndex": 10,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c99"
        ],
        "data": "0x",
        "logIndex": 11,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000159"
        ],
        "data": "0x",
        "logIndex": 12,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000008b0"
        ],
        "data": "0x",
        "logIndex": 13,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000036d"
        ],
        "data": "0x",
        "logIndex": 14,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c11"
        ],
        "data": "0x",
        "logIndex": 15,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001230"
        ],
        "data": "0x",
        "logIndex": 16,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000505"
        ],
        "data": "0x",
        "logIndex": 17,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000006aa"
        ],
        "data": "0x",
        "logIndex": 18,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000875"
        ],
        "data": "0x",
        "logIndex": 19,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000e8b"
        ],
        "data": "0x",
        "logIndex": 20,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000dfd"
        ],
        "data": "0x",
        "logIndex": 21,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000068d"
        ],
        "data": "0x",
        "logIndex": 22,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000a5e"
        ],
        "data": "0x",
        "logIndex": 23,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000b8a"
        ],
        "data": "0x",
        "logIndex": 24,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000093a"
        ],
        "data": "0x",
        "logIndex": 25,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000005b3"
        ],
        "data": "0x",
        "logIndex": 26,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001205"
        ],
        "data": "0x",
        "logIndex": 27,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000004be"
        ],
        "data": "0x",
        "logIndex": 28,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000028f"
        ],
        "data": "0x",
        "logIndex": 29,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000bfd"
        ],
        "data": "0x",
        "logIndex": 30,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000e6a"
        ],
        "data": "0x",
        "logIndex": 31,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000e39"
        ],
        "data": "0x",
        "logIndex": 32,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000020e"
        ],
        "data": "0x",
        "logIndex": 33,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000ebd"
        ],
        "data": "0x",
        "logIndex": 34,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000f06"
        ],
        "data": "0x",
        "logIndex": 35,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000611"
        ],
        "data": "0x",
        "logIndex": 36,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000cc4"
        ],
        "data": "0x",
        "logIndex": 37,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001310"
        ],
        "data": "0x",
        "logIndex": 38,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001302"
        ],
        "data": "0x",
        "logIndex": 39,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000769"
        ],
        "data": "0x",
        "logIndex": 40,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000b3a"
        ],
        "data": "0x",
        "logIndex": 41,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000010e0"
        ],
        "data": "0x",
        "logIndex": 42,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000ac7"
        ],
        "data": "0x",
        "logIndex": 43,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000007b5"
        ],
        "data": "0x",
        "logIndex": 44,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000578"
        ],
        "data": "0x",
        "logIndex": 45,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000006da"
        ],
        "data": "0x",
        "logIndex": 46,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000008e3"
        ],
        "data": "0x",
        "logIndex": 47,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000006d4"
        ],
        "data": "0x",
        "logIndex": 48,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000002b9"
        ],
        "data": "0x",
        "logIndex": 49,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000087f"
        ],
        "data": "0x",
        "logIndex": 50,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000001f1"
        ],
        "data": "0x",
        "logIndex": 51,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000ea5"
        ],
        "data": "0x",
        "logIndex": 52,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000099a"
        ],
        "data": "0x",
        "logIndex": 53,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000918"
        ],
        "data": "0x",
        "logIndex": 54,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000026b"
        ],
        "data": "0x",
        "logIndex": 55,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000d6f"
        ],
        "data": "0x",
        "logIndex": 56,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000aeb"
        ],
        "data": "0x",
        "logIndex": 57,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000001fe"
        ],
        "data": "0x",
        "logIndex": 58,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000003f7"
        ],
        "data": "0x",
        "logIndex": 59,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000044b"
        ],
        "data": "0x",
        "logIndex": 60,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000e9c"
        ],
        "data": "0x",
        "logIndex": 61,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001375"
        ],
        "data": "0x",
        "logIndex": 62,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000283"
        ],
        "data": "0x",
        "logIndex": 63,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001150"
        ],
        "data": "0x",
        "logIndex": 64,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000135b"
        ],
        "data": "0x",
        "logIndex": 65,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000010e2"
        ],
        "data": "0x",
        "logIndex": 66,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001074"
        ],
        "data": "0x",
        "logIndex": 67,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000dc1"
        ],
        "data": "0x",
        "logIndex": 68,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c92"
        ],
        "data": "0x",
        "logIndex": 69,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001218"
        ],
        "data": "0x",
        "logIndex": 70,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000011ff"
        ],
        "data": "0x",
        "logIndex": 71,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000000ff"
        ],
        "data": "0x",
        "logIndex": 72,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000011e7"
        ],
        "data": "0x",
        "logIndex": 73,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c9a"
        ],
        "data": "0x",
        "logIndex": 74,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000a74"
        ],
        "data": "0x",
        "logIndex": 75,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000ca3"
        ],
        "data": "0x",
        "logIndex": 76,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000247"
        ],
        "data": "0x",
        "logIndex": 77,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000058b"
        ],
        "data": "0x",
        "logIndex": 78,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000e92"
        ],
        "data": "0x",
        "logIndex": 79,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000006a0"
        ],
        "data": "0x",
        "logIndex": 80,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000d47"
        ],
        "data": "0x",
        "logIndex": 81,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000045c"
        ],
        "data": "0x",
        "logIndex": 82,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000d3a"
        ],
        "data": "0x",
        "logIndex": 83,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000a41"
        ],
        "data": "0x",
        "logIndex": 84,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000131a"
        ],
        "data": "0x",
        "logIndex": 85,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000004c"
        ],
        "data": "0x",
        "logIndex": 86,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001309"
        ],
        "data": "0x",
        "logIndex": 87,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000001e9"
        ],
        "data": "0x",
        "logIndex": 88,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000001140"
        ],
        "data": "0x",
        "logIndex": 89,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000007ef"
        ],
        "data": "0x",
        "logIndex": 90,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000978"
        ],
        "data": "0x",
        "logIndex": 91,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000714"
        ],
        "data": "0x",
        "logIndex": 92,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000d78"
        ],
        "data": "0x",
        "logIndex": 93,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000c4a"
        ],
        "data": "0x",
        "logIndex": 94,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000073e"
        ],
        "data": "0x",
        "logIndex": 95,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000658"
        ],
        "data": "0x",
        "logIndex": 96,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000b84"
        ],
        "data": "0x",
        "logIndex": 97,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x000000000000000000000000000000000000000000000000000000000000043d"
        ],
        "data": "0x",
        "logIndex": 98,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x0000000000000000000000000000000000000000000000000000000000000cf3"
        ],
        "data": "0x",
        "logIndex": 99,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      },
      {
        "transactionIndex": 1,
        "blockNumber": 11397263,
        "transactionHash": "0x765b4637ba8a396c4dc9868dd4502aae9f1f7bd0d9a31f0869f51ef06c9dfc5e",
        "address": "0x0f844c528B1699C455D9D898F9395240e4D73911",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000f768d8e84a04475571e807206b98840da5e8879",
          "0x00000000000000000000000000000000000000000000000000000000000010c9"
        ],
        "data": "0x",
        "logIndex": 100,
        "blockHash": "0x1d77d1bcfd252f43c1e8cb39a9d13425554d9cf786667740b269249ed52ee20f"
      }
    ],
    "blockNumber": 11397263,
    "cumulativeGasUsed": "7427240",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "KAZO",
    "KAZO",
    "ipfs://bafybeihoqbdoajoihcglk6ydim7bfemkcvo33dnfuobxyjhskiu6gq5fja/",
    5000,
    "0x6A8f07700CaF7d76BA3Ef4E8C8d0674894587877",
    "0xBDfAAD57daecf05786a5Fca0dB9BB0c7Ea2c04E0",
    "0x81A8403887CeB1f6b6AA8A2C14eDE31DB0D8744D",
    5,
    "8000000000000000",
    "10000000000000000",
    500
  ],
  "numDeployments": 7,
  "solcInputHash": "c574d5f6373440e6539e6ff8f5df7d72",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"maxSupply_\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelistSignerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_incentiveAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_whitelistMaxMint\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_whitelistMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_publicMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"_feeNumerator\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountBalanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoMoreTokenIds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newStage\",\"type\":\"uint8\"}],\"name\":\"StageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_publicMintPrice\",\"type\":\"uint256\"}],\"name\":\"setPublicMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newStage\",\"type\":\"uint8\"}],\"name\":\"setStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setTokenRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistMintPrice\",\"type\":\"uint256\"}],\"name\":\"setWhitelistMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSigner\",\"type\":\"address\"}],\"name\":\"setWhitelistSignerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWithdrawAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMaxMint\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_nonce\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistMintCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistSignerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccountBalanceOverflow()\":[{\"details\":\"The recipient's balance has overflowed.\"}],\"AlreadyInitialized()\":[{\"details\":\"Cannot double-initialize.\"}],\"BalanceQueryForZeroAddress()\":[{\"details\":\"Cannot query the balance for the zero address.\"}],\"NewOwnerIsZeroAddress()\":[{\"details\":\"The `newOwner` cannot be the zero address.\"}],\"NoHandoverRequest()\":[{\"details\":\"The `pendingOwner` does not have a valid handover request.\"}],\"NotOwnerNorApproved()\":[{\"details\":\"Only the token owner or an approved account can manage the token.\"}],\"TokenAlreadyExists()\":[{\"details\":\"The token already exists.\"}],\"TokenDoesNotExist()\":[{\"details\":\"The token does not exist.\"}],\"TransferFromIncorrectOwner()\":[{\"details\":\"The token must be owned by `from`.\"}],\"TransferToNonERC721ReceiverImplementer()\":[{\"details\":\"Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\"}],\"TransferToZeroAddress()\":[{\"details\":\"Cannot mint or transfer to the zero address.\"}],\"Unauthorized()\":[{\"details\":\"The caller is not authorized to call the function.\"}]},\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when `owner` enables `account` to manage the `id` token.\"},\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `owner` enables or disables `operator` to manage all of their tokens.\"},\"OwnershipHandoverCanceled(address)\":{\"details\":\"The ownership handover to `pendingOwner` has been canceled.\"},\"OwnershipHandoverRequested(address)\":{\"details\":\"An ownership handover to `pendingOwner` has been requested.\"},\"OwnershipTransferred(address,address)\":{\"details\":\"The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when token `id` is transferred from `from` to `to`.\"}},\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"details\":\"Sets `account` as the approved account to manage token `id`. Requirements: - Token `id` must exist. - The caller must be the owner of the token,   or an approved operator for the token owner. Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the number of tokens owned by `owner`. Requirements: - `owner` must not be the zero address.\"},\"cancelOwnershipHandover()\":{\"details\":\"Cancels the two-step ownership handover to the caller, if any.\"},\"completeOwnershipHandover(address)\":{\"details\":\"Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`.\"},\"getApproved(uint256)\":{\"details\":\"Returns the account approved to manage token `id`. Requirements: - Token `id` must exist.\"},\"isApprovedForAll(address,address)\":{\"details\":\"Returns whether `operator` is approved to manage the tokens of `owner`.\"},\"name()\":{\"details\":\"Returns the name of the token collection\",\"returns\":{\"_0\":\"Name of the token collection\"}},\"owner()\":{\"details\":\"Returns the owner of the contract.\"},\"ownerOf(uint256)\":{\"details\":\"Returns the owner of token `id`. Requirements: - Token `id` must exist.\"},\"ownershipHandoverExpiresAt(address)\":{\"details\":\"Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\"},\"publicMint(uint256)\":{\"details\":\"Public Mint\",\"params\":{\"_amount\":\"Amount to mint\"}},\"renounceOwnership()\":{\"details\":\"Allows the owner to renounce their ownership.\"},\"requestOwnershipHandover()\":{\"details\":\"Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default.\"},\"royaltyInfo(uint256,uint256)\":{\"details\":\"Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\"},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"details\":\"Transfers token `id` from `from` to `to`. Requirements: - Token `id` must exist. - `from` must be the owner of the token. - `to` cannot be the zero address. - The caller must be the owner of the token, or be approved to manage the token. - If `to` refers to a smart contract, it must implement   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"Sets whether `operator` is approved to manage the tokens of the caller. Emits an {ApprovalForAll} event.\"},\"setBaseURI(string)\":{\"details\":\"Set base URI for token metadata\",\"params\":{\"_baseURI_\":\"New base URI\"}},\"setDefaultRoyalty(address,uint96)\":{\"params\":{\"_feeNumerator\":\"Fee numerator, in basis points\",\"_receiver\":\"Address to receive royalties\"}},\"setPublicMintPrice(uint256)\":{\"details\":\"Sets the mint price for public mint\",\"params\":{\"_publicMintPrice\":\"New public mint price\"}},\"setStage(uint8)\":{\"details\":\"Sets the stage\",\"params\":{\"_newStage\":\"New stage\"}},\"setTokenRoyalty(uint256,address,uint96)\":{\"params\":{\"_feeNumerator\":\"Fee numerator, in basis points\",\"_receiver\":\"Address to receive royalties\",\"_tokenId\":\"Token ID\"}},\"setWhitelistSignerAddress(address)\":{\"details\":\"Sets the backend whitelist signer address\",\"params\":{\"_newSigner\":\"New signer address\"}},\"setWithdrawAddress(address)\":{\"details\":\"Sets the withdraw address which mint funds are sent to\",\"params\":{\"_newWithdrawAddress\":\"New withdraw address\"}},\"supportsInterface(bytes4)\":{\"details\":\"Function to adhere to EIP-2981\"},\"symbol()\":{\"details\":\"Returns the symbol of the token collection\",\"returns\":{\"_0\":\"Symbol of the token collection\"}},\"tokenURI(uint256)\":{\"details\":\"Return the metadata URI for a token\",\"params\":{\"tokenId\":\"Token ID\"},\"returns\":{\"_0\":\"Metadata URI for token\"}},\"totalSupply()\":{\"details\":\"Total supply of tokens\",\"returns\":{\"_0\":\"Total supply of tokens\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfers token `id` from `from` to `to`. Requirements: - Token `id` must exist. - `from` must be the owner of the token. - `to` cannot be the zero address. - The caller must be the owner of the token, or be approved to manage the token. Emits a {Transfer} event.\"},\"transferOwnership(address)\":{\"details\":\"Allows the owner to transfer the ownership to `newOwner`.\"},\"whitelistMint(uint256,bytes,bytes)\":{\"details\":\"Whitelist Mint Phase 1\",\"params\":{\"_amount\":\"Amount to mint\",\"_nonce\":\"Nonce to prevent replay attacks\",\"_signature\":\"Signature from backend signed by signer address if user is whitelisted\"}},\"withdraw()\":{\"details\":\"Withdraws ETH from contract to withdraw address\"}},\"title\":\"KAZO PFP Contract KAZO is a thriving community of adventurers within the Base ecosystem. KAZO holders will be able to enjoy gamified experiences through KAZO Adventures, filled with staking and questing activities. Enter the world of KAZO today.\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidTokenId()\":[{\"notice\":\"Error codes\"}]},\"events\":{\"StageChanged(uint8)\":{\"notice\":\"Event emitted when stage is changed\"}},\"kind\":\"user\",\"methods\":{\"MAX_SUPPLY()\":{\"notice\":\"Max supply of tokens\"},\"TEAM_ADDRESS()\":{\"notice\":\"Address for royalties and team NFTs\"},\"baseURI()\":{\"notice\":\"Base URI of token metadata\"},\"hasMinted(address)\":{\"notice\":\"Mapping used to track who has already minted for free mint\"},\"publicMintPrice()\":{\"notice\":\"Public mint price\"},\"revealed()\":{\"notice\":\"Flag to indicate if the collection is revealed\"},\"setDefaultRoyalty(address,uint96)\":{\"notice\":\"Used to set royalty fees for all tokens, according to EIP-2981\"},\"setTokenRoyalty(uint256,address,uint96)\":{\"notice\":\"Used to set royalty fees for a specific token, according to EIP-2981\"},\"stage()\":{\"notice\":\"Current stage\"},\"whitelistMaxMint()\":{\"notice\":\"Max amount of whitelist mint\"},\"whitelistMintCount(address)\":{\"notice\":\"Mapping used to track how many times an address has minted for whitelist mint\"},\"whitelistMintPrice()\":{\"notice\":\"Price for whitelist mint\"},\"whitelistSignerAddress()\":{\"notice\":\"Backend signer address - used to check if user is whitelisted\"},\"withdrawAddress()\":{\"notice\":\"Address to withdraw ETH to\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Kazo.sol\":\"Kazo\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC2981.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\",\"keccak256\":\"0x3976825a61df20457730b79ad0ac9c8908e3c7978ed9bf090c67137c91256b5c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/common/ERC2981.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\",\"keccak256\":\"0x990a4133f88b07f92724903f42bb25cdaeca0cf255fb48df26568c40e7c919c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/ERC721Template.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"solady/src/tokens/ERC721.sol\\\";\\r\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\r\\nimport \\\"solady/src/utils/LibString.sol\\\";\\r\\nimport \\\"solady/src/utils/ECDSA.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\r\\n\\r\\ncontract ERC721Template is ERC721, ERC2981, Ownable {\\r\\n    using LibString for uint256;\\r\\n    using ECDSA for bytes32;\\r\\n    /// @notice Error codes\\r\\n    error InvalidTokenId();\\r\\n    error NoMoreTokenIds();\\r\\n    error WithdrawFailed();\\r\\n    /// @notice Address to withdraw ETH to\\r\\n    address public withdrawAddress;\\r\\n    /// @notice Backend signer address - used to check if user is whitelisted\\r\\n    address public whitelistSignerAddress;\\r\\n    /// @notice Current stage\\r\\n    uint8 public stage;\\r\\n    /// @notice Max supply of tokens\\r\\n    uint16 public immutable MAX_SUPPLY;\\r\\n    /// @notice Number of available remaining tokens\\r\\n    uint16 internal _numAvailableRemainingTokens;\\r\\n    /// @notice Array of available remaining tokens\\r\\n    uint16[65536] internal _availableRemainingTokens;\\r\\n    /// @notice Public mint price\\r\\n    uint256 public publicMintPrice;\\r\\n    /// @notice Base URI of token metadata\\r\\n    string public baseURI;\\r\\n    /// @notice Name of token\\r\\n    string internal _name;\\r\\n    /// @notice Symbol of token\\r\\n    string internal _symbol;\\r\\n    /// @notice Event emitted when stage is changed\\r\\n    event StageChanged(uint8 newStage);\\r\\n\\r\\n    constructor(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        string memory _baseURI,\\r\\n        uint16 maxSupply_,\\r\\n        address _withdrawAddress,\\r\\n        address _whitelistSignerAddress,\\r\\n        uint256 _publicMintPrice\\r\\n    ) {\\r\\n        // Set max supply\\r\\n        MAX_SUPPLY = maxSupply_;\\r\\n        // Set available remaining tokens\\r\\n        _numAvailableRemainingTokens = maxSupply_;\\r\\n        // Set address to withdraw ETH to\\r\\n        withdrawAddress = _withdrawAddress;\\r\\n        // Set backend signer address\\r\\n        whitelistSignerAddress = _whitelistSignerAddress;\\r\\n        // Set public mint price\\r\\n        publicMintPrice = _publicMintPrice;\\r\\n        // Set name and symbol\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        // Set base URI\\r\\n        baseURI = _baseURI;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to set royalty fees for all tokens, according to EIP-2981\\r\\n     * @param _receiver Address to receive royalties\\r\\n     * @param _feeNumerator Fee numerator, in basis points\\r\\n     */\\r\\n    function setDefaultRoyalty(address _receiver, uint96 _feeNumerator) external onlyOwner {\\r\\n        _setDefaultRoyalty(_receiver, _feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to set royalty fees for a specific token, according to EIP-2981\\r\\n     * @param _tokenId Token ID\\r\\n     * @param _receiver Address to receive royalties\\r\\n     * @param _feeNumerator Fee numerator, in basis points\\r\\n     */\\r\\n\\r\\n    function setTokenRoyalty(uint256 _tokenId, address _receiver, uint96 _feeNumerator) external onlyOwner {\\r\\n        _setTokenRoyalty(_tokenId, _receiver, _feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the mint price for public mint\\r\\n     * @param _publicMintPrice New public mint price\\r\\n     */\\r\\n    function setPublicMintPrice(uint256 _publicMintPrice) external onlyOwner {\\r\\n        publicMintPrice = _publicMintPrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the stage\\r\\n     * @param _newStage New stage\\r\\n     */\\r\\n    function setStage(uint8 _newStage) external onlyOwner {\\r\\n        stage = _newStage;\\r\\n        emit StageChanged(_newStage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the backend whitelist signer address\\r\\n     * @param _newSigner New signer address\\r\\n     */\\r\\n    function setWhitelistSignerAddress(address _newSigner) external onlyOwner {\\r\\n        whitelistSignerAddress = _newSigner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the withdraw address which mint funds are sent to\\r\\n     * @param _newWithdrawAddress New withdraw address\\r\\n     */\\r\\n    function setWithdrawAddress(address _newWithdrawAddress) external onlyOwner {\\r\\n        withdrawAddress = _newWithdrawAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set base URI for token metadata\\r\\n     * @param _baseURI_ New base URI\\r\\n     */\\r\\n    function setBaseURI(string memory _baseURI_) public onlyOwner {\\r\\n        baseURI = _baseURI_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Withdraws ETH from contract to withdraw address\\r\\n     */\\r\\n    function withdraw() external {\\r\\n        (bool sent, ) = withdrawAddress.call{ value: address(this).balance }(\\\"\\\");\\r\\n        if (!sent) {\\r\\n            revert WithdrawFailed();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a random available token ID, used in pseudo random token Id generation\\r\\n     */\\r\\n    function _useRandomAvailableTokenId() internal returns (uint256) {\\r\\n        uint256 numAvailableRemainingTokens = _numAvailableRemainingTokens;\\r\\n        if (numAvailableRemainingTokens == 0) {\\r\\n            revert NoMoreTokenIds();\\r\\n        }\\r\\n\\r\\n        uint256 randomNum = _getRandomNum(numAvailableRemainingTokens);\\r\\n        uint256 randomIndex = randomNum % numAvailableRemainingTokens;\\r\\n        uint256 valAtIndex = _availableRemainingTokens[randomIndex];\\r\\n\\r\\n        uint256 result;\\r\\n        if (valAtIndex == 0) {\\r\\n            // This means the index itself is still an available token\\r\\n            result = randomIndex;\\r\\n        } else {\\r\\n            // This means the index itself is not an available token, but the val at that index is.\\r\\n            result = valAtIndex;\\r\\n        }\\r\\n\\r\\n        uint256 lastIndex = numAvailableRemainingTokens - 1;\\r\\n        if (randomIndex != lastIndex) {\\r\\n            // Replace the value at randomIndex, now that it's been used.\\r\\n            // Replace it with the data from the last index in the array, since we are going to decrease the array size afterwards.\\r\\n            uint256 lastValInArray = _availableRemainingTokens[lastIndex];\\r\\n            if (lastValInArray == 0) {\\r\\n                // This means the index itself is still an available token\\r\\n                // Cast is safe as we know that lastIndex cannot > MAX_SUPPLY, which is a uint16\\r\\n                _availableRemainingTokens[randomIndex] = uint16(lastIndex);\\r\\n            } else {\\r\\n                // This means the index itself is not an available token, but the val at that index is.\\r\\n                // Cast is safe as we know that lastValInArray cannot > MAX_SUPPLY, which is a uint16\\r\\n                _availableRemainingTokens[randomIndex] = uint16(lastValInArray);\\r\\n                delete _availableRemainingTokens[lastIndex];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        --_numAvailableRemainingTokens;\\r\\n\\r\\n        return result + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns a pseudo random number\\r\\n     * @param numAvailableRemainingTokens Number of available remaining tokens\\r\\n     * @return Pseudo random number\\r\\n     */\\r\\n    function _getRandomNum(uint256 numAvailableRemainingTokens) internal view returns (uint256) {\\r\\n        return\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encode(\\r\\n                        block.prevrandao,\\r\\n                        blockhash(block.number - 1),\\r\\n                        address(this),\\r\\n                        numAvailableRemainingTokens\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mint tokens with signature\\r\\n     * @param _amount Amount of tokens to mint\\r\\n     * @param nonce Nonce to prevent replay attacks\\r\\n     * @param signature Signature from backend signed by signer address if user is whitelisted\\r\\n     * @param _mintPrice Mint price\\r\\n     */\\r\\n    function _mintWithSignature(\\r\\n        uint256 _amount,\\r\\n        bytes calldata nonce,\\r\\n        bytes calldata signature,\\r\\n        uint256 _mintPrice\\r\\n    ) internal {\\r\\n        // Check if user is whitelisted\\r\\n        require(_whitelistSigned(msg.sender, nonce, signature, stage), \\\"Invalid Signature!\\\");\\r\\n\\r\\n        // Check if enough ETH is sent\\r\\n        require(msg.value == _amount * _mintPrice, \\\"Insufficient ETH!\\\");\\r\\n\\r\\n        // Check if mints does not exceed MAX_SUPPLY\\r\\n        require(totalSupply() + _amount <= MAX_SUPPLY, \\\"Exceeded Max Supply!\\\");\\r\\n\\r\\n        _mintWithRandomness(_amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mint tokens with public mint\\r\\n     * @param _amount Amount of tokens to mint\\r\\n     */\\r\\n    function _publicMint(uint256 _amount) internal {\\r\\n        // Check if enough ETH is sent\\r\\n        require(msg.value == _amount * publicMintPrice, \\\"Insufficient ETH\\\");\\r\\n\\r\\n        // Check if mints does not exceed MAX_SUPPLY\\r\\n        require(totalSupply() + _amount <= MAX_SUPPLY, \\\"Exceeded Max Supply!\\\");\\r\\n\\r\\n        _mintWithRandomness(_amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Dev Mint\\r\\n     * @param _amount Amount of tokens to mint\\r\\n     */\\r\\n    function _devMint(uint256 _amount, address _incentiveAddress) internal {\\r\\n        // Check if mints does not exceed MAX_SUPPLY\\r\\n        require(totalSupply() + _amount <= MAX_SUPPLY, \\\"Exceeded Max Supply!\\\");\\r\\n\\r\\n        for (uint256 i; i < _amount; ) {\\r\\n            uint256 tokenId = _useRandomAvailableTokenId();\\r\\n            super._mint(_incentiveAddress, tokenId);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mint tokens with pseudo random token ID\\r\\n     * @param _amount Amount of tokens to mint\\r\\n     */\\r\\n    function _mintWithRandomness(uint256 _amount) internal {\\r\\n        for (uint256 i; i < _amount; ) {\\r\\n            uint256 tokenId = _useRandomAvailableTokenId();\\r\\n            super._mint(msg.sender, tokenId);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Authenticate if user is whitelisted\\r\\n     * @param sender Sender address\\r\\n     * @param nonce Nonce to prevent replay attacks\\r\\n     * @param signature Signature from backend signed by signer address if user is whitelisted\\r\\n     * @param _stage Stage to check if user is whitelisted for\\r\\n     * @return True if user is whitelisted\\r\\n     */\\r\\n    function _whitelistSigned(\\r\\n        address sender,\\r\\n        bytes calldata nonce,\\r\\n        bytes calldata signature,\\r\\n        uint8 _stage\\r\\n    ) internal view returns (bool) {\\r\\n        bytes32 _hash = keccak256(abi.encodePacked(sender, nonce, _stage));\\r\\n        return whitelistSignerAddress == ECDSA.toEthSignedMessageHash(_hash).recover(signature);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to adhere to EIP-2981\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC2981) returns (bool) {\\r\\n        return ERC721.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token collection\\r\\n     * @return Name of the token collection\\r\\n     */\\r\\n    function name() public view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token collection\\r\\n     * @return Symbol of the token collection\\r\\n     */\\r\\n    function symbol() public view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Total supply of tokens\\r\\n     * @return Total supply of tokens\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        unchecked {\\r\\n            // Does not need to account for burns as they aren't supported.\\r\\n            return MAX_SUPPLY - _numAvailableRemainingTokens;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the metadata URI for a token\\r\\n     * @param tokenId Token ID\\r\\n     * @return Metadata URI for token\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        if (_ownerOf(tokenId) == address(0)) {\\r\\n            revert InvalidTokenId();\\r\\n        }\\r\\n        return string(abi.encodePacked(baseURI, tokenId.toString(), \\\".json\\\"));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x779f5f74ca5b154bc307a510afa18865428dab38e06adbd1a6c29af72c083af2\",\"license\":\"MIT\"},\"contracts/Kazo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"./ERC721Template.sol\\\";\\r\\n\\r\\n/// @title KAZO PFP Contract\\r\\n/// KAZO is a thriving community of adventurers within the Base ecosystem. KAZO holders will be able to enjoy gamified experiences through KAZO Adventures, filled with staking and questing activities. Enter the world of KAZO today.\\r\\n\\r\\ncontract Kazo is ERC721Template {\\r\\n    /// @notice Price for whitelist mint\\r\\n    uint256 public whitelistMintPrice;\\r\\n    /// @notice Max amount of whitelist mint\\r\\n    uint16 public whitelistMaxMint;\\r\\n    /// @notice Flag to indicate if the collection is revealed\\r\\n    bool public revealed;\\r\\n    /// @notice Mapping used to track how many times an address has minted for whitelist mint\\r\\n    mapping(address => uint16) public whitelistMintCount;\\r\\n    /// @notice Mapping used to track who has already minted for free mint\\r\\n    mapping(address => bool) public hasMinted;\\r\\n    /// @notice Address for royalties and team NFTs\\r\\n    address public constant TEAM_ADDRESS = 0x0f768d8E84a04475571e807206B98840Da5E8879;\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the input stage does not match the current stage\\r\\n     * @param _stage Input stage\\r\\n     */\\r\\n    modifier onlyStage(uint8 _stage) {\\r\\n        require(stage == _stage, \\\"Wrong stage!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        string memory _baseURI,\\r\\n        uint16 maxSupply_,\\r\\n        address withdrawAddress,\\r\\n        address _whitelistSignerAddress,\\r\\n        address _incentiveAddress,\\r\\n        uint16 _whitelistMaxMint,\\r\\n        uint256 _whitelistMintPrice,\\r\\n        uint256 _publicMintPrice,\\r\\n        uint96 _feeNumerator\\r\\n    ) ERC721Template(_name, _symbol, _baseURI, maxSupply_, withdrawAddress, _whitelistSignerAddress, _publicMintPrice) {\\r\\n        whitelistMintPrice = _whitelistMintPrice;\\r\\n        whitelistMaxMint = _whitelistMaxMint;\\r\\n        _setDefaultRoyalty(_incentiveAddress, _feeNumerator);\\r\\n        _initializeOwner(msg.sender);\\r\\n        _devMint();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Whitelist Mint Phase 1\\r\\n     * @param _amount Amount to mint\\r\\n     * @param _nonce Nonce to prevent replay attacks\\r\\n     * @param _signature Signature from backend signed by signer address if user is whitelisted\\r\\n     */\\r\\n    function whitelistMint(\\r\\n        uint256 _amount,\\r\\n        bytes calldata _nonce,\\r\\n        bytes calldata _signature\\r\\n    ) external payable onlyStage(1) {\\r\\n        // Check if whitelist max mint is reached\\r\\n        require(whitelistMintCount[msg.sender] + _amount <= whitelistMaxMint, \\\"Max mint reached!\\\");\\r\\n        // Increase whitelist mint count\\r\\n        whitelistMintCount[msg.sender] += uint16(_amount);\\r\\n        _mintWithSignature(_amount, _nonce, _signature, whitelistMintPrice);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public Mint\\r\\n     * @param _amount Amount to mint\\r\\n     */\\r\\n    function publicMint(uint256 _amount) external payable onlyStage(2) {\\r\\n        _publicMint(_amount);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Reveal the collection\\r\\n     * @param _baseURI Base URI for the collection\\r\\n     */\\r\\n    function reveal(string memory _baseURI) external onlyOwner {\\r\\n        revealed = true;\\r\\n        setBaseURI(_baseURI);\\r\\n    }\\r\\n\\r\\n    function _devMint() internal {\\r\\n        _devMint(100, TEAM_ADDRESS);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Set the whitelist mint price\\r\\n     * @param _whitelistMintPrice New whitelist mint price\\r\\n     */\\r\\n    function setWhitelistMintPrice(uint256 _whitelistMintPrice) external onlyOwner {\\r\\n        whitelistMintPrice = _whitelistMintPrice;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x909ec89486589f73a0a3a7a0a4093391af36a8f66fcf0b8bec197f364922547e\",\"license\":\"MIT\"},\"solady/src/auth/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xc208cdd9de02bbf4b5edad18b88e23a2be7ff56d2287d5649329dc7cda64b9a3\",\"license\":\"MIT\"},\"solady/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC721 implementation with storage hitchhiking.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC721.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)\\n///\\n/// @dev Note:\\n/// - The ERC721 standard allows for self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - For performance, methods are made payable where permitted by the ERC721 standard.\\n/// - The `safeTransfer` functions use the identity precompile (0x4)\\n///   to copy memory internally.\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC721 invariant:\\n///   the balance of an owner MUST always be equal to their number of ownership slots.\\n///   The transfer functions do not have an underflow guard for user token balances.\\n/// - Make sure all variables written to storage are properly cleaned\\n//    (e.g. the bool value for `isApprovedForAll` MUST be either 1 or 0 under the hood).\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC721 {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev An account can hold up to 4294967295 tokens.\\n    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Only the token owner or an approved account can manage the token.\\n    error NotOwnerNorApproved();\\n\\n    /// @dev The token does not exist.\\n    error TokenDoesNotExist();\\n\\n    /// @dev The token already exists.\\n    error TokenAlreadyExists();\\n\\n    /// @dev Cannot query the balance for the zero address.\\n    error BalanceQueryForZeroAddress();\\n\\n    /// @dev Cannot mint or transfer to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev The token must be owned by `from`.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev The recipient's balance has overflowed.\\n    error AccountBalanceOverflow();\\n\\n    /// @dev Cannot safely transfer to a contract that does not implement\\n    /// the ERC721Receiver interface.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The ownership data slot of `id` is given by:\\n    /// ```\\n    ///     mstore(0x00, id)\\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n    /// ```\\n    /// Bits Layout:\\n    /// - [0..159]   `addr`\\n    /// - [160..255] `extraData`\\n    ///\\n    /// The approved address slot is given by: `add(1, ownershipSlot)`.\\n    ///\\n    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip\\n    ///\\n    /// The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x1c)\\n    /// ```\\n    /// Bits Layout:\\n    /// - [0..31]   `balance`\\n    /// - [32..255] `aux`\\n    ///\\n    /// The `operator` approval slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\\n    ///     mstore(0x00, owner)\\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)\\n    /// ```\\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\\n\\n    /// @dev Pre-shifted and pre-masked constant.\\n    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      ERC721 METADATA                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the token collection name.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the token collection symbol.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           ERC721                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        result = _ownerOf(id);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(result) {\\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the number of tokens owned by `owner`.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the `owner` is the zero address.\\n            if iszero(owner) {\\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            if iszero(shl(96, sload(ownershipSlot))) {\\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := sload(add(1, ownershipSlot))\\n        }\\n    }\\n\\n    /// @dev Sets `account` as the approved account to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address account, uint256 id) public payable virtual {\\n        _approve(msg.sender, account, id);\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x1c, operator)\\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x30))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Convert to 0 or 1.\\n            isApproved := iszero(iszero(isApproved))\\n            // Update the `isApproved` for (`msg.sender`, `operator`).\\n            mstore(0x1c, operator)\\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x30), isApproved)\\n            // Emit the {ApprovalForAll} event.\\n            mstore(0x00, isApproved)\\n            // forgefmt: disable-next-item\\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public payable virtual {\\n        _beforeTokenTransfer(from, to, id);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clear the upper 96 bits.\\n            let bitmaskAddress := shr(96, not(0))\\n            from := and(bitmaskAddress, from)\\n            to := and(bitmaskAddress, to)\\n            // Load the ownership data.\\n            mstore(0x00, id)\\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let ownershipPacked := sload(ownershipSlot)\\n            let owner := and(bitmaskAddress, ownershipPacked)\\n            // Revert if `from` is not the owner, or does not exist.\\n            if iszero(mul(owner, eq(owner, from))) {\\n                if iszero(owner) {\\n                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Revert if `to` is the zero address.\\n            if iszero(to) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Load, check, and update the token approval.\\n            {\\n                mstore(0x00, from)\\n                let approvedAddress := sload(add(1, ownershipSlot))\\n                // Revert if the caller is not the owner, nor approved.\\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                }\\n                // Delete the approved address if any.\\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\\n            }\\n            // Update with the new owner.\\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\\n            // Decrement the balance of `from`.\\n            {\\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\\n            }\\n            // Increment the balance of `to`.\\n            {\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\\n                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(toBalanceSlot, toBalanceSlotPacked)\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n        _afterTokenTransfer(from, to, id);\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        payable\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL QUERY FUNCTIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance, no events are emitted for the hitchhiking setters.\\n    // Please emit your own events if required.\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint224 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\\n        }\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint224 value) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let balanceSlot := keccak256(0x0c, 0x1c)\\n            let packed := sload(balanceSlot)\\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\\n        }\\n    }\\n\\n    /// @dev Returns the extra data for token `id`.\\n    /// Minting, transferring, burning a token will not change the extra data.\\n    /// The extra data can be set on a non-existent token.\\n    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Sets the extra data for token `id` to `value`.\\n    /// Minting, transferring, burning a token will not change the extra data.\\n    /// The extra data can be set on a non-existent token.\\n    function _setExtraData(uint256 id, uint96 value) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let packed := sload(ownershipSlot)\\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Mints token `id` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must not exist.\\n    /// - `to` cannot be the zero address.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 id) internal virtual {\\n        _beforeTokenTransfer(address(0), to, id);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clear the upper 96 bits.\\n            to := shr(96, shl(96, to))\\n            // Revert if `to` is the zero address.\\n            if iszero(to) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Load the ownership data.\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let ownershipPacked := sload(ownershipSlot)\\n            // Revert if the token already exists.\\n            if shl(96, ownershipPacked) {\\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Update with the owner.\\n            sstore(ownershipSlot, or(ownershipPacked, to))\\n            // Increment the balance of the owner.\\n            {\\n                mstore(0x00, to)\\n                let balanceSlot := keccak256(0x0c, 0x1c)\\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\\n                if iszero(and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(balanceSlot, balanceSlotPacked)\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\\n        }\\n        _afterTokenTransfer(address(0), to, id);\\n    }\\n\\n    /// @dev Equivalent to `_safeMint(to, id, \\\"\\\")`.\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _safeMint(to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Mints token `id` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must not exist.\\n    /// - `to` cannot be the zero address.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `_burn(address(0), id)`.\\n    function _burn(uint256 id) internal virtual {\\n        _burn(address(0), id);\\n    }\\n\\n    /// @dev Destroys token `id`, using `by`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - If `by` is not the zero address,\\n    ///   it must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address by, uint256 id) internal virtual {\\n        address owner = ownerOf(id);\\n        _beforeTokenTransfer(owner, address(0), id);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clear the upper 96 bits.\\n            by := shr(96, shl(96, by))\\n            // Load the ownership data.\\n            mstore(0x00, id)\\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let ownershipPacked := sload(ownershipSlot)\\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\\n            owner := shr(96, shl(96, ownershipPacked))\\n            // Revert if the token does not exist.\\n            if iszero(owner) {\\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Load and check the token approval.\\n            {\\n                mstore(0x00, owner)\\n                let approvedAddress := sload(add(1, ownershipSlot))\\n                // If `by` is not the zero address, do the authorization check.\\n                // Revert if the `by` is not the owner, nor approved.\\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                }\\n                // Delete the approved address if any.\\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\\n            }\\n            // Clear the owner.\\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\\n            // Decrement the balance of `owner`.\\n            {\\n                let balanceSlot := keccak256(0x0c, 0x1c)\\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\\n        }\\n        _afterTokenTransfer(owner, address(0), id);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns whether `account` is the owner of token `id`, or is approved to manage it.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _isApprovedOrOwner(address account, uint256 id)\\n        internal\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            // Clear the upper 96 bits.\\n            account := shr(96, shl(96, account))\\n            // Load the ownership data.\\n            mstore(0x00, id)\\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\\n            // Revert if the token does not exist.\\n            if iszero(owner) {\\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Check if `account` is the `owner`.\\n            if iszero(eq(account, owner)) {\\n                mstore(0x00, owner)\\n                // Check if `account` is approved to manage the token.\\n                if iszero(sload(keccak256(0x0c, 0x30))) {\\n                    result := eq(account, sload(add(1, ownershipSlot)))\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, id)\\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `_approve(address(0), account, id)`.\\n    function _approve(address account, uint256 id) internal virtual {\\n        _approve(address(0), account, id);\\n    }\\n\\n    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - If `by` is not the zero address, `by` must be the owner\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _approve(address by, address account, uint256 id) internal virtual {\\n        assembly {\\n            // Clear the upper 96 bits.\\n            let bitmaskAddress := shr(96, not(0))\\n            account := and(bitmaskAddress, account)\\n            by := and(bitmaskAddress, by)\\n            // Load the owner of the token.\\n            mstore(0x00, id)\\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\\n            // Revert if the token does not exist.\\n            if iszero(owner) {\\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // If `by` is not the zero address, do the authorization check.\\n            // Revert if `by` is not the owner, nor approved.\\n            if iszero(or(iszero(by), eq(by, owner))) {\\n                mstore(0x00, owner)\\n                if iszero(sload(keccak256(0x0c, 0x30))) {\\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            // Sets `account` as the approved account to manage `id`.\\n            sstore(add(1, ownershipSlot), account)\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\\n        }\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `by`,\\n    /// without authorization checks.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clear the upper 96 bits.\\n            by := shr(96, shl(96, by))\\n            operator := shr(96, shl(96, operator))\\n            // Convert to 0 or 1.\\n            isApproved := iszero(iszero(isApproved))\\n            // Update the `isApproved` for (`by`, `operator`).\\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\\n            mstore(0x00, by)\\n            sstore(keccak256(0x0c, 0x30), isApproved)\\n            // Emit the {ApprovalForAll} event.\\n            mstore(0x00, isApproved)\\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.\\n    function _transfer(address from, address to, uint256 id) internal virtual {\\n        _transfer(address(0), from, to, id);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - If `by` is not the zero address,\\n    ///   it must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address by, address from, address to, uint256 id) internal virtual {\\n        _beforeTokenTransfer(from, to, id);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clear the upper 96 bits.\\n            let bitmaskAddress := shr(96, not(0))\\n            from := and(bitmaskAddress, from)\\n            to := and(bitmaskAddress, to)\\n            by := and(bitmaskAddress, by)\\n            // Load the ownership data.\\n            mstore(0x00, id)\\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\\n            let ownershipPacked := sload(ownershipSlot)\\n            let owner := and(bitmaskAddress, ownershipPacked)\\n            // Revert if `from` is not the owner, or does not exist.\\n            if iszero(mul(owner, eq(owner, from))) {\\n                if iszero(owner) {\\n                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Revert if `to` is the zero address.\\n            if iszero(to) {\\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Load, check, and update the token approval.\\n            {\\n                mstore(0x00, from)\\n                let approvedAddress := sload(add(1, ownershipSlot))\\n                // If `by` is not the zero address, do the authorization check.\\n                // Revert if the `by` is not the owner, nor approved.\\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                }\\n                // Delete the approved address if any.\\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\\n            }\\n            // Update with the new owner.\\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\\n            // Decrement the balance of `from`.\\n            {\\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\\n            }\\n            // Increment the balance of `to`.\\n            {\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\\n                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                sstore(toBalanceSlot, toBalanceSlotPacked)\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n        _afterTokenTransfer(from, to, id);\\n    }\\n\\n    /// @dev Equivalent to `_safeTransfer(from, to, id, \\\"\\\")`.\\n    function _safeTransfer(address from, address to, uint256 id) internal virtual {\\n        _safeTransfer(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _safeTransfer(address from, address to, uint256 id, bytes memory data)\\n        internal\\n        virtual\\n    {\\n        _transfer(address(0), from, to, id);\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Equivalent to `_safeTransfer(by, from, to, id, \\\"\\\")`.\\n    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\\n        _safeTransfer(by, from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - If `by` is not the zero address,\\n    ///   it must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\\n        internal\\n        virtual\\n    {\\n        _transfer(by, from, to, id);\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    HOOKS FOR OVERRIDING                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Hook that is called before any token transfers, including minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}\\n\\n    /// @dev Hook that is called after any token transfers, including minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x99ae3a9add4b6f6ee48d3e993cc4955be419c63d37f567a66e447c9c3239c192\",\"license\":\"MIT\"},\"solady/src/utils/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers.\\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: as of Solady version 0.0.68, these functions will\\n    // revert upon recovery failure for more safety by default.\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let signatureLength := mload(signature)\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        eq(signatureLength, 65), // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        eq(signature.length, 65), // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let signatureLength := mload(signature)\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    eq(signatureLength, 65), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    eq(signature.length, 65), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x707cf0ea7ce74e91e10234823d6c849c0f5948e16cba813a7142c1036a583bba\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\\n        if (smallString == bytes32(0)) return result;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n\\n            for {} 1 {} {\\n                n := add(n, 1)\\n                if iszero(byte(n, smallString)) { break } // Scan for '\\\\0'.\\n            }\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, smallString)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`. For short strings up to 32 bytes.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let x := and(b, add(not(b), 1))\\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x782d7a3d2f6e79f1a5795b236b33db8f5fb0550d06a4e867d1a59088566b7b1b\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b50604051620035a1380380620035a1833981016040819052620000349162000737565b61ffff8816608081905260038054600280546001600160a01b03808d166001600160a01b031992831617909255908a16600160a81b90940216600162ffff0160a01b0319909116179190911790556110048290558a8a8a8a8a8a876110066200009e8882620008eb565b50611007620000ae8782620008eb565b50611005620000be8682620008eb565b5050506110088890555050611009805461ffff191661ffff891617905550620000ec91508690508262000112565b620000f73362000217565b6200010162000253565b505050505050505050505062000a59565b6127106001600160601b0382161115620001865760405162461bcd60e51b815260206004820152602a60248201527f455243323938313a20726f79616c7479206665652077696c6c206578636565646044820152692073616c65507269636560b01b60648201526084015b60405180910390fd5b6001600160a01b038216620001de5760405162461bcd60e51b815260206004820152601960248201527f455243323938313a20696e76616c69642072656365697665720000000000000060448201526064016200017d565b604080518082019091526001600160a01b039092168083526001600160601b039091166020909201829052600160a01b90910217600055565b6001600160a01b0316638b78c6d8198190558060007f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a350565b620002746064730f768d8e84a04475571e807206b98840da5e887962000276565b565b60805160035461ffff808316928592600160a81b900482169003166200029d9190620009cd565b1115620002ed5760405162461bcd60e51b815260206004820152601460248201527f4578636565646564204d617820537570706c792100000000000000000000000060448201526064016200017d565b60005b828110156200031d5760006200030562000322565b905062000313838262000529565b50600101620002f0565b505050565b600354600090600160a81b900461ffff16808203620003545760405163aeb0cc9b60e01b815260040160405180910390fd5b60006200036182620005da565b90506000620003718383620009e9565b905060006004826201000081106200038d576200038d62000a0c565b601091828204019190066002029054906101000a900461ffff1661ffff169050600081600003620003c0575081620003c3565b50805b6000620003d260018762000a22565b9050808414620004d8576000600482620100008110620003f657620003f662000a0c565b601091828204019190066002029054906101000a900461ffff1661ffff1690508060000362000463578160048662010000811062000438576200043862000a0c565b601091828204019190066002026101000a81548161ffff021916908361ffff160217905550620004d6565b806004866201000081106200047c576200047c62000a0c565b601091828204019190066002026101000a81548161ffff021916908361ffff160217905550600482620100008110620004b957620004b962000a0c565b601091828204019190066002026101000a81549061ffff02191690555b505b60038054601590620004f590600160a81b900461ffff1662000a38565b91906101000a81548161ffff021916908361ffff1602179055508160016200051e9190620009cd565b965050505050505090565b6001600160a01b039091169081620005495763ea553b346000526004601cfd5b80600052673ec412a9852d173d60c11b601c5260206000208101810180548060601b156200057f5763c991cbb16000526004601cfd5b831790556000829052601c600c20805460010163ffffffff8116620005ac576301336cea6000526004601cfd5b9055808260007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8138a45050565b600044620005ea60014362000a22565b6040805160208101939093529040908201523060608201526080810183905260a00160408051601f19818403018152919052805160209091012092915050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200065257600080fd5b81516001600160401b03808211156200066f576200066f6200062a565b604051601f8301601f19908116603f011681019082821181831017156200069a576200069a6200062a565b81604052838152602092508683858801011115620006b757600080fd5b600091505b83821015620006db5785820183015181830184015290820190620006bc565b600093810190920192909252949350505050565b805161ffff811681146200070257600080fd5b919050565b80516001600160a01b03811681146200070257600080fd5b80516001600160601b03811681146200070257600080fd5b60008060008060008060008060008060006101608c8e0312156200075a57600080fd5b8b516001600160401b038111156200077157600080fd5b6200077f8e828f0162000640565b60208e0151909c5090506001600160401b038111156200079e57600080fd5b620007ac8e828f0162000640565b60408e0151909b5090506001600160401b03811115620007cb57600080fd5b620007d98e828f0162000640565b995050620007ea60608d01620006ef565b9750620007fa60808d0162000707565b96506200080a60a08d0162000707565b95506200081a60c08d0162000707565b94506200082a60e08d01620006ef565b93506101008c015192506101208c015191506200084b6101408d016200071f565b90509295989b509295989b9093969950565b600181811c908216806200087257607f821691505b6020821081036200089357634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200031d57600081815260208120601f850160051c81016020861015620008c25750805b601f850160051c820191505b81811015620008e357828155600101620008ce565b505050505050565b81516001600160401b038111156200090757620009076200062a565b6200091f816200091884546200085d565b8462000899565b602080601f8311600181146200095757600084156200093e5750858301515b600019600386901b1c1916600185901b178555620008e3565b600085815260208120601f198616915b82811015620009885788860151825594840194600190910190840162000967565b5085821015620009a75787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b634e487b7160e01b600052601160045260246000fd5b80820180821115620009e357620009e3620009b7565b92915050565b60008262000a0757634e487b7160e01b600052601260045260246000fd5b500690565b634e487b7160e01b600052603260045260246000fd5b81810381811115620009e357620009e3620009b7565b600061ffff82168062000a4f5762000a4f620009b7565b6000190192915050565b608051612b0962000a98600039600081816104310152818161052d01528181611876015281816118c1015281816119a401526119ef0152612b096000f3fe6080604052600436106102fd5760003560e01c806354d1f13d1161018f578063a22cb465116100e1578063dc53fd921161008a578063f2fde38b11610064578063f2fde38b146108ee578063f504764d14610901578063fee81cf41461092157600080fd5b8063dc53fd921461088e578063e985e9c5146108a5578063f04e283e146108db57600080fd5b8063c040e6b8116100bb578063c040e6b81461080a578063c87b56dd1461084e578063ce3cd9971461086e57600080fd5b8063a22cb465146107b7578063a611708e146107d7578063b88d4fde146107f757600080fd5b80636c0360eb11610143578063722e141d1161011d578063722e141d146107525780638da5cb5b1461076e57806395d89b41146107a257600080fd5b80636c0360eb1461071557806370a082311461072a578063715018a61461074a57600080fd5b80635944c753116101745780635944c753146106b55780635d82cf6e146106d55780636352211e146106f557600080fd5b806354d1f13d1461068d57806355f804b31461069557600080fd5b80632a55205a116102535780633ab1a494116101fc57806342842e0e116101d657806342842e0e146106395780634c2612471461064c578063518302271461066c57600080fd5b80633ab1a494146105d25780633bdf4ac6146105f25780633ccfd60b1461062457600080fd5b8063351509a81161022d578063351509a81461056257806335c6aaf81461058a57806338e21cce146105a157600080fd5b80632a55205a146104bc5780632db115441461050857806332cb6b0c1461051b57600080fd5b80631581b600116102b557806324436f771161028f57806324436f771461047457806324fccf251461048757806325692962146104b457600080fd5b80631581b600146103d357806318160ddd1461040057806323b872dd1461046157600080fd5b806306fdde03116102e657806306fdde0314610359578063081812fc1461037b578063095ea7b3146103c057600080fd5b806301ffc9a71461030257806304634d8d14610337575b600080fd5b34801561030e57600080fd5b5061032261031d3660046121cc565b610954565b60405190151581526020015b60405180910390f35b34801561034357600080fd5b50610357610352366004612255565b610991565b005b34801561036557600080fd5b5061036e6109a7565b60405161032e91906122ac565b34801561038757600080fd5b5061039b6103963660046122fd565b610a3a565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161032e565b6103576103ce366004612316565b610a8e565b3480156103df57600080fd5b5060025461039b9073ffffffffffffffffffffffffffffffffffffffff1681565b34801561040c57600080fd5b506003547501000000000000000000000000000000000000000000900461ffff9081167f000000000000000000000000000000000000000000000000000000000000000003165b60405190815260200161032e565b61035761046f366004612340565b610a99565b6103576104823660046123be565b610bf0565b34801561049357600080fd5b5060035461039b9073ffffffffffffffffffffffffffffffffffffffff1681565b610357610d31565b3480156104c857600080fd5b506104dc6104d7366004612438565b610d81565b6040805173ffffffffffffffffffffffffffffffffffffffff909316835260208301919091520161032e565b6103576105163660046122fd565b610e7a565b34801561052757600080fd5b5061054f7f000000000000000000000000000000000000000000000000000000000000000081565b60405161ffff909116815260200161032e565b34801561056e57600080fd5b5061039b730f768d8e84a04475571e807206b98840da5e887981565b34801561059657600080fd5b506104536110085481565b3480156105ad57600080fd5b506103226105bc36600461245a565b61100b6020526000908152604090205460ff1681565b3480156105de57600080fd5b506103576105ed36600461245a565b610ef2565b3480156105fe57600080fd5b5061054f61060d36600461245a565b61100a6020526000908152604090205461ffff1681565b34801561063057600080fd5b50610357610f41565b610357610647366004612340565b610fde565b34801561065857600080fd5b506103576106673660046124a4565b61100b565b34801561067857600080fd5b50611009546103229062010000900460ff1681565b61035761104a565b3480156106a157600080fd5b506103576106b03660046124a4565b611086565b3480156106c157600080fd5b506103576106d0366004612573565b61109b565b3480156106e157600080fd5b506103576106f03660046122fd565b6110ae565b34801561070157600080fd5b5061039b6107103660046122fd565b6110bc565b34801561072157600080fd5b5061036e61111c565b34801561073657600080fd5b5061045361074536600461245a565b6111ab565b6103576111fb565b34801561075e57600080fd5b506110095461054f9061ffff1681565b34801561077a57600080fd5b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739275461039b565b3480156107ae57600080fd5b5061036e61120f565b3480156107c357600080fd5b506103576107d23660046125af565b61121f565b3480156107e357600080fd5b506103576107f23660046122fd565b611275565b6103576108053660046125eb565b611283565b34801561081657600080fd5b5060035461083c9074010000000000000000000000000000000000000000900460ff1681565b60405160ff909116815260200161032e565b34801561085a57600080fd5b5061036e6108693660046122fd565b6112de565b34801561087a57600080fd5b50610357610889366004612649565b6113b0565b34801561089a57600080fd5b506104536110045481565b3480156108b157600080fd5b506103226108c036600461266c565b601c52670a5a2e7a000000006008526000526030600c205490565b6103576108e936600461245a565b611438565b6103576108fc36600461245a565b611475565b34801561090d57600080fd5b5061035761091c36600461245a565b61149c565b34801561092d57600080fd5b5061045361093c36600461245a565b63389a75e1600c908152600091909152602090205490565b600061097c826301ffc9a760e09190911c9081146380ac58cd821417635b5e139f9091141790565b8061098b575061098b826114eb565b92915050565b610999611582565b6109a382826115b8565b5050565b606061100680546109b790612696565b80601f01602080910402602001604051908101604052809291908181526020018280546109e390612696565b8015610a305780601f10610a0557610100808354040283529160200191610a30565b820191906000526020600020905b815481529060010190602001808311610a1357829003601f168201915b5050505050905090565b6000816000527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c52602060002082018201805460601b610a845763ceea21b66000526004601cfd5b6001015492915050565b6109a33383836116fd565b60008181527f7d8825530a5a2e7a0000000000000000000000000000000000000000000000003317601c526020902081018101805473ffffffffffffffffffffffffffffffffffffffff9485169493841693811691908286148302610b195782610b0b5763ceea21b66000526004601cfd5b63a11481006000526004601cfd5b84610b2c5763ea553b346000526004601cfd5b856000528160010154925082331486331417610b5a576030600c2054610b5a57634b6e7f186000526004601cfd5b8215610b6857600082600101555b85851818905550601c600c81812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019055600084905220805460010163ffffffff8116610bc0576301336cea6000526004601cfd5b90558082847fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600038a45b505050565b60035460019074010000000000000000000000000000000000000000900460ff168114610c645760405162461bcd60e51b815260206004820152600c60248201527f57726f6e6720737461676521000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6110095433600090815261100a602052604090205461ffff91821691610c8c91899116612718565b1115610cda5760405162461bcd60e51b815260206004820152601160248201527f4d6178206d696e742072656163686564210000000000000000000000000000006044820152606401610c5b565b33600090815261100a602052604081208054889290610cfe90849061ffff1661272b565b92506101000a81548161ffff021916908361ffff160217905550610d298686868686611008546117b3565b505050505050565b60006202a30067ffffffffffffffff164201905063389a75e1600c5233600052806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d600080a250565b600082815260016020908152604080832081518083019092525473ffffffffffffffffffffffffffffffffffffffff8116808352740100000000000000000000000000000000000000009091046bffffffffffffffffffffffff16928201929092528291610e3c57506040805180820190915260005473ffffffffffffffffffffffffffffffffffffffff811682527401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1660208201525b602081015160009061271090610e60906bffffffffffffffffffffffff168761274d565b610e6a9190612793565b91519350909150505b9250929050565b60035460029074010000000000000000000000000000000000000000900460ff168114610ee95760405162461bcd60e51b815260206004820152600c60248201527f57726f6e672073746167652100000000000000000000000000000000000000006044820152606401610c5b565b6109a382611946565b610efa611582565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60025460405160009173ffffffffffffffffffffffffffffffffffffffff169047908381818185875af1925050503d8060008114610f9b576040519150601f19603f3d011682016040523d82523d6000602084013e610fa0565b606091505b5050905080610fdb576040517f750b219c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b610fe9838383610a99565b813b15610beb57610beb83838360405180602001604052806000815250611a74565b611013611582565b61100980547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffff1662010000179055610fdb81611086565b63389a75e1600c523360005260006020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92600080a2565b61108e611582565b6110056109a382826127ed565b6110a3611582565b610beb838383611af8565b6110b6611582565b61100455565b60008181527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c5260209020810181015473ffffffffffffffffffffffffffffffffffffffff16806111175763ceea21b66000526004601cfd5b919050565b611005805461112a90612696565b80601f016020809104026020016040519081016040528092919081815260200182805461115690612696565b80156111a35780601f10611178576101008083540402835291602001916111a3565b820191906000526020600020905b81548152906001019060200180831161118657829003601f168201915b505050505081565b6000816111c057638f4eb6046000526004601cfd5b7f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c528160005263ffffffff601c600c2054169050919050565b611203611582565b61120d6000611c4e565b565b606061100780546109b790612696565b801515905081601c52670a5a2e7a0000000060085233600052806030600c2055806000528160601b60601c337f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3160206000a35050565b61127d611582565b61100855565b61128e858585610a99565b833b156112d7576112d785858585858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611a7492505050565b5050505050565b606060006113308360008181527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c52602090208101015473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff160361137d576040517f3f6cc76800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61100561138983611cb4565b60405160200161139a929190612907565b6040516020818303038152906040529050919050565b6113b8611582565b600380547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff167401000000000000000000000000000000000000000060ff8416908102919091179091556040519081527f273467821f33675618854603ef917ebcec8a1a39f95c43d5564ed1aefab870b39060200160405180910390a150565b611440611582565b63389a75e1600c52806000526020600c20805442111561146857636f5e88186000526004601cfd5b60009055610fdb81611c4e565b61147d611582565b8060601b61149357637448fbae6000526004601cfd5b610fdb81611c4e565b6114a4611582565b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f2a55205a00000000000000000000000000000000000000000000000000000000148061098b57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461098b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff7487392754331461120d576382b429006000526004601cfd5b6127106bffffffffffffffffffffffff8216111561163e5760405162461bcd60e51b815260206004820152602a60248201527f455243323938313a20726f79616c7479206665652077696c6c2065786365656460448201527f2073616c655072696365000000000000000000000000000000000000000000006064820152608401610c5b565b73ffffffffffffffffffffffffffffffffffffffff82166116a15760405162461bcd60e51b815260206004820152601960248201527f455243323938313a20696e76616c6964207265636569766572000000000000006044820152606401610c5b565b6040805180820190915273ffffffffffffffffffffffffffffffffffffffff9092168083526bffffffffffffffffffffffff90911660209092018290527401000000000000000000000000000000000000000090910217600055565b60001960601c8281169250838116935081600052837f7d8825530a5a2e7a00000000000000000000000000000000000000000000000017601c52602060002082018201805482169150816117595763ceea21b66000526004601cfd5b81851485151761177f57816000526030600c205461177f57634b6e7f186000526004601cfd5b6001018390558183827f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600038a450505050565b6117d03386868686600360149054906101000a900460ff16611d16565b61181c5760405162461bcd60e51b815260206004820152601260248201527f496e76616c6964205369676e61747572652100000000000000000000000000006044820152606401610c5b565b611826818761274d565b34146118745760405162461bcd60e51b815260206004820152601160248201527f496e73756666696369656e7420455448210000000000000000000000000000006044820152606401610c5b565b7f000000000000000000000000000000000000000000000000000000000000000061ffff16866118e560035461ffff750100000000000000000000000000000000000000000090910481167f0000000000000000000000000000000000000000000000000000000000000000031690565b6118ef9190612718565b111561193d5760405162461bcd60e51b815260206004820152601460248201527f4578636565646564204d617820537570706c79210000000000000000000000006044820152606401610c5b565b610d2986611dbd565b61100454611954908261274d565b34146119a25760405162461bcd60e51b815260206004820152601060248201527f496e73756666696369656e7420455448000000000000000000000000000000006044820152606401610c5b565b7f000000000000000000000000000000000000000000000000000000000000000061ffff1681611a1360035461ffff750100000000000000000000000000000000000000000090910481167f0000000000000000000000000000000000000000000000000000000000000000031690565b611a1d9190612718565b1115611a6b5760405162461bcd60e51b815260206004820152601460248201527f4578636565646564204d617820537570706c79210000000000000000000000006044820152606401610c5b565b610fdb81611dbd565b60405163150b7a028082523360208301528560601b60601c604083015283606083015260808083015282518060a08401528015611abb578060c08401826020870160045afa505b60208360a48301601c860160008a5af1611ade573d15611ade573d6000843e3d83fd5b508060e01b825114610d295763d1a57ed66000526004601cfd5b6127106bffffffffffffffffffffffff82161115611b7e5760405162461bcd60e51b815260206004820152602a60248201527f455243323938313a20726f79616c7479206665652077696c6c2065786365656460448201527f2073616c655072696365000000000000000000000000000000000000000000006064820152608401610c5b565b73ffffffffffffffffffffffffffffffffffffffff8216611be15760405162461bcd60e51b815260206004820152601b60248201527f455243323938313a20496e76616c696420706172616d657465727300000000006044820152606401610c5b565b60408051808201825273ffffffffffffffffffffffffffffffffffffffff93841681526bffffffffffffffffffffffff9283166020808301918252600096875260019052919094209351905190911674010000000000000000000000000000000000000000029116179055565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927805473ffffffffffffffffffffffffffffffffffffffff9092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a355565b60606080604051019050602081016040526000815280600019835b928101926030600a8206018453600a900480611ccf5750508190037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909101908152919050565b60008087878785604051602001611d3094939291906129d4565b604051602081830303815290604052805190602001209050611d9385858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611d8d9250859150611de79050565b90611e12565b60035473ffffffffffffffffffffffffffffffffffffffff91821691161498975050505050505050565b60005b818110156109a3576000611dd2611e6b565b9050611dde3382612090565b50600101611dc0565b6020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b6000604051825184600052606084015160001a602052602084015160405260408401516060526020600160806000604185145afa519250503d611e5d57638baa579f6000526004601cfd5b600060605260405292915050565b6003546000907501000000000000000000000000000000000000000000900461ffff16808203611ec7576040517faeb0cc9b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611ed282612160565b90506000611ee08383612a41565b90506000600482620100008110611ef957611ef9612a55565b601091828204019190066002029054906101000a900461ffff1661ffff169050600081600003611f2a575081611f2d565b50805b6000611f3a600187612a84565b9050808414612031576000600482620100008110611f5a57611f5a612a55565b601091828204019190066002029054906101000a900461ffff1661ffff16905080600003611fc25781600486620100008110611f9857611f98612a55565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555061202f565b80600486620100008110611fd857611fd8612a55565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555060048262010000811061201257612012612a55565b601091828204019190066002026101000a81549061ffff02191690555b505b6003805460159061205e907501000000000000000000000000000000000000000000900461ffff16612a97565b91906101000a81548161ffff021916908361ffff1602179055508160016120859190612718565b965050505050505090565b73ffffffffffffffffffffffffffffffffffffffff90911690816120bc5763ea553b346000526004601cfd5b806000527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c5260206000208101810180548060601b156121065763c991cbb16000526004601cfd5b831790556000829052601c600c20805460010163ffffffff8116612132576301336cea6000526004601cfd5b9055808260007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8138a45050565b60004461216e600143612a84565b6040805160208101939093529040908201523060608201526080810183905260a001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012092915050565b6000602082840312156121de57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461220e57600080fd5b9392505050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461111757600080fd5b80356bffffffffffffffffffffffff8116811461111757600080fd5b6000806040838503121561226857600080fd5b61227183612215565b915061227f60208401612239565b90509250929050565b60005b838110156122a357818101518382015260200161228b565b50506000910152565b60208152600082518060208401526122cb816040850160208701612288565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60006020828403121561230f57600080fd5b5035919050565b6000806040838503121561232957600080fd5b61233283612215565b946020939093013593505050565b60008060006060848603121561235557600080fd5b61235e84612215565b925061236c60208501612215565b9150604084013590509250925092565b60008083601f84011261238e57600080fd5b50813567ffffffffffffffff8111156123a657600080fd5b602083019150836020828501011115610e7357600080fd5b6000806000806000606086880312156123d657600080fd5b85359450602086013567ffffffffffffffff808211156123f557600080fd5b61240189838a0161237c565b9096509450604088013591508082111561241a57600080fd5b506124278882890161237c565b969995985093965092949392505050565b6000806040838503121561244b57600080fd5b50508035926020909101359150565b60006020828403121561246c57600080fd5b61220e82612215565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000602082840312156124b657600080fd5b813567ffffffffffffffff808211156124ce57600080fd5b818401915084601f8301126124e257600080fd5b8135818111156124f4576124f4612475565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561253a5761253a612475565b8160405282815287602084870101111561255357600080fd5b826020860160208301376000928101602001929092525095945050505050565b60008060006060848603121561258857600080fd5b8335925061259860208501612215565b91506125a660408501612239565b90509250925092565b600080604083850312156125c257600080fd5b6125cb83612215565b9150602083013580151581146125e057600080fd5b809150509250929050565b60008060008060006080868803121561260357600080fd5b61260c86612215565b945061261a60208701612215565b935060408601359250606086013567ffffffffffffffff81111561263d57600080fd5b6124278882890161237c565b60006020828403121561265b57600080fd5b813560ff8116811461220e57600080fd5b6000806040838503121561267f57600080fd5b61268883612215565b915061227f60208401612215565b600181811c908216806126aa57607f821691505b6020821081036126e3577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561098b5761098b6126e9565b61ffff818116838216019080821115612746576127466126e9565b5092915050565b808202811582820484141761098b5761098b6126e9565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000826127a2576127a2612764565b500490565b601f821115610beb57600081815260208120601f850160051c810160208610156127ce5750805b601f850160051c820191505b81811015610d29578281556001016127da565b815167ffffffffffffffff81111561280757612807612475565b61281b816128158454612696565b846127a7565b602080601f83116001811461286e57600084156128385750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b178555610d29565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b828110156128bb5788860151825594840194600190910190840161289c565b50858210156128f757878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b600080845461291581612696565b6001828116801561292d57600181146129605761298f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff008416875282151583028701945061298f565b8860005260208060002060005b858110156129865781548a82015290840190820161296d565b50505082870194505b5050505083516129a3818360208801612288565b7f2e6a736f6e0000000000000000000000000000000000000000000000000000009101908152600501949350505050565b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008560601b1681528284601483013760f89190911b7fff00000000000000000000000000000000000000000000000000000000000000166014919092019081019190915260150192915050565b600082612a5057612a50612764565b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b8181038181111561098b5761098b6126e9565b600061ffff821680612aab57612aab6126e9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019291505056fea2646970667358221220b941507b9a4300c9db062478dfb48083e9092b419b2c17c9a4cc675a9f61ad3364736f6c63430008130033",
  "deployedBytecode": "0x6080604052600436106102fd5760003560e01c806354d1f13d1161018f578063a22cb465116100e1578063dc53fd921161008a578063f2fde38b11610064578063f2fde38b146108ee578063f504764d14610901578063fee81cf41461092157600080fd5b8063dc53fd921461088e578063e985e9c5146108a5578063f04e283e146108db57600080fd5b8063c040e6b8116100bb578063c040e6b81461080a578063c87b56dd1461084e578063ce3cd9971461086e57600080fd5b8063a22cb465146107b7578063a611708e146107d7578063b88d4fde146107f757600080fd5b80636c0360eb11610143578063722e141d1161011d578063722e141d146107525780638da5cb5b1461076e57806395d89b41146107a257600080fd5b80636c0360eb1461071557806370a082311461072a578063715018a61461074a57600080fd5b80635944c753116101745780635944c753146106b55780635d82cf6e146106d55780636352211e146106f557600080fd5b806354d1f13d1461068d57806355f804b31461069557600080fd5b80632a55205a116102535780633ab1a494116101fc57806342842e0e116101d657806342842e0e146106395780634c2612471461064c578063518302271461066c57600080fd5b80633ab1a494146105d25780633bdf4ac6146105f25780633ccfd60b1461062457600080fd5b8063351509a81161022d578063351509a81461056257806335c6aaf81461058a57806338e21cce146105a157600080fd5b80632a55205a146104bc5780632db115441461050857806332cb6b0c1461051b57600080fd5b80631581b600116102b557806324436f771161028f57806324436f771461047457806324fccf251461048757806325692962146104b457600080fd5b80631581b600146103d357806318160ddd1461040057806323b872dd1461046157600080fd5b806306fdde03116102e657806306fdde0314610359578063081812fc1461037b578063095ea7b3146103c057600080fd5b806301ffc9a71461030257806304634d8d14610337575b600080fd5b34801561030e57600080fd5b5061032261031d3660046121cc565b610954565b60405190151581526020015b60405180910390f35b34801561034357600080fd5b50610357610352366004612255565b610991565b005b34801561036557600080fd5b5061036e6109a7565b60405161032e91906122ac565b34801561038757600080fd5b5061039b6103963660046122fd565b610a3a565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161032e565b6103576103ce366004612316565b610a8e565b3480156103df57600080fd5b5060025461039b9073ffffffffffffffffffffffffffffffffffffffff1681565b34801561040c57600080fd5b506003547501000000000000000000000000000000000000000000900461ffff9081167f000000000000000000000000000000000000000000000000000000000000000003165b60405190815260200161032e565b61035761046f366004612340565b610a99565b6103576104823660046123be565b610bf0565b34801561049357600080fd5b5060035461039b9073ffffffffffffffffffffffffffffffffffffffff1681565b610357610d31565b3480156104c857600080fd5b506104dc6104d7366004612438565b610d81565b6040805173ffffffffffffffffffffffffffffffffffffffff909316835260208301919091520161032e565b6103576105163660046122fd565b610e7a565b34801561052757600080fd5b5061054f7f000000000000000000000000000000000000000000000000000000000000000081565b60405161ffff909116815260200161032e565b34801561056e57600080fd5b5061039b730f768d8e84a04475571e807206b98840da5e887981565b34801561059657600080fd5b506104536110085481565b3480156105ad57600080fd5b506103226105bc36600461245a565b61100b6020526000908152604090205460ff1681565b3480156105de57600080fd5b506103576105ed36600461245a565b610ef2565b3480156105fe57600080fd5b5061054f61060d36600461245a565b61100a6020526000908152604090205461ffff1681565b34801561063057600080fd5b50610357610f41565b610357610647366004612340565b610fde565b34801561065857600080fd5b506103576106673660046124a4565b61100b565b34801561067857600080fd5b50611009546103229062010000900460ff1681565b61035761104a565b3480156106a157600080fd5b506103576106b03660046124a4565b611086565b3480156106c157600080fd5b506103576106d0366004612573565b61109b565b3480156106e157600080fd5b506103576106f03660046122fd565b6110ae565b34801561070157600080fd5b5061039b6107103660046122fd565b6110bc565b34801561072157600080fd5b5061036e61111c565b34801561073657600080fd5b5061045361074536600461245a565b6111ab565b6103576111fb565b34801561075e57600080fd5b506110095461054f9061ffff1681565b34801561077a57600080fd5b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739275461039b565b3480156107ae57600080fd5b5061036e61120f565b3480156107c357600080fd5b506103576107d23660046125af565b61121f565b3480156107e357600080fd5b506103576107f23660046122fd565b611275565b6103576108053660046125eb565b611283565b34801561081657600080fd5b5060035461083c9074010000000000000000000000000000000000000000900460ff1681565b60405160ff909116815260200161032e565b34801561085a57600080fd5b5061036e6108693660046122fd565b6112de565b34801561087a57600080fd5b50610357610889366004612649565b6113b0565b34801561089a57600080fd5b506104536110045481565b3480156108b157600080fd5b506103226108c036600461266c565b601c52670a5a2e7a000000006008526000526030600c205490565b6103576108e936600461245a565b611438565b6103576108fc36600461245a565b611475565b34801561090d57600080fd5b5061035761091c36600461245a565b61149c565b34801561092d57600080fd5b5061045361093c36600461245a565b63389a75e1600c908152600091909152602090205490565b600061097c826301ffc9a760e09190911c9081146380ac58cd821417635b5e139f9091141790565b8061098b575061098b826114eb565b92915050565b610999611582565b6109a382826115b8565b5050565b606061100680546109b790612696565b80601f01602080910402602001604051908101604052809291908181526020018280546109e390612696565b8015610a305780601f10610a0557610100808354040283529160200191610a30565b820191906000526020600020905b815481529060010190602001808311610a1357829003601f168201915b5050505050905090565b6000816000527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c52602060002082018201805460601b610a845763ceea21b66000526004601cfd5b6001015492915050565b6109a33383836116fd565b60008181527f7d8825530a5a2e7a0000000000000000000000000000000000000000000000003317601c526020902081018101805473ffffffffffffffffffffffffffffffffffffffff9485169493841693811691908286148302610b195782610b0b5763ceea21b66000526004601cfd5b63a11481006000526004601cfd5b84610b2c5763ea553b346000526004601cfd5b856000528160010154925082331486331417610b5a576030600c2054610b5a57634b6e7f186000526004601cfd5b8215610b6857600082600101555b85851818905550601c600c81812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019055600084905220805460010163ffffffff8116610bc0576301336cea6000526004601cfd5b90558082847fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600038a45b505050565b60035460019074010000000000000000000000000000000000000000900460ff168114610c645760405162461bcd60e51b815260206004820152600c60248201527f57726f6e6720737461676521000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6110095433600090815261100a602052604090205461ffff91821691610c8c91899116612718565b1115610cda5760405162461bcd60e51b815260206004820152601160248201527f4d6178206d696e742072656163686564210000000000000000000000000000006044820152606401610c5b565b33600090815261100a602052604081208054889290610cfe90849061ffff1661272b565b92506101000a81548161ffff021916908361ffff160217905550610d298686868686611008546117b3565b505050505050565b60006202a30067ffffffffffffffff164201905063389a75e1600c5233600052806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d600080a250565b600082815260016020908152604080832081518083019092525473ffffffffffffffffffffffffffffffffffffffff8116808352740100000000000000000000000000000000000000009091046bffffffffffffffffffffffff16928201929092528291610e3c57506040805180820190915260005473ffffffffffffffffffffffffffffffffffffffff811682527401000000000000000000000000000000000000000090046bffffffffffffffffffffffff1660208201525b602081015160009061271090610e60906bffffffffffffffffffffffff168761274d565b610e6a9190612793565b91519350909150505b9250929050565b60035460029074010000000000000000000000000000000000000000900460ff168114610ee95760405162461bcd60e51b815260206004820152600c60248201527f57726f6e672073746167652100000000000000000000000000000000000000006044820152606401610c5b565b6109a382611946565b610efa611582565b600280547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60025460405160009173ffffffffffffffffffffffffffffffffffffffff169047908381818185875af1925050503d8060008114610f9b576040519150601f19603f3d011682016040523d82523d6000602084013e610fa0565b606091505b5050905080610fdb576040517f750b219c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b610fe9838383610a99565b813b15610beb57610beb83838360405180602001604052806000815250611a74565b611013611582565b61100980547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffff1662010000179055610fdb81611086565b63389a75e1600c523360005260006020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92600080a2565b61108e611582565b6110056109a382826127ed565b6110a3611582565b610beb838383611af8565b6110b6611582565b61100455565b60008181527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c5260209020810181015473ffffffffffffffffffffffffffffffffffffffff16806111175763ceea21b66000526004601cfd5b919050565b611005805461112a90612696565b80601f016020809104026020016040519081016040528092919081815260200182805461115690612696565b80156111a35780601f10611178576101008083540402835291602001916111a3565b820191906000526020600020905b81548152906001019060200180831161118657829003601f168201915b505050505081565b6000816111c057638f4eb6046000526004601cfd5b7f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c528160005263ffffffff601c600c2054169050919050565b611203611582565b61120d6000611c4e565b565b606061100780546109b790612696565b801515905081601c52670a5a2e7a0000000060085233600052806030600c2055806000528160601b60601c337f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3160206000a35050565b61127d611582565b61100855565b61128e858585610a99565b833b156112d7576112d785858585858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611a7492505050565b5050505050565b606060006113308360008181527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c52602090208101015473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff160361137d576040517f3f6cc76800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61100561138983611cb4565b60405160200161139a929190612907565b6040516020818303038152906040529050919050565b6113b8611582565b600380547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff167401000000000000000000000000000000000000000060ff8416908102919091179091556040519081527f273467821f33675618854603ef917ebcec8a1a39f95c43d5564ed1aefab870b39060200160405180910390a150565b611440611582565b63389a75e1600c52806000526020600c20805442111561146857636f5e88186000526004601cfd5b60009055610fdb81611c4e565b61147d611582565b8060601b61149357637448fbae6000526004601cfd5b610fdb81611c4e565b6114a4611582565b600380547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f2a55205a00000000000000000000000000000000000000000000000000000000148061098b57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000083161461098b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff7487392754331461120d576382b429006000526004601cfd5b6127106bffffffffffffffffffffffff8216111561163e5760405162461bcd60e51b815260206004820152602a60248201527f455243323938313a20726f79616c7479206665652077696c6c2065786365656460448201527f2073616c655072696365000000000000000000000000000000000000000000006064820152608401610c5b565b73ffffffffffffffffffffffffffffffffffffffff82166116a15760405162461bcd60e51b815260206004820152601960248201527f455243323938313a20696e76616c6964207265636569766572000000000000006044820152606401610c5b565b6040805180820190915273ffffffffffffffffffffffffffffffffffffffff9092168083526bffffffffffffffffffffffff90911660209092018290527401000000000000000000000000000000000000000090910217600055565b60001960601c8281169250838116935081600052837f7d8825530a5a2e7a00000000000000000000000000000000000000000000000017601c52602060002082018201805482169150816117595763ceea21b66000526004601cfd5b81851485151761177f57816000526030600c205461177f57634b6e7f186000526004601cfd5b6001018390558183827f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600038a450505050565b6117d03386868686600360149054906101000a900460ff16611d16565b61181c5760405162461bcd60e51b815260206004820152601260248201527f496e76616c6964205369676e61747572652100000000000000000000000000006044820152606401610c5b565b611826818761274d565b34146118745760405162461bcd60e51b815260206004820152601160248201527f496e73756666696369656e7420455448210000000000000000000000000000006044820152606401610c5b565b7f000000000000000000000000000000000000000000000000000000000000000061ffff16866118e560035461ffff750100000000000000000000000000000000000000000090910481167f0000000000000000000000000000000000000000000000000000000000000000031690565b6118ef9190612718565b111561193d5760405162461bcd60e51b815260206004820152601460248201527f4578636565646564204d617820537570706c79210000000000000000000000006044820152606401610c5b565b610d2986611dbd565b61100454611954908261274d565b34146119a25760405162461bcd60e51b815260206004820152601060248201527f496e73756666696369656e7420455448000000000000000000000000000000006044820152606401610c5b565b7f000000000000000000000000000000000000000000000000000000000000000061ffff1681611a1360035461ffff750100000000000000000000000000000000000000000090910481167f0000000000000000000000000000000000000000000000000000000000000000031690565b611a1d9190612718565b1115611a6b5760405162461bcd60e51b815260206004820152601460248201527f4578636565646564204d617820537570706c79210000000000000000000000006044820152606401610c5b565b610fdb81611dbd565b60405163150b7a028082523360208301528560601b60601c604083015283606083015260808083015282518060a08401528015611abb578060c08401826020870160045afa505b60208360a48301601c860160008a5af1611ade573d15611ade573d6000843e3d83fd5b508060e01b825114610d295763d1a57ed66000526004601cfd5b6127106bffffffffffffffffffffffff82161115611b7e5760405162461bcd60e51b815260206004820152602a60248201527f455243323938313a20726f79616c7479206665652077696c6c2065786365656460448201527f2073616c655072696365000000000000000000000000000000000000000000006064820152608401610c5b565b73ffffffffffffffffffffffffffffffffffffffff8216611be15760405162461bcd60e51b815260206004820152601b60248201527f455243323938313a20496e76616c696420706172616d657465727300000000006044820152606401610c5b565b60408051808201825273ffffffffffffffffffffffffffffffffffffffff93841681526bffffffffffffffffffffffff9283166020808301918252600096875260019052919094209351905190911674010000000000000000000000000000000000000000029116179055565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927805473ffffffffffffffffffffffffffffffffffffffff9092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a355565b60606080604051019050602081016040526000815280600019835b928101926030600a8206018453600a900480611ccf5750508190037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909101908152919050565b60008087878785604051602001611d3094939291906129d4565b604051602081830303815290604052805190602001209050611d9385858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611d8d9250859150611de79050565b90611e12565b60035473ffffffffffffffffffffffffffffffffffffffff91821691161498975050505050505050565b60005b818110156109a3576000611dd2611e6b565b9050611dde3382612090565b50600101611dc0565b6020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b6000604051825184600052606084015160001a602052602084015160405260408401516060526020600160806000604185145afa519250503d611e5d57638baa579f6000526004601cfd5b600060605260405292915050565b6003546000907501000000000000000000000000000000000000000000900461ffff16808203611ec7576040517faeb0cc9b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000611ed282612160565b90506000611ee08383612a41565b90506000600482620100008110611ef957611ef9612a55565b601091828204019190066002029054906101000a900461ffff1661ffff169050600081600003611f2a575081611f2d565b50805b6000611f3a600187612a84565b9050808414612031576000600482620100008110611f5a57611f5a612a55565b601091828204019190066002029054906101000a900461ffff1661ffff16905080600003611fc25781600486620100008110611f9857611f98612a55565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555061202f565b80600486620100008110611fd857611fd8612a55565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555060048262010000811061201257612012612a55565b601091828204019190066002026101000a81549061ffff02191690555b505b6003805460159061205e907501000000000000000000000000000000000000000000900461ffff16612a97565b91906101000a81548161ffff021916908361ffff1602179055508160016120859190612718565b965050505050505090565b73ffffffffffffffffffffffffffffffffffffffff90911690816120bc5763ea553b346000526004601cfd5b806000527f7d8825530a5a2e7a000000000000000000000000000000000000000000000000601c5260206000208101810180548060601b156121065763c991cbb16000526004601cfd5b831790556000829052601c600c20805460010163ffffffff8116612132576301336cea6000526004601cfd5b9055808260007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8138a45050565b60004461216e600143612a84565b6040805160208101939093529040908201523060608201526080810183905260a001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012092915050565b6000602082840312156121de57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461220e57600080fd5b9392505050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461111757600080fd5b80356bffffffffffffffffffffffff8116811461111757600080fd5b6000806040838503121561226857600080fd5b61227183612215565b915061227f60208401612239565b90509250929050565b60005b838110156122a357818101518382015260200161228b565b50506000910152565b60208152600082518060208401526122cb816040850160208701612288565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160400192915050565b60006020828403121561230f57600080fd5b5035919050565b6000806040838503121561232957600080fd5b61233283612215565b946020939093013593505050565b60008060006060848603121561235557600080fd5b61235e84612215565b925061236c60208501612215565b9150604084013590509250925092565b60008083601f84011261238e57600080fd5b50813567ffffffffffffffff8111156123a657600080fd5b602083019150836020828501011115610e7357600080fd5b6000806000806000606086880312156123d657600080fd5b85359450602086013567ffffffffffffffff808211156123f557600080fd5b61240189838a0161237c565b9096509450604088013591508082111561241a57600080fd5b506124278882890161237c565b969995985093965092949392505050565b6000806040838503121561244b57600080fd5b50508035926020909101359150565b60006020828403121561246c57600080fd5b61220e82612215565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000602082840312156124b657600080fd5b813567ffffffffffffffff808211156124ce57600080fd5b818401915084601f8301126124e257600080fd5b8135818111156124f4576124f4612475565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190838211818310171561253a5761253a612475565b8160405282815287602084870101111561255357600080fd5b826020860160208301376000928101602001929092525095945050505050565b60008060006060848603121561258857600080fd5b8335925061259860208501612215565b91506125a660408501612239565b90509250925092565b600080604083850312156125c257600080fd5b6125cb83612215565b9150602083013580151581146125e057600080fd5b809150509250929050565b60008060008060006080868803121561260357600080fd5b61260c86612215565b945061261a60208701612215565b935060408601359250606086013567ffffffffffffffff81111561263d57600080fd5b6124278882890161237c565b60006020828403121561265b57600080fd5b813560ff8116811461220e57600080fd5b6000806040838503121561267f57600080fd5b61268883612215565b915061227f60208401612215565b600181811c908216806126aa57607f821691505b6020821081036126e3577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561098b5761098b6126e9565b61ffff818116838216019080821115612746576127466126e9565b5092915050565b808202811582820484141761098b5761098b6126e9565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000826127a2576127a2612764565b500490565b601f821115610beb57600081815260208120601f850160051c810160208610156127ce5750805b601f850160051c820191505b81811015610d29578281556001016127da565b815167ffffffffffffffff81111561280757612807612475565b61281b816128158454612696565b846127a7565b602080601f83116001811461286e57600084156128385750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b178555610d29565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b828110156128bb5788860151825594840194600190910190840161289c565b50858210156128f757878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b600080845461291581612696565b6001828116801561292d57600181146129605761298f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff008416875282151583028701945061298f565b8860005260208060002060005b858110156129865781548a82015290840190820161296d565b50505082870194505b5050505083516129a3818360208801612288565b7f2e6a736f6e0000000000000000000000000000000000000000000000000000009101908152600501949350505050565b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008560601b1681528284601483013760f89190911b7fff00000000000000000000000000000000000000000000000000000000000000166014919092019081019190915260150192915050565b600082612a5057612a50612764565b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b8181038181111561098b5761098b6126e9565b600061ffff821680612aab57612aab6126e9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019291505056fea2646970667358221220b941507b9a4300c9db062478dfb48083e9092b419b2c17c9a4cc675a9f61ad3364736f6c63430008130033",
  "devdoc": {
    "errors": {
      "AccountBalanceOverflow()": [
        {
          "details": "The recipient's balance has overflowed."
        }
      ],
      "AlreadyInitialized()": [
        {
          "details": "Cannot double-initialize."
        }
      ],
      "BalanceQueryForZeroAddress()": [
        {
          "details": "Cannot query the balance for the zero address."
        }
      ],
      "NewOwnerIsZeroAddress()": [
        {
          "details": "The `newOwner` cannot be the zero address."
        }
      ],
      "NoHandoverRequest()": [
        {
          "details": "The `pendingOwner` does not have a valid handover request."
        }
      ],
      "NotOwnerNorApproved()": [
        {
          "details": "Only the token owner or an approved account can manage the token."
        }
      ],
      "TokenAlreadyExists()": [
        {
          "details": "The token already exists."
        }
      ],
      "TokenDoesNotExist()": [
        {
          "details": "The token does not exist."
        }
      ],
      "TransferFromIncorrectOwner()": [
        {
          "details": "The token must be owned by `from`."
        }
      ],
      "TransferToNonERC721ReceiverImplementer()": [
        {
          "details": "Cannot safely transfer to a contract that does not implement the ERC721Receiver interface."
        }
      ],
      "TransferToZeroAddress()": [
        {
          "details": "Cannot mint or transfer to the zero address."
        }
      ],
      "Unauthorized()": [
        {
          "details": "The caller is not authorized to call the function."
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "details": "Emitted when `owner` enables `account` to manage the `id` token."
      },
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `owner` enables or disables `operator` to manage all of their tokens."
      },
      "OwnershipHandoverCanceled(address)": {
        "details": "The ownership handover to `pendingOwner` has been canceled."
      },
      "OwnershipHandoverRequested(address)": {
        "details": "An ownership handover to `pendingOwner` has been requested."
      },
      "OwnershipTransferred(address,address)": {
        "details": "The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event."
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when token `id` is transferred from `from` to `to`."
      }
    },
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "details": "Sets `account` as the approved account to manage token `id`. Requirements: - Token `id` must exist. - The caller must be the owner of the token,   or an approved operator for the token owner. Emits an {Approval} event."
      },
      "balanceOf(address)": {
        "details": "Returns the number of tokens owned by `owner`. Requirements: - `owner` must not be the zero address."
      },
      "cancelOwnershipHandover()": {
        "details": "Cancels the two-step ownership handover to the caller, if any."
      },
      "completeOwnershipHandover(address)": {
        "details": "Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`."
      },
      "getApproved(uint256)": {
        "details": "Returns the account approved to manage token `id`. Requirements: - Token `id` must exist."
      },
      "isApprovedForAll(address,address)": {
        "details": "Returns whether `operator` is approved to manage the tokens of `owner`."
      },
      "name()": {
        "details": "Returns the name of the token collection",
        "returns": {
          "_0": "Name of the token collection"
        }
      },
      "owner()": {
        "details": "Returns the owner of the contract."
      },
      "ownerOf(uint256)": {
        "details": "Returns the owner of token `id`. Requirements: - Token `id` must exist."
      },
      "ownershipHandoverExpiresAt(address)": {
        "details": "Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`."
      },
      "publicMint(uint256)": {
        "details": "Public Mint",
        "params": {
          "_amount": "Amount to mint"
        }
      },
      "renounceOwnership()": {
        "details": "Allows the owner to renounce their ownership."
      },
      "requestOwnershipHandover()": {
        "details": "Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default."
      },
      "royaltyInfo(uint256,uint256)": {
        "details": "Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of exchange. The royalty amount is denominated and should be paid in that same unit of exchange."
      },
      "safeTransferFrom(address,address,uint256)": {
        "details": "Equivalent to `safeTransferFrom(from, to, id, \"\")`."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "details": "Transfers token `id` from `from` to `to`. Requirements: - Token `id` must exist. - `from` must be the owner of the token. - `to` cannot be the zero address. - The caller must be the owner of the token, or be approved to manage the token. - If `to` refers to a smart contract, it must implement   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
      },
      "setApprovalForAll(address,bool)": {
        "details": "Sets whether `operator` is approved to manage the tokens of the caller. Emits an {ApprovalForAll} event."
      },
      "setBaseURI(string)": {
        "details": "Set base URI for token metadata",
        "params": {
          "_baseURI_": "New base URI"
        }
      },
      "setDefaultRoyalty(address,uint96)": {
        "params": {
          "_feeNumerator": "Fee numerator, in basis points",
          "_receiver": "Address to receive royalties"
        }
      },
      "setPublicMintPrice(uint256)": {
        "details": "Sets the mint price for public mint",
        "params": {
          "_publicMintPrice": "New public mint price"
        }
      },
      "setStage(uint8)": {
        "details": "Sets the stage",
        "params": {
          "_newStage": "New stage"
        }
      },
      "setTokenRoyalty(uint256,address,uint96)": {
        "params": {
          "_feeNumerator": "Fee numerator, in basis points",
          "_receiver": "Address to receive royalties",
          "_tokenId": "Token ID"
        }
      },
      "setWhitelistSignerAddress(address)": {
        "details": "Sets the backend whitelist signer address",
        "params": {
          "_newSigner": "New signer address"
        }
      },
      "setWithdrawAddress(address)": {
        "details": "Sets the withdraw address which mint funds are sent to",
        "params": {
          "_newWithdrawAddress": "New withdraw address"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Function to adhere to EIP-2981"
      },
      "symbol()": {
        "details": "Returns the symbol of the token collection",
        "returns": {
          "_0": "Symbol of the token collection"
        }
      },
      "tokenURI(uint256)": {
        "details": "Return the metadata URI for a token",
        "params": {
          "tokenId": "Token ID"
        },
        "returns": {
          "_0": "Metadata URI for token"
        }
      },
      "totalSupply()": {
        "details": "Total supply of tokens",
        "returns": {
          "_0": "Total supply of tokens"
        }
      },
      "transferFrom(address,address,uint256)": {
        "details": "Transfers token `id` from `from` to `to`. Requirements: - Token `id` must exist. - `from` must be the owner of the token. - `to` cannot be the zero address. - The caller must be the owner of the token, or be approved to manage the token. Emits a {Transfer} event."
      },
      "transferOwnership(address)": {
        "details": "Allows the owner to transfer the ownership to `newOwner`."
      },
      "whitelistMint(uint256,bytes,bytes)": {
        "details": "Whitelist Mint Phase 1",
        "params": {
          "_amount": "Amount to mint",
          "_nonce": "Nonce to prevent replay attacks",
          "_signature": "Signature from backend signed by signer address if user is whitelisted"
        }
      },
      "withdraw()": {
        "details": "Withdraws ETH from contract to withdraw address"
      }
    },
    "title": "KAZO PFP Contract KAZO is a thriving community of adventurers within the Base ecosystem. KAZO holders will be able to enjoy gamified experiences through KAZO Adventures, filled with staking and questing activities. Enter the world of KAZO today.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidTokenId()": [
        {
          "notice": "Error codes"
        }
      ]
    },
    "events": {
      "StageChanged(uint8)": {
        "notice": "Event emitted when stage is changed"
      }
    },
    "kind": "user",
    "methods": {
      "MAX_SUPPLY()": {
        "notice": "Max supply of tokens"
      },
      "TEAM_ADDRESS()": {
        "notice": "Address for royalties and team NFTs"
      },
      "baseURI()": {
        "notice": "Base URI of token metadata"
      },
      "hasMinted(address)": {
        "notice": "Mapping used to track who has already minted for free mint"
      },
      "publicMintPrice()": {
        "notice": "Public mint price"
      },
      "revealed()": {
        "notice": "Flag to indicate if the collection is revealed"
      },
      "setDefaultRoyalty(address,uint96)": {
        "notice": "Used to set royalty fees for all tokens, according to EIP-2981"
      },
      "setTokenRoyalty(uint256,address,uint96)": {
        "notice": "Used to set royalty fees for a specific token, according to EIP-2981"
      },
      "stage()": {
        "notice": "Current stage"
      },
      "whitelistMaxMint()": {
        "notice": "Max amount of whitelist mint"
      },
      "whitelistMintCount(address)": {
        "notice": "Mapping used to track how many times an address has minted for whitelist mint"
      },
      "whitelistMintPrice()": {
        "notice": "Price for whitelist mint"
      },
      "whitelistSignerAddress()": {
        "notice": "Backend signer address - used to check if user is whitelisted"
      },
      "withdrawAddress()": {
        "notice": "Address to withdraw ETH to"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 35,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "_defaultRoyaltyInfo",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(RoyaltyInfo)32_storage"
      },
      {
        "astId": 40,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "_tokenRoyaltyInfo",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_struct(RoyaltyInfo)32_storage)"
      },
      {
        "astId": 281,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "withdrawAddress",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 284,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "whitelistSignerAddress",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 287,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "stage",
        "offset": 20,
        "slot": "3",
        "type": "t_uint8"
      },
      {
        "astId": 293,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "_numAvailableRemainingTokens",
        "offset": 21,
        "slot": "3",
        "type": "t_uint16"
      },
      {
        "astId": 298,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "_availableRemainingTokens",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_uint16)65536_storage"
      },
      {
        "astId": 301,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "publicMintPrice",
        "offset": 0,
        "slot": "4100",
        "type": "t_uint256"
      },
      {
        "astId": 304,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "baseURI",
        "offset": 0,
        "slot": "4101",
        "type": "t_string_storage"
      },
      {
        "astId": 307,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "_name",
        "offset": 0,
        "slot": "4102",
        "type": "t_string_storage"
      },
      {
        "astId": 310,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "_symbol",
        "offset": 0,
        "slot": "4103",
        "type": "t_string_storage"
      },
      {
        "astId": 921,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "whitelistMintPrice",
        "offset": 0,
        "slot": "4104",
        "type": "t_uint256"
      },
      {
        "astId": 924,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "whitelistMaxMint",
        "offset": 0,
        "slot": "4105",
        "type": "t_uint16"
      },
      {
        "astId": 927,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "revealed",
        "offset": 2,
        "slot": "4105",
        "type": "t_bool"
      },
      {
        "astId": 932,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "whitelistMintCount",
        "offset": 0,
        "slot": "4106",
        "type": "t_mapping(t_address,t_uint16)"
      },
      {
        "astId": 937,
        "contract": "contracts/Kazo.sol:Kazo",
        "label": "hasMinted",
        "offset": 0,
        "slot": "4107",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint16)65536_storage": {
        "base": "t_uint16",
        "encoding": "inplace",
        "label": "uint16[65536]",
        "numberOfBytes": "131072"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_uint16)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint16)",
        "numberOfBytes": "32",
        "value": "t_uint16"
      },
      "t_mapping(t_uint256,t_struct(RoyaltyInfo)32_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ERC2981.RoyaltyInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(RoyaltyInfo)32_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(RoyaltyInfo)32_storage": {
        "encoding": "inplace",
        "label": "struct ERC2981.RoyaltyInfo",
        "members": [
          {
            "astId": 29,
            "contract": "contracts/Kazo.sol:Kazo",
            "label": "receiver",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 31,
            "contract": "contracts/Kazo.sol:Kazo",
            "label": "royaltyFraction",
            "offset": 20,
            "slot": "0",
            "type": "t_uint96"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      },
      "t_uint96": {
        "encoding": "inplace",
        "label": "uint96",
        "numberOfBytes": "12"
      }
    }
  }
}